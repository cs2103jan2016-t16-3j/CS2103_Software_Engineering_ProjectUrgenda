# A0127358Y
###### urgenda\command\Demo.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

public class Demo extends Command {

	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.DEMO);
		data.clearShowMoreTasks();
		return null;
	}

}
```
###### urgenda\command\Edit.java
``` java
package urgenda.command;

import java.time.LocalDateTime;
import java.util.ArrayList;

import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * 
 * Edit is the command object used for editing of task in Urgenda.
 * 
 */
public class Edit extends TaskCommand {

	private static final String MESSAGE_NO_EDIT_MATCH = "Invalid task number. No matches found to edit";
	private static final String MESSAGE_EDIT = " has been edited to ";
	private static final String MESSAGE_REVERTED = " has been reverted to ";
	private static final String MESSAGE_ERROR = "Error: ";
	private static final String MESSAGE_OVERLAP = " Warning: Overlaps with ";
	private static final String MESSAGE_EVENT_PASSED = " Warning: Event added has already passed";
	private static final String MESSAGE_DEADLINE_PASSED = " Warning: Deadline added has already passed";

	private static UrgendaLogger logger = UrgendaLogger.getInstance();
	private LogicData _data;
	private Integer _id;
	private Task _prevTask;
	// a copy of prevTask for edition and comparison of time so that time in
	// prevTask will not get modified during execution
	private Task _temp;
	// new copy of task for edition w info for edition entered by user
	private Task _newTask = new Task();
	// a timing variable for storing of time that user entered w/o starttime and
	// or endtime flag
	LocalDateTime _unknown;
	// a boolean variable to indicate removal of one timing (change of task type
	// from event to deadline or deadline to floating
	boolean isRemoveOnce = false;
	// a boolean variable to indicate removal of a second timing (only set as
	// true after isRemoveOnce is alr set as true)
	// for change of task type from event to floating
	boolean isRemoveTwice = false;

	/**
	 * Execute command of Edit which edits _prevTask to _newTask.
	 */
	public String execute() throws LogicException {
		_data = LogicData.getInstance();
		if (_id != null && _id.intValue() > -1) {
			_prevTask = _data.findMatchingPosition(_id.intValue());
			_temp = new Task(_prevTask);
		}
		if (_prevTask == null) {
			_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			logger.getLogger().severe("Exception(No edit match) thrown");
			throw new LogicException(MESSAGE_NO_EDIT_MATCH);
		} else {
			performEdition();
			updateEdition();
			String warning = checkValidity();
			return taskMessageWithLocation(_prevTask) + MESSAGE_EDIT + taskMessageWithLocation(_newTask) + warning;
		}
	}

	/*
	 * method to check for warnings, start time after end time etc and set pointer to
	 * edited task.
	 */
	private String checkValidity() throws LogicException {
		String warning;
		try {
			checkTaskValidity(_newTask);
			_data.deleteTask(_prevTask);
			_data.addTask(_newTask);
			_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			_data.setTaskPointer(_newTask);
			_data.clearShowMoreTasks();
			warning = checkPassed();
			warning += findOverlaps();
		} catch (LogicException e) {
			logger.getLogger().severe("Exception occured: " + e);
			_data.setCurrState(LogicData.DisplayState.INVALID_TASK);
			// throws exception to prevent Edit being added to undo stack
			throw new LogicException(MESSAGE_ERROR + e.getMessage());
		}
		return warning;
	}

	/*
	 * Method to update fields that are non-editable through edit command by users e.g.
	 * multislot, priority, datemodified etc.
	 */
	private void updateEdition() {
		_newTask.setId(_prevTask.getId());
		_newTask.setSlot(_prevTask.getSlot());
		_newTask.setIsCompleted(_prevTask.isCompleted());
		_newTask.setIsImportant(_prevTask.isImportant());
		_newTask.setDateAdded(_prevTask.getDateAdded());
		_newTask.updateTaskType();
		updateDateModified();
	}

	/*
	 * Method to perform edition of prev task to new task.
	 */
	private void performEdition() {
		setMultiSlots();
		removeTimings();
		_temp.updateTaskType();
		setDesc();
		setLocation();
		setNewTimings();
	}

	private void setNewTimings() {
		if (_unknown == null) {
			setDefiniteTime();
		} else {
			determineUnclearTimings();
			setDefiniteTime();
		}
	}

	/*
	 * Method to determine whether timing entered is for edition of start/end time 
	 * if user input it w/o start &/ end flag.
	 */
	private void determineUnclearTimings() {
		switch (_temp.getTaskType()) {
		case FLOATING: // Fallthrough
		case DEADLINE:
			// if prevtask is of type float/event (after removal of time had alr
			// been performed), set unknown as endtime.
			setUnknownAsEndTime();
			break;
		default:
			// if prevTask is of type event, compare unknown w task time
			checkStartEndAndSetUnknown();
			break;
		}
	}

	/*
	 * if user entered new timing w/o start/end time, if task to be
	 * edited(_temp) is of type event. Check if new timing entered is before
	 * _temp start time, set new timing as starttime if new timing entered is
	 * after _temp end time, set new timing as endtime. Else if is in btwn, take
	 * default as changing start, set to start time.
	 */
	private void checkStartEndAndSetUnknown() {
		if (_newTask.getStartTime() == null && _newTask.getEndTime() == null) {
			if (_unknown.isBefore(_temp.getStartTime())) {
				_newTask.setStartTime(_unknown);
			} else if (_unknown.isAfter(_temp.getEndTime())) {
				_newTask.setEndTime(_unknown);
			} else {
				_newTask.setStartTime(_unknown);
			}
		} else { 
			// when user enter 2 new time to be edited, one w flag one w/o falg
			// e.g. 7pm to 10pm instead of from 7pm to 10pm, the unknown non-flag one
			// could be determined
			if (_newTask.getEndTime() == null) {
				_newTask.setEndTime(_unknown);
			} else {
				_newTask.setStartTime(_unknown);
			}
		}
	}

	private void setUnknownAsEndTime() {
		if (_newTask.getStartTime() == null && _newTask.getEndTime() == null) {
			_newTask.setEndTime(_unknown);
		} else {
			if (_newTask.getEndTime() == null) {
				_newTask.setEndTime(_unknown);
			} else {
				_newTask.setStartTime(_unknown);
			}
		}
	}

	// when user enter timing to be edited w flag, set to _newTask accordingly.
	private void setDefiniteTime() {
		if (_newTask.getStartTime() == null) {
			_newTask.setStartTime(_temp.getStartTime());
		}
		if (_newTask.getEndTime() == null) {
			_newTask.setEndTime(_temp.getEndTime());
		}
	}

	private void setLocation() {
		if (_newTask.getLocation() == null || _newTask.getLocation().equals("") 
				&& _prevTask.getLocation() != null) {
			_newTask.setLocation(_prevTask.getLocation());
		}
	}

	private void setDesc() {
		if (_newTask.getDesc() == null || _newTask.getDesc().equals("") 
				&& _prevTask.getDesc() != null) {
			_newTask.setDesc(_prevTask.getDesc());
		}
	}

	private void setMultiSlots() {
		if (_newTask.getSlot() == null || _newTask.getSlot().isEmpty()) {
			_newTask.setSlot(null);
		}
	}

	private void removeTimings() {
		if (isRemoveOnce) {
			if (_temp.getStartTime() != null) {
				_temp.setStartTime(null);
			} else {
				_temp.setEndTime(null);
			}
		}
		if (isRemoveTwice) {
			_temp.setEndTime(null);
		}
	}

	private void updateDateModified() {
		_newTask.setDateModified(LocalDateTime.now());
		_prevTask.setDateModified(LocalDateTime.now());
	}

	private String checkPassed() {
		if (_newTask.getTaskType() == Task.Type.EVENT) {
			if (_newTask.getEndTime().isBefore(LocalDateTime.now())) {
				return MESSAGE_EVENT_PASSED;
			}
		} else if (_newTask.getTaskType() == Task.Type.DEADLINE) {
			if (_newTask.getEndTime().isBefore(LocalDateTime.now())) {
				return MESSAGE_DEADLINE_PASSED;
			}
		}
		return "";
	}

	private String findOverlaps() {
		ArrayList<Task> overlaps;
		overlaps = _data.overlappingTasks(_newTask);
		assert(overlaps.size() >= 0);

		if (overlaps.size() == 0) {
			return "";
		} else {
			String feedback = MESSAGE_OVERLAP + taskMessage(overlaps.get(0));
			overlaps.remove(0);
			for (Task task : overlaps) {
				feedback += ", " + taskMessage(task);
			}
			return feedback;
		}
	}

	/**
	 * Undo method of Edit which undo the revert the task edited back to
	 * original.
	 */
	public String undo() {
		updateDateModified();
		_data.deleteTask(_newTask);
		_data.addTask(_prevTask);
		_data.setTaskPointer(_prevTask);
		return taskMessageWithLocation(_newTask) + MESSAGE_REVERTED + taskMessageWithLocation(_prevTask);
	}

	/**
	 * Redo method of Edit which redo the action and edit the task to the new
	 * version.
	 */
	public String redo() {
		updateDateModified();
		_data.deleteTask(_prevTask);
		_data.addTask(_newTask);
		_data.setTaskPointer(_newTask);
		return taskMessageWithLocation(_prevTask) + MESSAGE_EDIT + taskMessageWithLocation(_newTask) + findOverlaps();
	}

	/**
	 * Setter for the position of the task to be edited.
	 * 
	 * @param id
	 */
	public void setId(int id) {
		_id = Integer.valueOf(id);
	}

	/**
	 * Setter for the new edited task containing info of the fields to be edited
	 * (e.g. new desc, location, timings etc).
	 * 
	 * @param newTask
	 */
	public void setNewTask(Task newTask) {
		_newTask = newTask;
	}

	/**
	 * Setter for unknown, a LocalDateTime variable for storing of timing that
	 * user entered w/o starttime andor endtime flags.
	 * 
	 * @param unknown
	 */
	public void setUnknown(LocalDateTime unknown) {
		_unknown = unknown;
	}

	/**
	 * Setter for boolean variable isRemovedOnce which is used to indicate the
	 * removal of one timing (change of task type).
	 */
	public void setIsRemovedOnce() {
		isRemoveOnce = true;
	}

	/**
	 * Setter for boolean variable isRemovedTwice (only set after isRemovedOnce
	 * had alr been set as true) which is used to indicate the removal of two
	 * timings.
	 */
	public void setIsRemovedTwice() {
		isRemoveTwice = true;
	}
}
```
###### urgenda\command\Exit.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * 
 * Exit is the command object used for exiting and closing of Urgenda.
 *
 */

public class Exit extends Command {

	/**
	 * Execute command of Exit which closes Urgenda.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.EXIT);
		return null;
	}

}
```
###### urgenda\command\Help.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * 
 * Help is the command object used for generating help (user manual) of Urgenda. 
 *
 */
public class Help extends Command {	

	/**
	 * Execute command of Help which set current state of system to HELP.state and 
	 * hence indicates to display help guide to user.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.HELP);
		return "";
	}

}
```
###### urgenda\command\Hide.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

public class Hide extends Command {
	
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.HIDE);
		return null;
	}

}
```
###### urgenda\command\Home.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * 
 * Home is the command object used for returning display screen to displaying all tasks.
 *
 */
public class Home extends Command {
	
	private static final String MESSAGE_HOME = "Showing all tasks";

	/**
	 * Execute command of Home which return user's display screen to showing all tasks.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		data.clearShowMoreTasks();
		return MESSAGE_HOME;
	}

}
```
###### urgenda\command\Recurrence.java
``` java
//Unused feature due to change of additional special feature towards the end. Decided to go for nicer and 
//more rewarding feature Good Gui rather than recurring task. Hence this feature has not been fully tested, implemented
//and refactored. Left it here for the effort spent, probably deleting it in the end.
//Unused feature due to change of additional special feature towards the end. Decided to go for nicer and 
//more rewarding feature Good Gui rather than recurring task. Hence this feature has not been fully tested, implemented
//and refactored. Left it here for the effort spent, probably deleting it in the end.
package urgenda.command;

import java.time.LocalDateTime;
import java.util.ArrayList;

import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.MultipleSlot;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * 
 * Recurrence command object used for performing recurring tasks in Urgenda
 *
 */
public class Recurrence extends TaskCommand {

	private static UrgendaLogger logger = UrgendaLogger.getInstance();
	private static final String MESSAGE_NO_RECURR_MATCH = "Invalid task number. No matches found to set as recurring";
	private static final String MESSAGE_ERROR = "ERROR:";
	private static final String MESSAGE_INVALID = "Insufficient reccurrence info entered";
	private static final String MESSAGE_TYPE_ERROR = "ERROR: Invalid Task Type for recurrence";
	private static final String MESSAGE_RECURR = " has been set as recurring task";
	private static final String MESSAGE_RECURR_TASK = "Recurring task ";
	private static final String MESSAGE_REMOVED = " removed";
	private static final String MESSAGE_ADDED = " added";
	private static final String MESSAGE_EVENT_PASSED = "\nWarning: Event added has already passed";
	private static final String MESSAGE_DEADLINE_PASSED = "\nWarning: Deadline added has already passed";
	private static final String MESSAGE_OVERLAP = "\nWarning: Overlaps with ";
	private static final String MESSAGE_NONRECURR = " has been reverted to non-recurring";

	private MultipleSlot _recurr;
	private LogicData _data;
	private Task _newTask;
	private Task _recurrTask;
	private Integer _id;
	private Integer _minutes;
	private Integer _hours;
	private Integer _days;
	private Integer _weeks;
	private Integer _months;
	private Integer _years;
	private Integer _length;

	public Recurrence() {
	}

	public String execute() throws LogicException {
		_data = LogicData.getInstance();
		if (_id != null && _id.intValue() > -1) {
			_recurrTask = _data.findMatchingPosition(_id.intValue());
		}
		if (_recurrTask == null) {
			_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			logger.getLogger().severe("Exception(No edit match) thrown");
			throw new LogicException(MESSAGE_NO_RECURR_MATCH);
		} else {
			_newTask = new Task(_recurrTask);
		}
		_recurr = _newTask.getSlot();
		if (_length == null) {
			_length = Integer.MAX_VALUE;
		}
		switch (_newTask.getTaskType()) {
		case DEADLINE:
			LocalDateTime start = null;
			LocalDateTime end = _newTask.getEndTime();
			for (int i = 0; i < (_length).intValue(); i++) {
				if (_minutes != null) {
					end = end.plusMinutes(_minutes);
				}
				if (_hours != null) {
					end = end.plusHours(_hours);
				}
				if (_days != null) {
					end = end.plusDays(_days);
				}
				if (_weeks != null) {
					end = end.plusWeeks(_weeks);
				}
				if (_months != null) {
					end = end.plusMonths(_months);
				}
				if (_months != null) {
					end = end.plusYears(_years);
				}
				_recurr.addTimeSlot(start, end);
			}
			break;
		case EVENT:
			start = _newTask.getStartTime();
			end = _newTask.getEndTime();
			for (int i = 0; i < (_length).intValue(); i++) {
				if (_minutes != null) {
					start = start.plusMinutes(_minutes);
					end = end.plusMinutes(_minutes);
				}
				if (_hours != null) {
					start = start.plusHours(_hours);
					end = end.plusHours(_hours);
				}
				if (_days != null) {
					start = start.plusDays(_days);
					end = end.plusDays(_days);
				}
				if (_weeks != null) {
					start = start.plusWeeks(_weeks);
					end = end.plusWeeks(_weeks);
				}
				if (_months != null) {
					start = start.plusMonths(_months);
					end = end.plusMonths(_months);
				}
				if (_months != null) {
					start = start.plusYears(_years);
					end = end.plusYears(_years);
				}
				_recurr.addTimeSlot(start, end);
			}
			break;
		default:
			throw new LogicException(MESSAGE_TYPE_ERROR);
		}
		if (_recurr.isEmpty() || _recurr.equals(null)) {
			throw new LogicException(MESSAGE_INVALID);
		}

		// _newTask.toggleRecurring(); attribute to be added to task to indicate task is of type recurring 
		//highlight to gui to only show start time, end time and first datetimepair in multiple slot 
		_newTask.setSlot(_recurr);
		LocalDateTime now = LocalDateTime.now();
		if (_id != null) {
			_newTask.setId(_data.getCurrentId());
			_newTask.setDateAdded(now);
			_data.updateCurrentId();
		}
		_newTask.setDateModified(now);
		_newTask.updateTaskType();
		String feedback = "";
		try {
			checkTaskValidity(_newTask);
			_data.addTask(_newTask);
			if (_id != null) {
				_data.deleteTask(_recurrTask);
			}
			_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			_data.setTaskPointer(_newTask);
			_data.clearShowMoreTasks();
			if (_id == null) {
				feedback = checkPassed();
				feedback += findOverlaps();
			}
		} catch (LogicException e) {
			logger.getLogger().severe("Exception occurred" + e);
			_data.setCurrState(LogicData.DisplayState.INVALID_TASK);
			// throws exception to prevent AddTask being added to undo stack
			throw new LogicException(MESSAGE_ERROR + e.getMessage());
		}
		return taskMessage(_newTask) + MESSAGE_RECURR + feedback;
	}

	private String checkPassed() {
		if (_newTask.getTaskType() == Task.Type.EVENT) {
			if (_newTask.getEndTime().isBefore(LocalDateTime.now())) {
				return MESSAGE_EVENT_PASSED;
			}
		} else if (_newTask.getTaskType() == Task.Type.DEADLINE) {
			if (_newTask.getEndTime().isBefore(LocalDateTime.now())) {
				return MESSAGE_DEADLINE_PASSED;
			}
		}
		return "";
	}

	private String findOverlaps() {
		ArrayList<Task> overlaps;
		overlaps = _data.overlappingTasks(_newTask);

		if (overlaps.size() == 0) {
			return "";
		} else {
			String feedback = MESSAGE_OVERLAP + taskMessage(overlaps.get(0));
			overlaps.remove(0);
			for (Task task : overlaps) {
				feedback += ", " + taskMessage(task);
			}
			return feedback;
		}
	}

	@Override
	public String undo() {
		String feedback;
		if (_id != null) {
			_data.addTask(_recurrTask);
			feedback = taskMessage(_newTask) + MESSAGE_NONRECURR;
		} else {
			feedback = MESSAGE_RECURR_TASK + taskMessage(_newTask) + MESSAGE_REMOVED;
		}
		_data.deleteTask(_newTask);
		return feedback;
	}

	@Override
	public String redo() {
		String feedback;
		if (_id != null) {
			_data.deleteTask(_recurrTask);
			feedback = taskMessage(_recurrTask) + MESSAGE_RECURR;
		} else {
			feedback = MESSAGE_RECURR_TASK + taskMessage(_newTask) + MESSAGE_ADDED;
		}
		_newTask.setDateModified(LocalDateTime.now());
		_data.addTask(_newTask);
		_data.setTaskPointer(_newTask);
		return feedback;
	}

	public void setNewTask(Task newTask) {
		_newTask = newTask;
	}

	public void setId(int id) {
		_id = Integer.valueOf(id);
	}

	public void setMins(int input) {
		_minutes = Integer.valueOf(input);
	}

	public void setHours(int input) {
		_hours = Integer.valueOf(input);
	}

	public void setDays(int input) {
		_days = Integer.valueOf(input);
	}

	public void setWeeks(int input) {
		_weeks = Integer.valueOf(input);
	}

	public void setMonths(int input) {
		_months = Integer.valueOf(input);
	}

	public void setYears(int input) {
		_years = input;
	}

	public void updateDateModified(ArrayList<Task> tasks) {
		LocalDateTime now = LocalDateTime.now();
		for (Task task : tasks) {
			task.setDateModified(now);
		}
	}

}
```
###### urgenda\command\Search.java
``` java
package urgenda.command;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Month;
import java.util.ArrayList;

import org.apache.commons.lang3.StringUtils;

import urgenda.logic.LogicData;
import urgenda.util.Task;

/**
 * 
 * Search is the command object used for searching of tasks in Urgenda.
 *
 */
public class Search extends Command {

	private static final String MESSAGE_SHOWING = "Showing: ";
	private static final String MESSAGE_PROGRESSIVE_SEARCH = "PROGRESSIVE SEARCH: %1$s  based on the current view. Enter home to show all tasks";
	private static final String MESSAGE_SEARCH_DESC = "all task(s) found containing \"%1$s\"";
	private static final String MESSAGE_SEARCH_TYPE = "all task(s) found of type \"%1$s\"";
	private static final String MESSAGE_SEARCH_TIME = "These are all the task(s) falling on \"%1$s\"";
	private static final String MESSAGE_REFINE_SEARCH_TIME = "PROGRESSIVE SEARCH: Showing task(s) that falls on \"%1$s\" based on the current view. Enter home to show all tasks";
	private static final String MESSAGE_SEARCH_NOT_FOUND = "There is no match found for \"%1$s\"";
	private static final String MESSAGE_SEARCH_INT_NOT_FOUND = "There is no match found for task no. %1$s";
	private static final String MESSAGE_SEARCH_INT = "Search Result: Showing detailed info of task no. %1$s";
	private static final String MESSAGE_NEAR_MATCH = "%1$s near match(es)";
	private static final String MESSAGE_SEARCH_NO_EXACT = "No exact match found for \"%1$s\". ";

	private String _searchDesc;
	private LocalDate _searchDate;
	private LocalDateTime _searchDateTime;
	private Month _searchMonth;
	private Integer _searchId;

	/**
	 * Default constructor for creating a new Search object.
	 */
	public Search() {

	}

	/**
	 * Alternative constructor for Search command object with the String desc
	 * for searching.
	 * 
	 * @param String
	 *            input The desc entered by user for searching.
	 */
	public Search(String input) {
		_searchDesc = input;
	}

	/**
	 * Alternative constructor for Search command object with the LocalDate date
	 * for searching.
	 * 
	 * @param LocalDate
	 *            input The date entered by user for searching.
	 */
	public Search(LocalDate input) {
		_searchDate = input;
	}

	/**
	 * Alternative constructor for Search command object with the LocalDateTime
	 * date&time for searching.
	 * 
	 * @param input
	 *            The date and time entered by user for searching.
	 */
	public Search(LocalDateTime input) {
		_searchDateTime = input;
	}

	/**
	 * Alternative constructor for Search command object with the Month month
	 * for searching.
	 * 
	 * @param input
	 *            The month entered by user for searching of tasks falling on
	 *            that month.
	 */
	public Search(Month input) {
		_searchMonth = input;
	}

	/**
	 * Alternative constructor for Search command object with the int id for
	 * searching.
	 * 
	 * @param input
	 *            The position entered by user for searching of a task (fn
	 *            similarly as showmore).
	 */
	public Search(int input) {
		_searchId = Integer.valueOf(input);
	}

	/**
	 * Execute command of Search which searches for tasks in Urgenda that
	 * matches the user specified input.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		ArrayList<Task> matches;
		String feedback = null;
		data.clearShowMoreTasks();

		if (_searchDesc != null) {
			feedback = searchForDesc(data);

		} else if (_searchDate != null) {
			matches = data.findMatchingDates(_searchDate);
			feedback = generateSearchDateFeedback(data, matches);

		} else if (_searchDateTime != null) {
			matches = data.findMatchingDateTimes(_searchDateTime);
			feedback = generateSearchDateTimeFeedback(data, matches);

		} else if (_searchMonth != null) {
			matches = data.findMatchingMonths(_searchMonth);
			feedback = generateSearchMonthFeedback(data, matches);

		} else if (_searchId != null) {
			Task task = data.findMatchingPosition(_searchId);
			feedback = generateSearchIdFeedback(data, task);
		}
		return feedback;
	}

	/*
	 * method for searching for tasks w desc and or tasktype that matches input.
	 */
	private String searchForDesc(LogicData data) {
		ArrayList<Task> matches;
		String feedback;
		// copy of _searchDesc for modification, trimming and caseignore
		String copy = _searchDesc;
		int descCount = 0;
		int typeCount = 0;
		int nearMatchCount = 0;
		switch (copy.toLowerCase().trim()) {
		case "overdue":
			matches = data.findMatchingDesc(_searchDesc);
			descCount = matches.size();
			typeCount = findTypeOverdue(data, matches, typeCount);
			break;
		case "completed":
			matches = data.findMatchingDesc(_searchDesc);
			descCount = matches.size();
			typeCount = findTypeCompleted(data, matches, typeCount);
			break;
		case "important": // Fallthrough
		case "impt": // Fallthrough
		case "prioritise":
			matches = data.findMatchingDesc(_searchDesc);
			descCount = matches.size();
			typeCount = findTypePri(data, matches, typeCount);
			break;
		case "twotime": // Fallthrough
		case "event":
			matches = data.findMatchingDesc(_searchDesc);
			descCount = matches.size();
			typeCount = findTypeEvent(data, matches, typeCount);
			break;
		case "onetime": // Fallthrough
		case "duedate": // Fallthrough
		case "deadline": // Fallthrough
			matches = data.findMatchingDesc(_searchDesc);
			descCount = matches.size();
			typeCount = findTypeDeadLine(data, matches, typeCount);
			break;
		case "floating": // Fallthrough
		case "untimed":
			matches = data.findMatchingDesc(_searchDesc);
			descCount = matches.size();
			typeCount = findTypeFloat(data, matches, typeCount);
			break;
		case "archive":
			matches = data.getArchives();
			typeCount = matches.size();
			break;
		default:
			matches = data.findRefinedMatchingDesc(_searchDesc);
			descCount = matches.size();
			nearMatchCount = findNearMatch(data, matches, nearMatchCount);
			break;
		}
		feedback = generateSearchDescFeedback(data, matches, descCount, typeCount)
				+ getNearMatchFeedback(nearMatchCount, descCount, typeCount);
		return feedback;
	}

	private String getNearMatchFeedback(int nearMatchCount, int descCount, int typeCount) {
		if (nearMatchCount != 0) {
			if (descCount == 0 && typeCount == 0) {
				return String.format(MESSAGE_SEARCH_NO_EXACT, _searchDesc) + MESSAGE_SHOWING
						+ String.format(MESSAGE_NEAR_MATCH, nearMatchCount);
			} else {
				return " and " + String.format(MESSAGE_NEAR_MATCH, nearMatchCount);
			}
		}
		return "";
	}

	private int findNearMatch(LogicData data, ArrayList<Task> matches, int nearMatchCount) {
		for (Task task : data.getDisplays()) {
			if (StringUtils.getJaroWinklerDistance(_searchDesc, task.getDesc()) >= 0.8 && !matches.contains(task)) {
				matches.add(task);
				nearMatchCount++;
			}
		}
		return nearMatchCount;
	}

	private String generateSearchIdFeedback(LogicData data, Task task) {
		String feedback;
		if (task != null) {
			data.toggleShowMoreTasks(task);
			data.setTaskPointer(task);
			data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			feedback = String.format(MESSAGE_SEARCH_INT, _searchId + 1);
		} else {
			data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			feedback = String.format(MESSAGE_SEARCH_INT_NOT_FOUND, _searchId + 1);
		}
		return feedback;
	}

	private String generateSearchMonthFeedback(LogicData data, ArrayList<Task> matches) {
		String feedback;
		if (matches.isEmpty()) {
			data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			feedback = String.format(MESSAGE_SEARCH_NOT_FOUND, _searchMonth.toString());
		} else {
			data.setDisplays(matches);
			if (data.getCurrState().equals(LogicData.DisplayState.ALL_TASKS)) {
				feedback = String.format(MESSAGE_SEARCH_TIME, _searchMonth.toString());
			} else {
				feedback = String.format(MESSAGE_REFINE_SEARCH_TIME, _searchMonth.toString());
			}
			data.setCurrState(LogicData.DisplayState.SHOW_SEARCH);
		}
		return feedback;
	}

	private String generateSearchDateTimeFeedback(LogicData data, ArrayList<Task> matches) {
		String feedback;
		if (matches.isEmpty()) {
			data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			feedback = String.format(MESSAGE_SEARCH_NOT_FOUND, _searchDateTime.toString());
		} else {
			data.setDisplays(matches);
			if (data.getCurrState().equals(LogicData.DisplayState.ALL_TASKS)) {
				feedback = String.format(MESSAGE_SEARCH_TIME, _searchDateTime.toString());
			} else {
				feedback = String.format(MESSAGE_REFINE_SEARCH_TIME, _searchDateTime.toString());
			}
			data.setCurrState(LogicData.DisplayState.SHOW_SEARCH);
		}
		return feedback;
	}

	private String generateSearchDateFeedback(LogicData data, ArrayList<Task> matches) {
		String feedback;
		if (matches.isEmpty()) {
			data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			feedback = String.format(MESSAGE_SEARCH_NOT_FOUND, _searchDate.toString());
		} else {
			data.setDisplays(matches);
			if (data.getCurrState().equals(LogicData.DisplayState.ALL_TASKS)) {
				feedback = String.format(MESSAGE_SEARCH_TIME, _searchDate.toString());
			} else {
				feedback = String.format(MESSAGE_REFINE_SEARCH_TIME, _searchDate.toString());
			}
			data.setCurrState(LogicData.DisplayState.SHOW_SEARCH);
		}
		return feedback;
	}

	private String generateSearchDescFeedback(LogicData data, ArrayList<Task> matches, int descCount, int typeCount) {
		String feedback;
		if (matches.isEmpty()) {
			data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			feedback = String.format(MESSAGE_SEARCH_NOT_FOUND, _searchDesc);
		} else {
			data.setDisplays(matches);
			if (data.getCurrState().equals(LogicData.DisplayState.ALL_TASKS)) {
				feedback = getNormSearchFeedback(descCount, typeCount);
			} else {
				feedback = getProgressiveSearchFeedback(descCount, typeCount);
			}
			data.setCurrState(LogicData.DisplayState.SHOW_SEARCH);
		}
		return feedback;
	}

	private String getProgressiveSearchFeedback(int descCount, int typeCount) {
		String feedback;
		if (descCount != 0 && typeCount != 0) {
			String substr = String.format(MESSAGE_SEARCH_DESC, _searchDesc) + " and "
					+ String.format(MESSAGE_SEARCH_TYPE, _searchDesc);
			feedback = String.format(MESSAGE_PROGRESSIVE_SEARCH, substr);
		} else if (descCount == 0) {
			feedback = String.format(MESSAGE_PROGRESSIVE_SEARCH, String.format(MESSAGE_SEARCH_TYPE, _searchDesc));
		} else {
			feedback = String.format(MESSAGE_PROGRESSIVE_SEARCH, String.format(MESSAGE_SEARCH_DESC, _searchDesc));
		}
		return feedback;
	}

	private String getNormSearchFeedback(int descCount, int typeCount) {
		String feedback;
		if (descCount != 0 && typeCount != 0) {
			feedback = MESSAGE_SHOWING + String.format(MESSAGE_SEARCH_DESC, _searchDesc) + " and "
					+ String.format(MESSAGE_SEARCH_TYPE, _searchDesc);
		} else if (descCount == 0 && typeCount != 0) {
			feedback = MESSAGE_SHOWING + String.format(MESSAGE_SEARCH_TYPE, _searchDesc);
		} else if (descCount != 0 && typeCount == 0) {
			feedback = MESSAGE_SHOWING + String.format(MESSAGE_SEARCH_DESC, _searchDesc);
		} else {
			feedback = "";
		}
		return feedback;
	}

	/*
	 * find tasks that are of type floating
	 */
	private int findTypeFloat(LogicData data, ArrayList<Task> matches, int typeCount) {
		for (Task task : data.getDisplays()) {
			if (task.getTaskType().equals(Task.Type.FLOATING)) {
				typeCount++;
			}
			if (task.getTaskType().equals(Task.Type.FLOATING) && !matches.contains(task)) {
				matches.add(task);
			}
		}
		return typeCount;
	}

	/*
	 * find tasks that are of type deadline
	 */
	private int findTypeDeadLine(LogicData data, ArrayList<Task> matches, int typeCount) {
		for (Task task : data.getDisplays()) {
			if (task.getTaskType().equals(Task.Type.DEADLINE)) {
				typeCount++;
			}
			if (task.getTaskType().equals(Task.Type.DEADLINE) && !matches.contains(task)) {
				matches.add(task);
			}
		}
		return typeCount;
	}

	/*
	 * find tasks that are of type event
	 */
	private int findTypeEvent(LogicData data, ArrayList<Task> matches, int typeCount) {
		for (Task task : data.getDisplays()) {
			if (task.getTaskType().equals(Task.Type.EVENT)) {
				typeCount++;
			}
			if (task.getTaskType().equals(Task.Type.EVENT) && !matches.contains(task)) {
				matches.add(task);
			}
		}
		return typeCount;
	}

	/*
	 * find tasks that are marked as important
	 */
	private int findTypePri(LogicData data, ArrayList<Task> matches, int typeCount) {
		for (Task task : data.getDisplays()) {
			if (task.isImportant()) {
				typeCount++; // maintain count of all pri tasks
			}
			// prevent adding duplicate copies which falls under multi category
			// eg. desc impt and isImpt
			if (task.isImportant() && !matches.contains(task)) {
				matches.add(task);
			}
		}
		return typeCount;
	}

	/*
	 * find tasks that are marked as done
	 */
	private int findTypeCompleted(LogicData data, ArrayList<Task> matches, int typeCount) {
		for (Task task : data.getTaskList()) {
			if (task.isCompleted()) {
				typeCount++; // maintain count of all completed tasks
			}
			// prevent adding duplicate copies which falls under multi category
			if (task.isCompleted() && !matches.contains(task)) {
				matches.add(task);
			}
		}
		for (Task task : data.getArchives()) {
			if (task.isCompleted() && !matches.contains(task)) {
				typeCount++;
				matches.add(task);
			}
		}
		return typeCount;
	}

	/*
	 * find tasks that are overdue
	 */
	private int findTypeOverdue(LogicData data, ArrayList<Task> matches, int typeCount) {
		for (Task task : data.getDisplays()) {
			if (task.isOverdue()) {
				// get num of overdue tasks (including those which are both
				// overdue & has desc overdue)
				typeCount++;
			}
			// prevent adding of duplicate copies
			if (task.isOverdue() && !matches.contains(task)) {
				matches.add(task);
			}
		}
		return typeCount;
	}

	/**
	 * Setter for search by desc.
	 * 
	 * @param input
	 *            The string desc used for searching.
	 */
	public void setSearchInput(String input) {
		_searchDesc = input;
	}

	/**
	 * Setter for search by date
	 * 
	 * @param input
	 *            The LocalDate date used for searching.
	 */
	public void setSearchDate(LocalDate input) {
		_searchDate = input;
	}

	/**
	 * Setter for search by datetime
	 * 
	 * @param input
	 *            The LocalDateTime dateandtime used for searching.
	 */
	public void setSearchDateTime(LocalDateTime input) {
		_searchDateTime = input;
	}

	/**
	 * Setter for search by month
	 * 
	 * @param input
	 *            The Month month used for searching.
	 */
	public void setSearchMonth(Month input) {
		_searchMonth = input;
	}

	/**
	 * Setter for search by id
	 * 
	 * @param id
	 *            The int position of task used for searching.
	 */
	public void setSearchId(int id) {
		_searchId = Integer.valueOf(id);
	}

}
```
###### urgenda\command\ShowArchive.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * 
 * ShowArchive is the command object used for displaying archive (list of completed tasks)
 * to the user.
 *
 */

public class ShowArchive extends Command {
	
	private static final String MESSAGE_SHOWING_ARCHIVE = "Showing all archived tasks";

	/**
	 * Execute command of ShowArchive which sets user's display screen to showing archived tasks.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.ARCHIVE);
		data.clearShowMoreTasks();
		return MESSAGE_SHOWING_ARCHIVE;
	}

}
```
###### urgenda\logic\LogicData.java
``` java
package urgenda.logic;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Month;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.regex.Pattern;

import urgenda.storage.Storage;
import urgenda.storage.StorageTester;
import urgenda.util.DateTimePair;
import urgenda.util.InvalidFolderException;
import urgenda.util.MultipleSlot;
import urgenda.util.StateFeedback;
import urgenda.util.StorageException;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * LogicData class of the Logic component in Urgenda. Responsible for the
 * handling of the different tasks of the user. Main class where all the
 * manipulation of the task objects are carried out. Also responsible for
 * storing of all the tasks.
 *
 */
public class LogicData {

	/**
	 * Different DisplayState for LogicData which represents the state of
	 * display given to the user
	 *
	 */
	public enum DisplayState {
		ALL_TASKS, MULTIPLE_DELETE, MULTIPLE_COMPLETE, MULTIPLE_PRIORITISE, SHOW_SEARCH, EXIT, INVALID_COMMAND, HELP, INVALID_TASK, ARCHIVE, FIND_FREE, DEMO, HIDE
	}

	private static UrgendaLogger logger = UrgendaLogger.getInstance();
	private static LogicData _logicData;

	// storage object for retrieval and storing of tasks to data format
	private Storage _storage;

	// for storage of full lists of tasks
	private ArrayList<Task> _tasks;
	// for storage of all completed tasks
	private ArrayList<Task> _archives;
	// for storage of tasks being displayed to user by last command
	private ArrayList<Task> _displays;
	// for storage of tasks to have more details to be displayed
	private ArrayList<Task> _showMoreTasks;

	private Task _taskPointer;
	private DisplayState _currState;
	private int _currentId;

	/*
	 * Default constructor where singleton pattern is applied. To initialise the
	 * variables within LogicData.
	 */
	private LogicData() {
		logger.getLogger().info("constructing LogicData Object");
		_storage = new Storage();
		_tasks = _storage.updateCurrentTaskList();
		_archives = _storage.updateArchiveTaskList();
		_currState = DisplayState.ALL_TASKS;
		_displays = new ArrayList<Task>();
		_showMoreTasks = new ArrayList<Task>();
		// sets the next id to be used for future labelling of tasks
		_currentId = _tasks.size() + 1;
	}

	/*
	 * Alternative constructor where singleton pattern is applied. To initialise
	 * the variables within LogicData when doing testing.
	 */
	private LogicData(boolean isTest) {
		// stubs storage with storagetester
		_storage = new StorageTester();
		_tasks = _storage.updateCurrentTaskList();
		_archives = _storage.updateArchiveTaskList();
		_currState = DisplayState.ALL_TASKS;
		_displays = new ArrayList<Task>();
		_showMoreTasks = new ArrayList<Task>();
		_currentId = _tasks.size() + 1;
	}

	/**
	 * Singleton pattern method for instantiation of LogicData to avoid multiple
	 * copies of tasks for the user
	 * 
	 * @return LogicData object that is used currently or created
	 */
	public static LogicData getInstance() {
		if (_logicData == null) {
			logger.getLogger().info("creating instance of logicData");
			_logicData = new LogicData();
		}
		logger.getLogger().info("retrieving prev instance of logicData");
		return _logicData;
	}

	/**
	 * Alternate constructor for singleton pattern for stubbing of storage when
	 * testing
	 * 
	 * @param isTest
	 *            boolean of checking if the current mode is in testing
	 * @return LogicData object that is used currently or created
	 */
	public static LogicData getInstance(boolean isTest) {
		if (_logicData == null) {
			_logicData = new LogicData(isTest);
		}
		return _logicData;
	}

	/**
	 * Method used for saving all current contents into the data file for usage
	 * in the future.
	 */
	public void saveContents() {
		logger.getLogger().info("Saving contents to storage");
		_storage.save(_tasks, _archives);
	}

	/**
	 * Method to retrieve the current state of LogicData into a StateFeedback
	 * object for packaging all required information. Different sets of lists
	 * are used for different states that it is currently in.
	 * 
	 * @return StateFeedback object that holds all the required information
	 */
	public StateFeedback getState() {
		// TODO: refactor function
		StateFeedback state;
		switch (_currState) {
		case ALL_TASKS:
			// TODO update diagram
			state = displayAllTasks(_tasks);
			state.setState(StateFeedback.State.ALL_TASKS);
			break;
		case MULTIPLE_DELETE: // Fallthrough
		case MULTIPLE_COMPLETE: // Fallthrough
		case MULTIPLE_PRIORITISE:
			state = displayAllTasks(_displays);
			state.setState(StateFeedback.State.MULTIPLE_MATCHES);
			break;
		case SHOW_SEARCH:
			state = displayAllTasks(_displays);
			state.setState(StateFeedback.State.SHOW_SEARCH);
			break;
		case HELP:
			state = displayAllTasks(_displays);
			state.setState(StateFeedback.State.SHOW_HELP);
			break;
		case EXIT:
			saveContents();
			state = displayAllTasks(_tasks);
			state.setState(StateFeedback.State.EXIT);
			break;
		case INVALID_COMMAND: // Fallthrough
		case INVALID_TASK:
			state = displayAllTasks(_tasks);
			state.setState(StateFeedback.State.ERROR);
			break;
		case ARCHIVE:
			state = displayArchiveTasks(_archives);
			state.setState(StateFeedback.State.ARCHIVE);
			break;
		case FIND_FREE:
			state = displayAllTasks(_displays);
			state.setState(StateFeedback.State.FIND_FREE);
			break;
		case DEMO:
			state = displayAllTasks(_displays);
			state.setState(StateFeedback.State.DEMO);
			break;
		case HIDE:
			state = displayAllTasks(_displays);
			state.setState(StateFeedback.State.HIDE);
			break;
		default:
			state = displayAllTasks(_tasks);
			state.setState(StateFeedback.State.ALL_TASKS);
			break;
		}
		return state;
	}

	/**
	 * Method for setting the display list to show archive tasks
	 * 
	 * @param displayList
	 *            Archive list for putting as display
	 * @return StateFeedback object containing the list given
	 */
	public StateFeedback displayArchiveTasks(ArrayList<Task> displayList) {
		clearDisplays();
		_displays.addAll(sortArchive(displayList));
		StateFeedback state = new StateFeedback(_displays, _displays.size());
		setOverdueCount(state);
		setFeedbackDisplayPosition(state);
		setShowMorePositions(state);
		return state;
	}

	/**
	 * Method for setting the display list to show the current list given. Sorts
	 * the list according to Overdue, Today, Others.
	 * 
	 * @param displayList
	 *            Display List given for putting as display
	 * @return StateFeedback object containing the list given
	 */
	public StateFeedback displayAllTasks(ArrayList<Task> displayList) {
		ArrayList<Task> overdueTasks = new ArrayList<Task>();
		ArrayList<Task> todayTasks = new ArrayList<Task>();
		ArrayList<Task> otherTasks = new ArrayList<Task>();
		sortTasksIntoList(displayList, overdueTasks, todayTasks, otherTasks);
		clearDisplays();
		_displays.addAll(sortList(overdueTasks));
		_displays.addAll(sortList(todayTasks));
		_displays.addAll(sortList(otherTasks));

		assert (_displays.size() >= 0);

		StateFeedback state = new StateFeedback(_displays, overdueTasks.size(), todayTasks.size(),
				otherTasks.size());
		setOverdueCount(state);
		setFeedbackDisplayPosition(state);
		setShowMorePositions(state);
		return state;
	}

	private void sortTasksIntoList(ArrayList<Task> displayList, ArrayList<Task> overdueTasks,
			ArrayList<Task> todayTasks, ArrayList<Task> otherTasks) {
		for (Task task : displayList) {
			if (task.isOverdue()) {
				overdueTasks.add(task);
			} else if (isTaskToday(task)) {
				todayTasks.add(task);
			} else { // remaining tasks and floating tasks
				otherTasks.add(task);
			}
		}
	}

	private void setOverdueCount(StateFeedback state) {
		int count = 0;
		for (Task task : _tasks) {
			if (task.isOverdue()) {
				count++;
			}
		}
		assert (count >= 0);
		state.setOverdueCount(count);
	}

	private void setShowMorePositions(StateFeedback state) {
		for (Task task : _showMoreTasks) {
			if (_displays.contains(task)) {
				state.addDetailedTaskIdx(_displays.indexOf(task));
			}
		}
	}

	// sets the position if the pointer matches the display
	private void setFeedbackDisplayPosition(StateFeedback state) {
		if (_taskPointer != null && _displays.contains(_taskPointer)) {
			state.setDisplayPosition(_displays.indexOf(_taskPointer));
		} else {
			// sets to 0 (default) if no specific task to pointed at
			state.setDisplayPosition(0);
		}
		// clears task pointer for next iteration
		_taskPointer = null;
	}

	/**
	 * Method for checking whether the task falls on today (calendar time).
	 * 
	 * @param task
	 *            task given for checking if falls on today.
	 * @return boolean true or false
	 */
	public boolean isTaskToday(Task task) {
		LocalDate now = LocalDate.now();
		if (task.getTaskType() == Task.Type.DEADLINE) {
			return verifyEndTime(task, now);
		} else if (task.getTaskType() == Task.Type.EVENT) {
			// check whether any of the time within the time span of the event
			// falls on today
			return verifyTimeSpan(task, now);
		} else { // Type is floating
			return false;
		}
	}

	/*
	 * method for checking whether an event falls on today (including
	 * consideration of tasks that spans multiple days
	 */
	private boolean verifyTimeSpan(Task task, LocalDate now) {
		if (task.getStartTime().toLocalDate().isEqual(now) || task.getEndTime().toLocalDate().isEqual(now)
				|| task.getStartTime().toLocalDate().isBefore(now)
						&& task.getEndTime().toLocalDate().isAfter(now)) {
			return true;
		} else {
			return false;
		}
	}

	/*
	 * method for checking whether a deadline task falls on today
	 */
	private boolean verifyEndTime(Task task, LocalDate now) {
		if (task.getEndTime().toLocalDate().isEqual(now)) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Method for updating the state of the system e.g. called after every
	 * execution of command so that GUI knows the state for display.
	 */
	public void updateState() {
		logger.getLogger().info("Updating state of prog");
		ArrayList<Task> completedTasks = new ArrayList<Task>();
		LocalDateTime now = LocalDateTime.now();
		for (Task task : _tasks) {
			checkDeadline(now, task);
			checkMultipleSlot(task);
			checkEvents(completedTasks, now, task);
		}
		_tasks.removeAll(completedTasks);
		_archives.addAll(completedTasks);
	}

	private void checkEvents(ArrayList<Task> completedTasks, LocalDateTime now, Task task) {
		if (task.getTaskType() == Task.Type.EVENT) {
			if (task.getEndTime().isBefore(now)) {
				task.setIsCompleted(true);
				task.setDateModified(LocalDateTime.now());
				logger.getLogger().info("event task" + task + " has been completed");
				// only moves completed tasks when the day ends for that day
				if (task.getEndTime().toLocalDate().isBefore(LocalDate.now())) {
					completedTasks.add(task);
					task.setDateModified(LocalDateTime.now());
				}
			}
		}
	}

	private void checkMultipleSlot(Task task) {
		if (task.getSlot() != null) {
			updateMultipleSlot(task);
		}
	}

	private void checkDeadline(LocalDateTime now, Task task) {
		if (task.getTaskType() == Task.Type.DEADLINE) {
			if (task.getEndTime().isBefore(now)) {
				task.setIsOverdue(true);
				task.setDateModified(LocalDateTime.now());
				logger.getLogger().info("deadline task " + task + " has turned overdue");
			} else {
				task.setIsOverdue(false);
			}
		}
	}

	/**
	 * Method for updating the Multipleslot attribute (for blocking of several
	 * timings for same task) of a given task.
	 * 
	 * @param task
	 *            The task specified for updating of multipleslot.
	 */
	public void updateMultipleSlot(Task task) {
		LocalDateTime now = LocalDateTime.now();
		if (task.getStartTime() == null || task.getEndTime() == null) {
			return;
		}
		task.getSlot().addTimeSlot(task.getStartTime(), task.getEndTime());
		task.getSlot().sortSlots();
		updateTimeSlots(task, now);
		checkEmptySlot(task);
	}

	private void checkEmptySlot(Task task) {
		if (task.getSlot().isEmpty()) {
			task.setSlot(null);
		}
	}

	private void updateTimeSlots(Task task, LocalDateTime now) {
		do {
			DateTimePair newTime = task.getSlot().getNextSlot();
			task.setStartTime(newTime.getEarlierDateTime());
			task.setEndTime(newTime.getLaterDateTime());
			task.getSlot().removeNextSlot();
		} while (task.getEndTime().isBefore(now) && !(task.getSlot().isEmpty()));
	}

	/**
	 * Method for finding tasks w desc that matches input (in same order)
	 * regardless of case. e.g. for input of abc, Abc and ABCDDD will all be
	 * returned.
	 * 
	 * @param desc
	 *            The description given by user to find matches.
	 * @return ArrayList containing all matching tasks.
	 */
	public ArrayList<Task> findMatchingDesc(String desc) {
		ArrayList<Task> matches = new ArrayList<Task>();
		if (!desc.equals("")) {
			searchForMatchingDescInDisplayList(desc, matches);
		}
		logger.getLogger().info("Find matching desc: " + desc);
		return matches;
	}

	private void searchForMatchingDescInDisplayList(String desc, ArrayList<Task> matches) {
		for (Task task : _displays) {
			if (Pattern.compile(Pattern.quote(desc), Pattern.CASE_INSENSITIVE).matcher(task.getDesc())
					.find()) {
				matches.add(task);
			}
		}
	}

	/**
	 * Method for finding tasks w desc that matches input (more than one word)
	 * (words dont need be in same order) regardless of case. e.g. for input of
	 * Sweden Holiday, Holiday to Swenden and Sweden Public Holiday will both be
	 * returned.
	 * 
	 * @param desc
	 *            The desc given by user for finding matches within current task
	 *            list.
	 * @return ArrayList containing all the tasks with matching desc.
	 */
	public ArrayList<Task> findRefinedMatchingDesc(String desc) {
		ArrayList<Task> matches = new ArrayList<Task>();
		if (!desc.equals("")) {
			String[] substr = desc.split("\\s+");
			ArrayList<String> substr2 = new ArrayList<String>(Arrays.asList(substr));
			if (substr2.size() > 1) {
				searchForNonOrderedDesc(matches, substr2);
			} else {
				searchForMatchingDescInDisplayList(desc, matches);
			}
		}
		return matches;
	}

	private void searchForNonOrderedDesc(ArrayList<Task> matches, ArrayList<String> substr2) {
		for (Task task : _displays) {
			boolean flag = true;
			for (String s : substr2) {
				if (!(Pattern.compile(Pattern.quote(s + " "), Pattern.CASE_INSENSITIVE)
						.matcher(task.getDesc()).find())
						&& !(Pattern.compile(Pattern.quote(" " + s), Pattern.CASE_INSENSITIVE)
								.matcher(task.getDesc()).find())
						&& flag) {
					flag = false;
				}
			}
			if (flag) {
				matches.add(task);
			}
		}
	}

	/**
	 * Method for adding a completed task to archive.
	 * 
	 * @param task
	 *            The task to be moved to archive
	 */
	public void addArchive(Task task) {
		logger.getLogger().info("adding task " + task + " to archive");
		_archives.add(task);
	}

	/**
	 * Method for adding multiple completed tasks to archive at once.
	 * 
	 * @param tasks
	 *            The ArrayList of tasks to be moved to archive
	 */
	public void addArchive(ArrayList<Task> tasks) {
		logger.getLogger().info("adding task multiple tasks to archive");
		_archives.addAll(tasks);
	}

	/**
	 * Method for removing a task from archive.
	 * 
	 * @param tasks
	 *            The task to be removed from archive.
	 */
	public void removeArchive(Task task) {
		_archives.remove(task);
	}

	/**
	 * Method for removing multiple tasks from archive at once.
	 * 
	 * @param tasks
	 *            The ArrayList of tasks to be removed from archive.
	 */
	public void removeArchive(ArrayList<Task> tasks) {
		_archives.removeAll(tasks);
	}

	/**
	 * Getter for getting the private attribute _tasks in logicData.
	 * 
	 * @return _task, the list containing all current tasks.
	 */
	public ArrayList<Task> getTaskList() {
		return _tasks;
	}

	/**
	 * Getter for getting the latest id assigned to a new task.
	 * 
	 * @return _currentId, the current id of the system.
	 */
	public int getCurrentId() {
		return _currentId;
	}

	/**
	 * Method for updating the id of task list to the most recent number in
	 * logicData.
	 */
	public void updateCurrentId() {
		_currentId++;
	}

	/**
	 * Method for adding a new Task into the taskList in LogicData.
	 * 
	 * @param newTask
	 *            The new task given to be added to current task list.
	 */
	public void addTask(Task newTask) {
		_tasks.add(newTask);
	}

	/**
	 * Method for adding multiple new Tasks into the taskList in LogicData.
	 * 
	 * @param tasks
	 *            The ArrayList of new tasks to be added to current task list.
	 */
	public void addTasks(ArrayList<Task> tasks) {
		_tasks.addAll(tasks);
	}

	/**
	 * Method for removing a task from the taskList and archive in LogicData.
	 * 
	 * @param task
	 *            The task specified for the removal from Urgenda.
	 */
	public void deleteTask(Task task) {
		_tasks.remove(task);
		_archives.remove(task);
	}

	/**
	 * Method for removing a task from the taskList in LogicData.
	 * 
	 * @param tasks
	 *            The ArrayList of tasks specified for the removal from Urgenda.
	 */
	public void deleteTasks(ArrayList<Task> tasks) {
		_tasks.removeAll(tasks);
		_archives.removeAll(tasks);
	}

	/**
	 * Method for retrieving a task based on specified id (position in task list
	 * _tasks).
	 * 
	 * @param id
	 *            The id (position) specified for locating of a task.
	 * @return the task which corresponds to the position in _tasks(id) or null
	 *         if couldn't find a valid match.
	 */
	public Task findMatchingPosition(int id) {
		logger.getLogger().info("Find matching position, " + id);
		if (id >= 0 && id < _displays.size()) {
			logger.getLogger().info("Matching position found: " + id);
			return _displays.get(id);
		} else {
			logger.getLogger().info("Matching position not found");
			return null;
		}
	}

	/**
	 * Overloaded method for finding matching positions w arraylists of id given
	 * as input.
	 * 
	 * @param idPositions
	 *            The ArrayList of id (positions) specified for retrieving and
	 *            locating of multiple tasks.
	 * @return ArrayList of task which corresponds to the idpositions, none
	 *         valid id will just be ignored.
	 */
	public ArrayList<Task> findMatchingPosition(ArrayList<Integer> idPositions) {
		ArrayList<Task> matches = new ArrayList<Task>();
		for (Integer i : idPositions) {
			if (i != null && i >= 0 && i < _displays.size()) {
				matches.add(_displays.get(i));
				logger.getLogger().info("Found matching position, " + i);
			}
		}
		if (matches.isEmpty()) {
			return null;
		} else {
			return matches;
		}
	}

	/**
	 * Method for retrieving tasks that matches date specified by input.
	 * 
	 * @param input
	 *            The date specified for searching of tasks falling on it.
	 * @return Arraylist of tasks that matches input date.
	 */
	public ArrayList<Task> findMatchingDates(LocalDate input) {
		logger.getLogger().info("Find matching dates, " + input);
		ArrayList<Task> matches = new ArrayList<Task>();
		for (Task task : _displays) {
			if (task.getTaskType() == Task.Type.DEADLINE) {
				getDeadLineWithMatchingDate(input, matches, task);
			} else if (task.getTaskType() == Task.Type.EVENT) {
				getEventWithMatchingDate(input, matches, task);
			}
		}
		return matches;
	}

	private void getEventWithMatchingDate(LocalDate input, ArrayList<Task> matches, Task task) {
		if (task.getStartTime().toLocalDate().isEqual(input)
				|| task.getEndTime().toLocalDate().isEqual(input)) {
			matches.add(task);
		} else if (task.getStartTime().toLocalDate().isBefore(input)
				&& task.getEndTime().toLocalDate().isAfter(input)) {
			matches.add(task);
		} else if (task.getSlot() != null && !task.getSlot().isEmpty()) {
			checkForMatchingDateWithinSlots(input, matches, task);
		}
	}

	private void checkForMatchingDateWithinSlots(LocalDate input, ArrayList<Task> matches, Task task) {
		ArrayList<DateTimePair> slots = task.getSlot().getSlots();
		for (DateTimePair pair : slots) {
			if (pair.getEarlierDateTime().toLocalDate().isEqual(input)
					|| pair.getLaterDateTime().toLocalDate().isEqual(input)) {
				matches.add(task);
			} else if (pair.getEarlierDateTime().toLocalDate().isBefore(input)
					&& pair.getLaterDateTime().toLocalDate().isAfter(input)) {
				matches.add(task);
			}
		}
	}

	private void getDeadLineWithMatchingDate(LocalDate input, ArrayList<Task> matches, Task task) {
		if (task.getEndTime().toLocalDate().isEqual(input)) {
			matches.add(task);
		}
	}

	/**
	 * Method for retrieving tasks that matches both date and time specified by
	 * input.
	 * 
	 * @param input
	 *            The DateTime specified for searching of tasks falling it.
	 * @return Arraylist of tasks that matches input datetime.
	 */
	public ArrayList<Task> findMatchingDateTimes(LocalDateTime input) {
		logger.getLogger().info("Find matching datetime, " + input);
		ArrayList<Task> matches = new ArrayList<Task>();
		for (Task task : _displays) {
			if (task.getTaskType() == Task.Type.DEADLINE) {
				getDeadLineWithMatchingDateTime(input, matches, task);
			} else if (task.getTaskType() == Task.Type.EVENT) {
				getEventWithMatchingDateTime(input, matches, task);
			}
		}
		return matches;
	}

	private void getEventWithMatchingDateTime(LocalDateTime input, ArrayList<Task> matches, Task task) {
		if (task.getStartTime().isEqual(input) || task.getEndTime().isEqual(input)) {
			matches.add(task);
		} else if (task.getStartTime().isBefore(input) && task.getEndTime().isAfter(input)) {
			matches.add(task);
		} else if (task.getSlot() != null && !task.getSlot().isEmpty()) {
			getMatchingDateTimeWithinSlots(input, matches, task);
		}
	}

	private void getMatchingDateTimeWithinSlots(LocalDateTime input, ArrayList<Task> matches, Task task) {
		ArrayList<DateTimePair> slots = task.getSlot().getSlots();
		for (DateTimePair pair : slots) {
			if (pair.getEarlierDateTime().isEqual(input) || pair.getLaterDateTime().isEqual(input)) {
				matches.add(task);
			} else if (pair.getEarlierDateTime().isBefore(input) && pair.getLaterDateTime().isAfter(input)) {
				matches.add(task);
			}
		}
	}

	private void getDeadLineWithMatchingDateTime(LocalDateTime input, ArrayList<Task> matches, Task task) {
		if (task.getEndTime().isEqual(input)) {
			matches.add(task);
		}
	}

	/**
	 * Method for retrieving tasks that falls on the month specified by input.
	 * 
	 * @param input
	 *            The Month specified for searching of tasks falling on it.
	 * @return Arraylist of tasks that matches input month.
	 */
	public ArrayList<Task> findMatchingMonths(Month input) {
		logger.getLogger().info("Find matching months, " + input);
		ArrayList<Task> matches = new ArrayList<Task>();
		for (Task task : _displays) {
			if (task.getTaskType() == Task.Type.DEADLINE) {
				getDeadLineWithMatchingMonth(input, matches, task);
			} else if (task.getTaskType() == Task.Type.EVENT) {
				getEventWithMatchingMonth(input, matches, task);
			}
		}
		return matches;
	}

	private void getEventWithMatchingMonth(Month input, ArrayList<Task> matches, Task task) {
		if (task.getStartTime().getMonth() == input || task.getEndTime().getMonth() == input) {
			matches.add(task);
		} else if (task.getStartTime().getMonth() == input && task.getEndTime().getMonth() == input) {
			matches.add(task);
		} else if (task.getSlot() != null && !task.getSlot().isEmpty()) {
			getMatchingMonthWithinSlots(input, matches, task);
		}
	}

	private void getMatchingMonthWithinSlots(Month input, ArrayList<Task> matches, Task task) {
		ArrayList<DateTimePair> slots = task.getSlot().getSlots();
		for (DateTimePair pair : slots) {
			if (pair.getEarlierDateTime().getMonth() == input
					|| pair.getLaterDateTime().getMonth() == input) {
				matches.add(task);
			} else if (pair.getEarlierDateTime().getMonth() == input
					&& pair.getLaterDateTime().getMonth() == input) {
				matches.add(task);
			}
		}
	}

	private void getDeadLineWithMatchingMonth(Month input, ArrayList<Task> matches, Task task) {
		if (task.getEndTime().getMonth() == input) {
			matches.add(task);
		}
	}

	/**
	 * Method for finding task that has the same multipleslot as given input.
	 * 
	 * @param block
	 *            The MultipleSlot variable for searching of tasks that matches
	 *            this block.
	 * @return ArrayList of task that matches block.
	 */
	public ArrayList<Task> findBlocks(MultipleSlot block) {
		ArrayList<Task> _blocks = new ArrayList<Task>();
		for (Task task : _tasks) {
			if (task.getSlot() != null) {
				if (task.getSlot().equals(block)) {
					_blocks.add(task);
				}
			}
		}
		return _blocks;
	}

	/**
	 * Method for sorting of list of task according to datetime and priority and
	 * alpha order for tasks w/o datetime (floating).
	 * 
	 * @param list
	 *            The ArrayList of tasks to be sorted.
	 * @return sorted list.
	 */
	public ArrayList<Task> sortList(ArrayList<Task> list) {
		Collections.sort(list, comparator);
		Collections.sort(list, imptComparator);
		return list;
	}

	/*
	 * comparator for comparison of timing
	 */
	static Comparator<Task> comparator = new Comparator<Task>() {
		public int compare(final Task o1, final Task o2) {
			LocalDateTime c1, c2;
			if (o1.getStartTime() != null) {
				c1 = o1.getStartTime();
			} else {
				c1 = o1.getEndTime();
			}
			if (o2.getStartTime() != null) {
				c2 = o2.getStartTime();
			} else {
				c2 = o2.getEndTime();
			}
			if (c1 == null && c2 == null) {
				return o1.getDesc().compareToIgnoreCase(o2.getDesc());
			} else if (c1 == null) {
				return 1;
			} else if (c2 == null) {
				return -1;
			} else {
				if (c1.compareTo(c2) == 0) {
					return o1.getDesc().compareToIgnoreCase(o2.getDesc());
				}
				return c1.compareTo(c2);
			}
		}
	};

	/*
	 * comparator for comparing of priority status
	 */
	static Comparator<Task> imptComparator = new Comparator<Task>() {
		public int compare(final Task o1, final Task o2) {
			int compare = 0;
			if (o1.isImportant() && o2.isImportant()) {
				compare = 0;
			} else if (o1.isImportant()) {
				compare = -1;
			} else if (o2.isImportant()) {
				compare = 1;
			}
			return compare;
		}
	};

	/**
	 * Method for sorting list of tasks in archive according to date modified.
	 * 
	 * @param list
	 *            The ArrayList of archive tasks to be sorted.
	 * @return sorted list
	 */
	public ArrayList<Task> sortArchive(ArrayList<Task> list) {
		Collections.sort(list, archiveComparator);
		return list;
	}

	/*
	 * new comparator for sorting of archive, compares datemodified.
	 */
	static Comparator<Task> archiveComparator = new Comparator<Task>() {
		public int compare(final Task o1, final Task o2) {
			return o2.getDateModified().compareTo(o1.getDateModified());
		}
	};

	/**
	 * Getter for retrieving display list (all tasks currently displayed to
	 * user), the private attribute in LogicData.
	 * 
	 * @return _displays, the private attribute in logicData.
	 */
	public ArrayList<Task> getDisplays() {
		return _displays;
	}

	/**
	 * Getter for retrieving archive list (all tasks currently displayed to
	 * user), the private attribute in LogicData.
	 * 
	 * @return _archives, the private attribute in logicData.
	 */
	public ArrayList<Task> getArchives() {
		return _archives;
	}

	/**
	 * Setter for setting the attribute _display in logicData as the specified
	 * ArrayList<Task> input.
	 * 
	 * @param displays
	 *            The ArrayList to be set as display.
	 */
	public void setDisplays(ArrayList<Task> displays) {
		_displays = displays;
	}

	/**
	 * Getter for getting the currState of the program e.g. the state shown by
	 * ui.
	 * 
	 * @return _currState, a DisplayState private attribute in LogicData
	 */
	public DisplayState getCurrState() {
		return _currState;
	}

	/**
	 * Setter for setting currState of program to a specified Display State
	 * given by input e.g. indicating to UI the state of the system after a
	 * command is executed.
	 * 
	 * @param currState
	 *            The DisplayState to be set as current state of the system.
	 */
	public void setCurrState(DisplayState currState) {
		_currState = currState;
	}

	/**
	 * Method for clearing display list.
	 */
	public void clearDisplays() {
		_displays.clear();
	}

	/**
	 * Method for testing purposes only. Use in FreeTimeTest.java for clearing
	 * of entire tasklist.
	 */
	public void clearTasks() {
		_tasks.clear();
	}

	/**
	 * Method for retrieving userguide (help for user).
	 * 
	 * @return _storage.retrieveHelp, the help file stored in storage.
	 */
	public ArrayList<String> generateHelpManual() {
		return _storage.getHelp();
	}

	/**
	 * Getter for getting the selector position of the program e.g. the task
	 * that is currently pointing at.
	 * 
	 * @return _taskPointer, the private attribute in logicData which is the
	 *         selector of Urgenda.
	 */
	public Task getTaskPointer() {
		return _taskPointer;
	}

	/**
	 * Setter for setting the position of the selector, e.g. which task to point
	 * to by UI.
	 * 
	 * @param taskPointer
	 *            The Task for setting the pointer to be pointing at.
	 */
	public void setTaskPointer(Task taskPointer) {
		_taskPointer = taskPointer;
	}

	/**
	 * Method for getting the showmore status of a given task.
	 * 
	 * @param task
	 *            The task specified for checking of showmore status.
	 * @return true if status isShowingMore, false otherwise.
	 */
	public boolean isShowingMore(Task task) {
		return _showMoreTasks.contains(task);
	}

	/**
	 * Method to toggle showmore status of a specified task.
	 * 
	 * @param task
	 *            The task specified for toggling of showmore status.
	 */
	public void toggleShowMoreTasks(Task task) {
		logger.getLogger().info("toggle showmore status of " + task);
		if (_showMoreTasks.contains(task)) {
			_showMoreTasks.remove(task);
		} else {
			_showMoreTasks.add(task);
		}
	}

	/**
	 * Method for setting status of all task to not showing more.
	 */
	public void clearShowMoreTasks() {
		_showMoreTasks.clear();
	}

	/**
	 * Method to get current file directory.
	 * 
	 * @return _storage.getDirPath
	 */
	public String retrieveCurrentDirectory() {
		return _storage.getDirPath();
	}

	/**
	 * Method for changing file directory of where task is saved to.
	 * 
	 * @param path
	 *            The String path specified for changing of current directory to
	 *            the new one.
	 * @throws StorageException
	 * @throws InvalidFolderException
	 */
	public void changeDirectory(String path) throws StorageException, InvalidFolderException {
		_storage.changeFileSettings(path);
	}

	/**
	 * Method for retrieving all the tasks in tasklist that a specified task
	 * overlaps with.
	 * 
	 * @param newTask
	 *            The task used for comparing with all other tasks in LogicData
	 *            for searching of overlap in timing.
	 * @return ArrayList of overlapping tasks
	 */
	public ArrayList<Task> overlappingTasks(Task newTask) {
		ArrayList<Task> overlaps = new ArrayList<Task>();

		for (Task task : _tasks) {
			if (!task.equals(newTask)) {
				if (task.getTaskType() == Task.Type.EVENT) {
					if (task.isOverlapping(newTask)) {
						overlaps.add(task);
					}
				}
				// case when there are multiple slots, multiple copies of
				// overlaps are added
				if (task.getSlot() != null && !task.getSlot().isEmpty()) {
					getOverlapsWithinSlots(newTask, overlaps, task);
				}
			}
		}

		return overlaps;
	}

	private void getOverlapsWithinSlots(Task newTask, ArrayList<Task> overlaps, Task task) {
		MultipleSlot slot = new MultipleSlot(task.getSlot());
		while (!slot.isEmpty()) {
			DateTimePair pair = slot.getNextSlot();
			slot.removeNextSlot();
			Task currTask = new Task(task.getDesc(), task.getLocation(), pair.getDateTime1(),
					pair.getDateTime2());
			if (currTask.isOverlapping(newTask)) {
				overlaps.add(currTask);
			}
		}
	}

	/**
	 * Method for removing archived tasks that are beyond one month old
	 */
	public void clearOldArchive() {
		ArrayList<Task> outdatedTasks = new ArrayList<Task>();
		for (Task task : _archives) {
			if (task.getDateModified().isBefore(LocalDateTime.now().minusMonths(1))) {
				outdatedTasks.add(task);
			}
		}
		_archives.removeAll(outdatedTasks);
	}

	/**
	 * Method for checking whether taskpointer is currently pointing to an
	 * archived task. If yes, set Displaystate as archive.
	 */
	public void checkPointer() {
		if (_taskPointer != null) {
			if (_archives.contains(_taskPointer)) {
				_currState = LogicData.DisplayState.ARCHIVE;
			}
		}
	}

	/**
	 * Method to reinitialise Storage, called upon very launch of program.
	 */
	public void reinitialiseStorage() {
		_storage = new Storage();
		_tasks = _storage.updateCurrentTaskList();
		_archives = _storage.updateArchiveTaskList();
	}

	/**
	 * Method for to reinitialise Storage for integration testing.
	 */
	public void reinitialiseStorageTester() {
		_storage.delete();
		_storage = new StorageTester();
		_tasks = _storage.updateCurrentTaskList();
		_archives = _storage.updateArchiveTaskList();
	}

	/**
	 * Method for retrieving demo file stored in storage.
	 * 
	 * @return _storage.getDemoText().
	 */
	public ArrayList<String> generateDemoText() {
		return _storage.getDemoText();
	}

	/**
	 * Method for retrieving Indexes selected for demo.
	 * 
	 * @return _storage.getDemoSelectionIndexes().
	 */
	public ArrayList<Integer> generateDemoSelectionIndexes() {
		return _storage.getDemoSelectionIndexes();
	}

	/**
	 * Method for retrieving settings for novice view.
	 * 
	 * @return _storage.getNoviceSettings();
	 */
	public boolean getNoviceSettings() {
		return _storage.getNoviceSettings();
	}

	/**
	 * Sets the novice or advanced view settings.
	 * 
	 * @param isNovice
	 *            boolean to show novice or advanced view
	 */
	public void setNoviceSettings(boolean isNovice) {
		_storage.setNoviceSettings(isNovice);
	}

}
```
###### urgenda\util\Task.java
``` java
package urgenda.util;

import java.time.LocalDateTime;
import java.util.ArrayList;

/**
 * 
 * Task class of Utils Component in Urgenda.
 * Used for storing of information related to a task e.g. timings, location, desc etc.
 *
 */
public class Task {

	private static final String TASK_TYPE_FLOATING = "FLOATING";
	private static final String TASK_TYPE_EVENT = "EVENT";
	private static final String TASK_TYPE_DEADLINE = "DEADLINE";

	/**
	 * 
	 * Different categorisation of tasks.
	 *
	 */
	public enum Type {
		// Event type have start + end time
		EVENT,
		// Deadline type has only end time
		DEADLINE,
		// Floating type has no start and no end time
		FLOATING
	}

	private int _id;
	private String _desc;
	private Type _taskType;
	private String _location;
	private LocalDateTime _startTime;
	private LocalDateTime _endTime;
	private LocalDateTime _dateAdded;
	private LocalDateTime _dateModified;
	private boolean _isCompleted = false;
	private boolean _isImportant = false;
	private boolean _isOverdue = false;
	private MultipleSlot _slot;

	/**
	 * Default constructor for creating a Task object.
	 */
	public Task() {

	}

	/**
	 * Alternative constructor for Task object with String desc specified
	 * @param desc
	 * The String desc of the Task.
	 */
	public Task(String desc) {
		_desc = desc;
		updateTaskType(null, null);
	}

	// constructor for inclusion of details if there is priority
	public Task(String desc, String location, LocalDateTime start, LocalDateTime end,
			boolean isImportant) {
		_desc = desc;
		_location = location;
		updateTaskType(start, end);
		_startTime = start;
		_endTime = end;
		_dateAdded = LocalDateTime.now();
		_dateModified = LocalDateTime.now();
		_isImportant = isImportant;
	}

	// constructor for inclusion of details without priority
	public Task(String desc, String location, LocalDateTime start, LocalDateTime end) {
		_desc = desc;
		_location = location;
		updateTaskType(start, end);
		_startTime = start;
		_endTime = end;
		_dateAdded = LocalDateTime.now();
		_dateModified = LocalDateTime.now();
	}

	// constructor for copying task objects
	public Task(Task originalTask) {
		setId(originalTask.getId());
		setDesc(originalTask.getDesc());
		setTaskType(originalTask.getTaskType());
		setLocation(originalTask.getLocation());
		setStartTime(originalTask.getStartTime());
		setEndTime(originalTask.getEndTime());
		setDateAdded(originalTask.getDateAdded());
		setDateModified(originalTask.getDateModified());
		setIsCompleted(originalTask.isCompleted());
		setIsImportant(originalTask.isImportant());
		setIsOverdue(originalTask.isOverdue());
		setSlot(originalTask.getSlot());
	}

	/**
	 * Full constructor for all variables.
	 * 
	 * @param type
	 *            required to be of String type, will be converted to enum Type
	 *            in constructor
	 */
	public Task(int id, String desc, String type, String location, boolean isCompleted, boolean isImportant,
			boolean isOverdue, LocalDateTime startTime, LocalDateTime endTime, LocalDateTime dateAdded,
			LocalDateTime dateModified, MultipleSlot slot) {
		_id = id;
		_desc = desc;
		setType(type);
		_location = location;
		_isCompleted = isCompleted;
		_isImportant = isImportant;
		_isOverdue = isOverdue;
		_startTime = startTime;
		_endTime = endTime;
		_dateAdded = dateAdded;
		_dateModified = dateModified;
		_slot = slot;

	}

	private void setType(String type) {
		if (type.equalsIgnoreCase(TASK_TYPE_EVENT)) {
			_taskType = Type.EVENT;
		} else if (type.equalsIgnoreCase(TASK_TYPE_DEADLINE)) {
			_taskType = Type.DEADLINE;
		} else if (type.equalsIgnoreCase(TASK_TYPE_FLOATING)) {
			_taskType = Type.FLOATING;
		}
	}

	public void updateTaskType(LocalDateTime start, LocalDateTime end) {
		if (start == null && end == null) {
			_taskType = Type.FLOATING;
		} else if (start == null && end != null) {
			_taskType = Type.DEADLINE;
		} else if (start != null && end != null) {
			_taskType = Type.EVENT;
		}
	}
	
	public void updateTaskType() {
		if (_startTime == null && _endTime == null) {
			_taskType = Type.FLOATING;
		} else if (_startTime == null && _endTime != null) {
			_taskType = Type.DEADLINE;
		} else if (_startTime != null && _endTime != null) {
			_taskType = Type.EVENT;
		}
	}

	public int getId() {
		return _id;
	}

	public String getDesc() {
		return _desc;
	}

	public Type getTaskType() {
		return _taskType;
	}

	public String getLocation() {
		return _location;
	}

	public LocalDateTime getStartTime() {
		return _startTime;
	}

	public LocalDateTime getEndTime() {
		return _endTime;
	}


	public LocalDateTime getDateAdded() {
		return _dateAdded;
	}

	public LocalDateTime getDateModified() {
		return _dateModified;
	}

	public boolean isCompleted() {
		return _isCompleted;
	}

	public boolean isImportant() {
		return _isImportant;
	}

	public boolean isOverdue() {
		return _isOverdue;
	}

	public MultipleSlot getSlot() {
		return _slot;
	}

	public void setId(int id) {
		_id = id;
	}

	public void setDesc(String desc) {
		_desc = desc;
	}

	public void setTaskType(Type taskType) {
		_taskType = taskType;
	}

	public void setLocation(String location) {
		_location = location;
	}

	public void setStartTime(LocalDateTime startTime) {
		_startTime = startTime;
	}

	public void setEndTime(LocalDateTime endTime) {
		_endTime = endTime;
	}
	
	public void setDateAdded(LocalDateTime dateAdded) {
		_dateAdded = dateAdded;
	}

	public void setDateModified(LocalDateTime dateModified) {
		_dateModified = dateModified;
	}

	public void setIsCompleted(boolean isCompleted) {
		_isCompleted = isCompleted;
	}

	public void setIsImportant(boolean isImportant) {
		_isImportant = isImportant;
	}

	public void setIsOverdue(boolean isOverdue) {
		_isOverdue = isOverdue;
	}

	public void setSlot(MultipleSlot slot) {
		_slot = slot;
	}

	public void toggleImportant() {
		if (_isImportant) {
			_isImportant = false;
		} else {
			_isImportant = true;
		}
	}

	// assumes that the task given is not a multipleslot type task
	public boolean isOverlapping(Task task) {
		// defensive code to prevent checking of non event types
		if (task.getTaskType() != Task.Type.EVENT || this.getTaskType() != Task.Type.EVENT) {
			return false;
		}
		LocalDateTime start = task.getStartTime();
		LocalDateTime end = task.getEndTime();
		// checks overlaps if there are multiple slots
		if (this.getSlot() != null) {
			ArrayList<DateTimePair> slots = this.getSlot().getSlots();
			for (DateTimePair pair : slots) {
				if (hasOverlap(start, end, pair.getEarlierDateTime(), pair.getLaterDateTime())) {
					return true;
				}
			}
		}
		// checks for the initial timings in task
		return hasOverlap(start, end, _startTime, _endTime);
	}

	public boolean hasOverlap(LocalDateTime start, LocalDateTime end, LocalDateTime compareStart, LocalDateTime compareEnd) {
		if (end.isAfter(compareStart) && (end.isBefore(compareEnd) || end.isEqual(compareEnd))) {
			return true;
		} else if ((start.isAfter(compareStart) || start.isEqual(compareStart)) && start.isBefore(compareEnd)) {
			return true;
		} else if (start.isBefore(compareStart) && end.isAfter(compareEnd)) {
			return true;
		} else if (start.isEqual(compareStart) && end.isEqual(compareEnd)) {
			return true;
		} else {
			return false;
		}
	}

}
```
###### urgenda\util\TaskList.java
``` java
package urgenda.util;

import java.util.ArrayList;

public class TaskList {

	private ArrayList<Task> _tasks;
	private ArrayList<Task> _archives;
	private int _overdueCount;
	private int _todayCount;
	private int _remainingCount;
	private int _archiveCount;
	
	//default constructor creates empty TaskList
	public TaskList() {
		_tasks = new ArrayList<Task>();
		_archives = new ArrayList<Task>();
		setOverdueCount(0);
		setTodayCount(0);
		setRemainingCount(0);
		setArchiveCount(0);
	}
	
	// constructor for tasklist of only uncompleted task
	public TaskList(ArrayList<Task> tasks, int overdue, int today, int remaining) {
		_tasks = tasks;
		_archives = new ArrayList<Task>();
		setOverdueCount(overdue);
		setTodayCount(today);
		setRemainingCount(remaining);
		setArchiveCount(0);
	}
	
	// constructor for tasklist with both uncompleted and completed task
	public TaskList(ArrayList<Task> tasks, ArrayList<Task> archives, int overdue, int today, 
			int remaining, int archive) {
		_tasks = tasks;
		_archives = archives;
		setOverdueCount(overdue);
		setTodayCount(today);
		setRemainingCount(remaining);
		setArchiveCount(archive);
	}
	
	// constructor for tasklist with only archived tasks
	public TaskList(ArrayList<Task> archives, int archive) {
		_tasks = new ArrayList<Task>();
		_archives = archives;
		setOverdueCount(0);
		setTodayCount(0);
		setRemainingCount(0);
		setArchiveCount(archive);
	}
	
	public ArrayList<Task> getTasks() {
		return _tasks;
	}
	
	public int getOverdueCount() {
		return _overdueCount;
	}

	public void setOverdueCount(int overdueCount) {
		_overdueCount = overdueCount;
	}

	public int getTodayCount() {
		return _todayCount;
	}

	public void setTodayCount(int todayCount) {
		_todayCount = todayCount;
	}

	public int getRemainingCount() {
		return _remainingCount;
	}

	public void setRemainingCount(int remainingCount) {
		_remainingCount = remainingCount;
	}

	public ArrayList<Task> getArchives() {
		return _archives;
	}

	public int getArchiveCount() {
		return _archiveCount;
	}

	public void setArchives(ArrayList<Task> archives) {
		_archives = archives;
	}

	public void setArchiveCount(int archiveCount) {
		_archiveCount = archiveCount;
	}
	
	public int getUncompletedCount() {
		return _overdueCount + _todayCount + _remainingCount;
	}

}
```
###### urgenda\util\UrgendaLogger.java
``` java
package urgenda.util;

import java.io.File;
import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

public class UrgendaLogger {
	
	private final static Logger myLogger = Logger.getLogger(UrgendaLogger.class.getName());
	private static UrgendaLogger _loggerInstance = null;
	
	private static File _parentDir;

	public static UrgendaLogger getInstance() {
		if (_loggerInstance == null) {
			setUpLogger();
			_loggerInstance = new UrgendaLogger();
		}
		return _loggerInstance;
	}

	private static void setUpLogger() {
		try {
			createFileSettings();
			FileHandler fh = new FileHandler("settings/UrgendaLog.txt");
			fh.setFormatter(new SimpleFormatter());
			myLogger.addHandler(fh);
			myLogger.setUseParentHandlers(false);
			myLogger.setLevel(Level.FINEST);
		} catch (IOException e) {
			myLogger.log(Level.SEVERE, "Error occur in FileHandler.", e);
		}
	}
	
	private static void createFileSettings() {
		_parentDir = new File("settings");
		_parentDir.mkdir();
		
	}

	public Logger getLogger() {
		return myLogger;
	}

}
```
