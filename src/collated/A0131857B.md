# A0131857B
###### urgenda\gui\DemoController.java
``` java
package urgenda.gui;

import java.util.ArrayList;

import javafx.fxml.FXML;
import javafx.scene.input.MouseEvent;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;

/**
 * UI component that controls the features demo of Urgenda.
 * 
 * @author KangSoon
 */
public class DemoController {

	// Elements loaded using FXML
	@FXML
	private TextFlow demoTextArea;

	// Private attributes
	private ArrayList<String> _demoText = new ArrayList<String>();
	private ArrayList<Integer> _demoSelectionIndexes = new ArrayList<Integer>();
	private MainController _mainController;
	private int _demoIndex = 0;

	/**
	 * Creates a DemoController.
	 * 
	 * @param mainController
	 *            MainController object that invoked this method
	 * @param demoText
	 *            array of text to be shown during demo
	 * @param demoSelectionIndexes
	 *            array of indexes for selection of tasks during steps of demo
	 */
	public DemoController(MainController mainController, ArrayList<String> demoText,
			ArrayList<Integer> demoSelectionIndexes) {
		_mainController = mainController;
		_demoText.addAll(demoText);
		_demoSelectionIndexes.addAll(demoSelectionIndexes);
	}

	/**
	 * Initialise attributes for demo.
	 */
	public void init() {
		_demoIndex = 0;
		showDemoPart(_demoIndex);
	}

	private void showDemoPart(int index) {
		demoTextArea.getChildren().clear();
		demoTextArea.getChildren().add(new Text(_demoText.get(index)));
		_mainController.getDisplayController().setSelectedTaskByCall(_demoSelectionIndexes.get(_demoIndex),
				false);
	}

	@FXML
	private void nextPartListener(MouseEvent e) {
		nextPart();
	}

	@FXML
	private void prevPartListener(MouseEvent e) {
		prevPart();
	}

	/**
	 * Shows the next part of the demo, or returns to all tasks view if demo has
	 * finished.
	 */
	public void nextPart() {
		if (_demoIndex < _demoText.size()) {
			_demoIndex++;
		}
		if (_demoIndex >= _demoText.size()) {
			_mainController.setDemo(false);
		} else {
			showDemoPart(_demoIndex);
		}
	}

	/**
	 * Returns to the previous part of the demo if it is not on the first part.
	 */
	public void prevPart() {
		if (_demoIndex > 0) {
			_demoIndex--;
			showDemoPart(_demoIndex);
		}
	}

	/**
	 * Returns the index of the part demo is at.
	 * 
	 * @return part the demo is at
	 */
	public int getDemoIndex() {
		return _demoIndex;
	}

	/**
	 * Sets the part demo is at by index.
	 * 
	 * @param _demoIndex
	 *            part to set the demo for
	 */
	public void setDemoIndex(int _demoIndex) {
		this._demoIndex = _demoIndex;
	}
}
```
###### urgenda\gui\DetailedTaskController.java
``` java
package urgenda.gui;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.image.ImageView;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;
import urgenda.gui.DisplayController.Direction;
import urgenda.gui.DisplayController.TaskDisplayType;
import urgenda.util.Task;

/**
 * UI component and child of SimpleTaskController, invoked when showing a
 * detailed task panel for a single task.
 * 
 * @author KangSoon
 */
public class DetailedTaskController extends SimpleTaskController {

	// Constants
	private static final String FORMATTER_DATE_TIME_FORMAT = "dd-MM-yyyy HH:mm:ss";

	// File paths
	private static final String PATH_DETAILEDTASKVIEW_FXML = "fxml/DetailedTaskView.fxml";

	// Elements loaded using FXML
	@FXML
	private Text dateCreatedHeader;
	@FXML
	private Text dateModifiedHeader;
	@FXML
	private Text dateCreatedText;
	@FXML
	private Text dateModifiedText;
	@FXML
	private VBox detailsDisplayArea;
	@FXML
	private ImageView locationIcon;
	@FXML
	private Text taskLocationText;
	@FXML
	private VBox dateTimesHolder;
	@FXML
	private HBox locationHolder;

	/**
	 * Creates a DetailedTaskController using the given task.
	 * 
	 * @param task
	 *            task to show details for
	 * @param index
	 *            index of the task
	 * @param taskDisplayType
	 *            the enumerated type of the task
	 * @param showHeader
	 *            boolean to show headers for the task or not
	 */
	public DetailedTaskController(Task task, int index, TaskDisplayType taskDisplayType, boolean showHeader) {
		super(task, index, taskDisplayType, showHeader); // invoke SimpleTaskController constructor
		multipleSlotCounter.setVisible(false);
		initDetailedLabels();
	}

	private void initDetailedLabels() {
		dateCreatedText.setText(formatDetailsDateTime(_task.getDateAdded()));
		dateModifiedText.setText(formatDetailsDateTime(_task.getDateModified()));
		if (_task.getLocation() != null) {
			taskLocationText.setText(_task.getLocation());
		}
		if (_task.getLocation() == null || _task.getLocation().isEmpty()) {
			locationHolder.setVisible(false);
		}
		if (_task.getSlot() != null) { // task has multiple time slots
			taskDateTimeText.setText(formatDateTime(_multipleSlotList.get(0).getEarlierDateTime(),
					_multipleSlotList.get(0).getLaterDateTime()));
			for (int i = 1; i < _multipleSlotList.size(); i++) {
				Text newText = new Text(formatDateTime(_multipleSlotList.get(i).getEarlierDateTime(),
						_multipleSlotList.get(i).getLaterDateTime()));
				dateTimesHolder.getChildren().add(i, newText);
			}
		}
	}

	private String formatDetailsDateTime(LocalDateTime dateTime) {
		DateTimeFormatter formatter = DateTimeFormatter.ofPattern(FORMATTER_DATE_TIME_FORMAT);
		return dateTime.format(formatter);
	}

	@Override
	protected void loadFXML() {
		FXMLLoader loader = new FXMLLoader(getClass().getResource(PATH_DETAILEDTASKVIEW_FXML));
		loader.setController(this);
		loader.setRoot(this);
		try {
			loader.load();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	@Override
	public void traverseMultipleSlot(Direction direction) {
		// disable traverses for detailed tasks
	}
}
```
###### urgenda\gui\DisplayController.java
``` java
package urgenda.gui;

import java.util.ArrayDeque;
import java.util.ArrayList;

import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;
import urgenda.util.Task;
import urgenda.util.TaskList;

/**
 * UI component, sets the display view for the relevant tasks to be shown
 * according to their respective attributes.
 * 
 * @author KangSoon
 */
public class DisplayController extends AnchorPane {


	// Enumerations
	public enum TaskDisplayType {
		OVERDUE, TODAY, NORMAL, ARCHIVE, FREE_TIME
	}

	public enum Direction {
		DOWN, UP, LEFT, RIGHT
	}

	// Constants
	private static final String MESSAGE_ZERO_TASKS = "\nYou have no tasks to display!";
	private static final String KEYWORD_SHOWMORE = "showmore";
	private static final int INVALID_INDEX = -1;

	// Elements loaded using FXML
	@FXML
	private Label displayHeader;
	@FXML
	private VBox displayHolder;
	@FXML
	private ScrollPane displayArea;

	// Private attributes
	private ArrayList<Task> _displayedTasks;
	private ArrayDeque<Integer> _detailedIndexes;
	private IntegerProperty _selectedTaskIndex;
	private boolean _isNoviceView;
	private boolean _setup;
	private boolean _allowChangeScroll;
	private Main _main;

	/**
	 * Creates a DisplayController.
	 */
	public DisplayController() {
		_isNoviceView = true;
		_setup = true;
		_selectedTaskIndex = new SimpleIntegerProperty(INVALID_INDEX);
		_selectedTaskIndex.addListener(new ChangeListener<Number>() {
			@Override
			public void changed(ObservableValue<? extends Number> value, Number oldIndex, Number newIndex) {
				if (!_setup) {
					setDisplayScrollHeight();
				}
				if (displayHolder.getChildren().get(_selectedTaskIndex.getValue()).getClass()
						.equals(SimpleTaskController.class)) {
					if (((SimpleTaskController) displayHolder.getChildren()
							.get(_selectedTaskIndex.getValue())).isMultipleSlot()) {
						boolean isMultipleSlotTask = ((SimpleTaskController) displayHolder.getChildren()
								.get(_selectedTaskIndex.getValue())).isMultipleSlot();
						boolean isDetailed = (displayHolder.getChildren().get(_selectedTaskIndex.getValue()))
								.getClass().equals(DetailedTaskController.class);
						_main.getController().toggleMultipleSlotMenuOption(!isDetailed && isMultipleSlotTask);
					} else {
						_main.getController().toggleMultipleSlotMenuOption(false);
					}
				}
			}
		});
		_displayedTasks = new ArrayList<Task>();
		_detailedIndexes = new ArrayDeque<Integer>();
		_allowChangeScroll = false; // set default change scroll as false
	}

	/**
	 * Initializes the display view at startup with the default tasks view.
	 * 
	 * @param updatedTasks
	 *            TaskList object containing all tasks to be shown in current
	 *            screen
	 * @param displayHeader
	 *            text to be set for the header indicating currently displayed
	 *            tasks
	 * @param showmoreIndexes
	 *            array of indexes for all tasks to show more details for
	 * @param modifiedTaskIndex
	 *            index of task to be set as selected
	 */
	public void initDisplay(TaskList updatedTasks, String displayHeader, ArrayList<Integer> showmoreIndexes,
			int modifiedTaskIndex, boolean isShowNoviceHeaders) {
		setDisplay(updatedTasks, displayHeader, showmoreIndexes, modifiedTaskIndex,
				false, false);
		// set listener for scrolling of pane
		displayArea.vvalueProperty().addListener(new ChangeListener<Number>() {
			@Override
			public void changed(ObservableValue<? extends Number> value, Number oldValue, Number newValue) {
				// prevent changes to scroll height of displayArea other than
				// method calls and mouse or touch scrolls
				if (!_allowChangeScroll && oldValue != newValue) {
					changeDisplayVvalue(oldValue.doubleValue());
				}
			}
		});
		displayArea.addEventFilter(ScrollEvent.SCROLL, new EventHandler<ScrollEvent>() {
			@Override
			public void handle(ScrollEvent scrollEvent) {
				if (!_allowChangeScroll) { // allow if is mouse/touch scroll
											// event
					_allowChangeScroll = true;
				}
			}
		});
	}

	/**
	 * Sets up display view with the list of tasks given.
	 * 
	 * @param updatedTasks
	 *            Tasklist object containing all tasks to be shown in current
	 *            screen
	 * @param displayHeader
	 *            text to be set for the header indicating currently displayed
	 *            tasks
	 * @param showmoreIndexes
	 *            array of indexes for all tasks to show more details for
	 * @param modifiedTaskIndex
	 *            index of task to be set as selected
	 * @param isShowFreeTime
	 *            boolean indicating view is show free time or not
	 * @param isDemo
	 *            boolean indicating view is demo view or not
	 */
	public void setDisplay(TaskList updatedTasks, String displayHeader, ArrayList<Integer> showmoreIndexes,
			int modifiedTaskIndex, boolean isShowFreeTime, boolean isDemo) {
		_setup = true;
		_allowChangeScroll = false;
		displayHolder.getChildren().clear();
		_displayedTasks.clear();
		_displayedTasks.addAll(updatedTasks.getTasks());
		_displayedTasks.addAll(updatedTasks.getArchives());
		_detailedIndexes.clear();
		_detailedIndexes.addAll(showmoreIndexes);

		createTaskControllers(updatedTasks, isShowFreeTime);
		
		if (updatedTasks.getArchiveCount() + updatedTasks.getUncompletedCount() == 0) {
			showZeroTasksFeedback();
		} else {
			if (!isDemo) {
				initSelectedTask(modifiedTaskIndex);
			} else {
				initSelectedTask(_selectedTaskIndex.get());
			}
		}
		if (displayHeader != null) { // display header needs to be changed
			setDisplayHeader(displayHeader);
		}
	}

	private void createTaskControllers(TaskList updatedTasks, boolean isShowFreeTime) {
		if (_main.getController().isDemo()) {
			_isNoviceView = true;
		}
		int indexCounter = 0;
		if (updatedTasks.getUncompletedCount() != 0) {
			if (isShowFreeTime) {
				indexCounter += showStyledTaskView(indexCounter, updatedTasks.getTasks().size(),
						TaskDisplayType.FREE_TIME, false);
			} else if (_isNoviceView) {
				if (updatedTasks.getOverdueCount() > 0) {
					indexCounter += showStyledTaskView(indexCounter, 1, TaskDisplayType.OVERDUE, _isNoviceView);
					indexCounter += showStyledTaskView(indexCounter, updatedTasks.getOverdueCount() - 1,
							TaskDisplayType.OVERDUE, false);
				}
				if (updatedTasks.getTodayCount() > 0) {
					indexCounter += showStyledTaskView(indexCounter, 1, TaskDisplayType.TODAY, _isNoviceView);
					indexCounter += showStyledTaskView(indexCounter, updatedTasks.getTodayCount() - 1,
							TaskDisplayType.TODAY, false);
				}
				if (updatedTasks.getRemainingCount() > 0) {
					indexCounter += showStyledTaskView(indexCounter, 1, TaskDisplayType.NORMAL, _isNoviceView);
					indexCounter += showStyledTaskView(indexCounter, updatedTasks.getRemainingCount() - 1,
							TaskDisplayType.NORMAL, false);
				}
			} else {
				indexCounter += showStyledTaskView(indexCounter, updatedTasks.getOverdueCount(),
						TaskDisplayType.OVERDUE, false);
				indexCounter += showStyledTaskView(indexCounter, updatedTasks.getTodayCount(),
						TaskDisplayType.TODAY, false);
				indexCounter += showStyledTaskView(indexCounter, updatedTasks.getRemainingCount(),
						TaskDisplayType.NORMAL, false);
			}
		}
		if (updatedTasks.getArchiveCount() != 0) {
			if (_isNoviceView) {
				indexCounter += showStyledTaskView(indexCounter, 1, TaskDisplayType.ARCHIVE, _isNoviceView);
				indexCounter += showStyledTaskView(indexCounter, updatedTasks.getArchiveCount() - 1,
						TaskDisplayType.ARCHIVE, false);
			} else {
				indexCounter += showStyledTaskView(indexCounter, updatedTasks.getArchiveCount(),
						TaskDisplayType.ARCHIVE, false);
			}	
		}
		if (_main.getController().isDemo()) {
			_isNoviceView = false;
		}
	}

	// create indicated number of tasks of given type with reference to whether
	// to show details for tasks or not
	private int showStyledTaskView(int currIndex, int toAddCount, TaskDisplayType taskDisplayType,
			boolean showHeader) {
		int addedCount = 0;
		while (addedCount < toAddCount) {
			if (isDetailed(currIndex)) {
				DetailedTaskController newDetailedTaskView = new DetailedTaskController(
						_displayedTasks.get(currIndex), currIndex, taskDisplayType, showHeader);
				newDetailedTaskView.setDisplayController(this);
				displayHolder.getChildren().add(newDetailedTaskView);
			} else {
				SimpleTaskController newTaskView = new SimpleTaskController(_displayedTasks.get(currIndex),
						currIndex, taskDisplayType, showHeader);
				newTaskView.setDisplayController(this);
				displayHolder.getChildren().add(newTaskView);
			}
			addedCount++;
			currIndex++;
		}
		return addedCount;
	}

	private boolean isDetailed(int currIndex) {
		if (!_detailedIndexes.isEmpty() && currIndex == _detailedIndexes.peekFirst()) {
			_detailedIndexes.removeFirst();
			return true;
		}
		return false;
	}

	private void showZeroTasksFeedback() {
		Text emptyDisplay = new Text(MESSAGE_ZERO_TASKS);
		emptyDisplay.setFont(Main.BOLD_FONT);
		displayHolder.getChildren().add(emptyDisplay);
	}

	private void initSelectedTask(int index) {
		if (!_displayedTasks.isEmpty()) {
			_selectedTaskIndex.set(index);
			((SimpleTaskController) displayHolder.getChildren().get(index)).setSelected(true);
		} else {
			_selectedTaskIndex.set(INVALID_INDEX);
		}
	}

	/**
	 * Sets the scroll height of the display according to the currently selected
	 * task.
	 */
	protected void setDisplayScrollHeight() {
		double selectedIndexTop = 0.0;
		double selectedIndexBottom = 0.0;
		double heightSum = 0.0;
		for (int i = 0; i < displayHolder.getChildren().size(); i++) {
			heightSum += ((SimpleTaskController) displayHolder.getChildren().get(i)).getHeight();
			if (i == _selectedTaskIndex.intValue() - 1) {
				selectedIndexTop = heightSum;
			}
			if (i == _selectedTaskIndex.intValue()) {
				selectedIndexBottom = heightSum;
			}
		}
		displayArea.setVmax(heightSum - displayArea.getHeight());
		double oldScrollHeightTop = displayArea.getVvalue();
		double oldScrollHeightBottom = displayArea.getVvalue() + displayArea.getViewportBounds().getHeight();
		// check if task is fully visible
		if (!isFullyWithinRange(oldScrollHeightTop, oldScrollHeightBottom, selectedIndexTop, 
				selectedIndexBottom)) {
			if (selectedIndexTop > oldScrollHeightTop) { // task below screen
				changeDisplayVvalue(selectedIndexBottom - displayArea.getViewportBounds().getHeight());
			} else if (selectedIndexBottom < oldScrollHeightBottom) { // task above screen
				changeDisplayVvalue(selectedIndexTop);
			}
		}
	}

	private boolean isFullyWithinRange(double rangeTop, double rangeBottom, double top, double bottom) {
		if (top < rangeTop) {
			return false;
		}
		if (bottom > rangeBottom) {
			return false;
		}
		return true;
	}

	/**
	 * Traverses the task selection or the multiple slots of the selected task,
	 * according to the direction indicated.
	 * 
	 * @param direction
	 *            to traverse for
	 */
	public void executeTraverse(Direction direction) {
		if (!_main.getController().isDemo()) {
			switch (direction) {
			case DOWN:
				if (_selectedTaskIndex.getValue() < _displayedTasks.size() - 1) {
					((SimpleTaskController) displayHolder.getChildren().get(_selectedTaskIndex.getValue()))
							.setSelected(false);
					_selectedTaskIndex.set(_selectedTaskIndex.getValue() + 1);
					((SimpleTaskController) displayHolder.getChildren().get(_selectedTaskIndex.getValue()))
							.setSelected(true);
				}
				break;
			case UP:
				if (_selectedTaskIndex.getValue() != 0) {
					((SimpleTaskController) displayHolder.getChildren().get(_selectedTaskIndex.getValue()))
							.setSelected(false);
					_selectedTaskIndex.set(_selectedTaskIndex.getValue() - 1);
					((SimpleTaskController) displayHolder.getChildren().get(_selectedTaskIndex.getValue()))
							.setSelected(true);
				}
				break;
			case LEFT: // fall-through
			case RIGHT:
				((SimpleTaskController) displayHolder.getChildren().get(_selectedTaskIndex.getValue()))
						.traverseMultipleSlot(direction);
				break;
			}
		}
	}

	/**
	 * Sets indicated task as selected.
	 * 
	 * @param index
	 *            index of task to set as selected
	 * @param isInitDemo
	 *            boolean to indicate call by initialising demo view or not
	 */
	protected void setSelectedTaskByCall(int index, boolean isInitDemo) {
		if (_selectedTaskIndex.get() >= 0 && index != _selectedTaskIndex.getValue()) {
			if (!isInitDemo) {
				((SimpleTaskController) displayHolder.getChildren().get(_selectedTaskIndex.getValue()))
						.setSelected(false);
			}
		}
		if (displayHolder.getChildren().get(index).getClass().equals(SimpleTaskController.class)) {
			((SimpleTaskController) displayHolder.getChildren().get(index)).setSelected(true);
		} else if (displayHolder.getChildren().get(index).getClass().equals(DetailedTaskController.class)) {
			((DetailedTaskController) displayHolder.getChildren().get(index)).setSelected(true);
		}
		_selectedTaskIndex.set(index);
	}

	/**
	 * 
	 */
	protected void toggleSelectedDetailsOnClick() {
		_main.handleCommandLine(KEYWORD_SHOWMORE);
	}

	/**
	 * Sets the display header text.
	 * 
	 * @param headerText
	 *            text to display as header
	 */
	public void setDisplayHeader(String headerText) {
		displayHeader.setText(headerText);
	}

	/**
	 * Sets the display area scroll height.
	 * 
	 * @param value
	 *            scroll height to be set at
	 */
	void changeDisplayVvalue(double value) {
		_allowChangeScroll = true;
		displayArea.setVvalue(value);
		_allowChangeScroll = false;
	}

	/**
	 * Gets the index of the currently selected task.
	 * 
	 * @return index of currently selected task
	 */
	public int getSelectedTaskIndex() {
		return _selectedTaskIndex.getValue();
	}

	/**
	 * Gets the number of tasks displayed.
	 * 
	 * @return number of tasks displayed
	 */
	public int getDisplayedTasksCount() {
		return _displayedTasks.size();
	}

	/**
	 * Sets boolean for setup of display.
	 * 
	 * @param setup
	 *            boolean for setup for display
	 */
	public void setSetup(boolean setup) {
		_setup = setup;
	}

	/**
	 * Toggles the novice view.
	 * 
	 * @param isNovice boolean to set for novice view or not
	 */
	public void setNoviceSettings(boolean isNovice) {
		_isNoviceView = isNovice;
	}
	
	/**
	 * Returns novice view settings.
	 * 
	 * @return boolean for novice view settings
	 */
	public boolean getNoviceSettings() {
		return _isNoviceView;
	}
	
	/**
	 * Sets the reference to the Main UI object instance.
	 * 
	 * @param main
	 *            Main UI object instance
	 */	
	public void setMain(Main main) {
		_main = main;
	}

	/**
	 * Gets the reference to the Main UI object instance.
	 * 
	 * @return Main UI object instance
	 */
	public Main getMain() {
		return _main;
	}
}
```
###### urgenda\gui\HelpController.java
``` java
package urgenda.gui;

import java.io.IOException;
import java.net.URL;
import java.util.ArrayList;
import java.util.ResourceBundle;

import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.fxml.Initializable;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.TextArea;
import javafx.scene.image.Image;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

/**
 * UI components, controls the elements in help window.
 * 
 * @author KangSoon
 */
public class HelpController implements Initializable {
	
	// Constants
	private static final String HELP_NAME = "Help";
	
	// File paths
	private static final String PATH_HELP_SPLASH_FXML = "fxml/HelpSplash.fxml";
	private static final String PATH_ICON = "../../resources/urgenda_icon.png";
	
	// Private attributes
	static Stage _helpStage;
	static Scene _helpScene;
	private static ArrayList<String> _helpText;
	private int _helpTextPos;
	
	// Elements loaded using FXML
	@FXML
	private TextArea helpContentPane;
	@FXML
	private Button helpPrev;
	@FXML
	private Button helpNext;
	
	@FXML
	private void handleEscPressed(KeyEvent event) {
		if (event.getCode() == KeyCode.ENTER || event.getCode() == KeyCode.ESCAPE) {
			_helpStage.close();
		}
	}
	
	@FXML
	private void handleOkAction(ActionEvent e) {
		_helpStage.close();
	}
	
	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {	
		_helpTextPos = 0;
		helpContentPane.setText(_helpText.get(_helpTextPos));
		helpContentPane.setEditable(false);
	}
	
	/**
	 * Sets up the help window.
	 * @param helpText list of help text to display
	 * @throws IOException 
	 */
	public void setupHelpStage(ArrayList<String> helpText) throws IOException {		
		_helpText = helpText;
		Parent help = FXMLLoader.load(Main.class.getResource(PATH_HELP_SPLASH_FXML));
		_helpStage = new Stage();
		_helpScene = new Scene(help);
		_helpStage.setScene(_helpScene);
		_helpStage.initStyle(StageStyle.DECORATED);
		_helpStage.getIcons().add(new Image(getClass().getResourceAsStream(PATH_ICON)));
		_helpStage.setTitle(HELP_NAME);
		showHelpStage();
		_helpScene.setOnKeyReleased(new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent event) {
				if(event.getCode().equals(KeyCode.LEFT)) {
					helpPrev();
				}
				if(event.getCode().equals(KeyCode.RIGHT)) {
					helpNext();
				}
			}	
		});
	}
	
	@FXML
	private void helpPrevListener(ActionEvent e) {
		helpPrev();
	}

	private void helpPrev() {
		if(_helpTextPos > 0) {
			_helpTextPos--;
			helpContentPane.setText(_helpText.get(_helpTextPos));
		}
	}

	private void helpNext() {
		if(_helpTextPos < _helpText.size() - 1) {
			_helpTextPos++;
			helpContentPane.setText(_helpText.get(_helpTextPos));
		}
	}
	
	@FXML
	private void helpNextListener(ActionEvent e) {
		helpNext();
	}
	
	/**
	 * Shows the help window.
	 */
	public void showHelpStage() {
		_helpStage.show();
	}
	
	/**
	 * Closes the help window.
	 */
	public void closeHelpWindow() {
		_helpStage.close();		
	}
	
	/**
	 * Gets the help stage used for the window.
	 * @return help stage used for the window
	 */
	public Stage getHelpStage() {
		return _helpStage;
	}
}
```
###### urgenda\gui\InputSuggestionsPopupController.java
``` java
package urgenda.gui;

import java.util.ArrayList;
import java.util.StringTokenizer;

import javafx.fxml.FXML;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.FlowPane;
import javafx.scene.layout.HBox;
import javafx.scene.paint.Color;
import javafx.scene.paint.Paint;
import javafx.scene.text.Text;
import urgenda.util.SuggestFeedback;

/**
 * UI component, controls the elements that are used for the suggestions popup and styles keywords in suggestions for better readability.
 * 
 * @author KangSoon
 */
public class InputSuggestionsPopupController extends BorderPane {

	// File paths
	private static final String PATH_INPUT_SUGGESTIONS_CSS = "styles/InputSuggestions.css";
	
	// Delimiters to identify by and for replacement during formatting
	private static final String DELIMITER_CHAR = "[]<>";
	private static final String DELIMITER_NON_SUGGESTION = "or";
	private static final String DELIMITER_SUGGESTION = " / ";
	
	// Strings to identify by for formatting
	private static final String SUBSTRING_INDEX = "task no";
	private static final String SUBSTRING_DESC = "desc";
	private static final String SUBSTRING_DESC_EDIT = "new desc";
	private static final String SUBSTRING_DATE_TIME_NEW = "new timing(s)";	
	private static final String SUBSTRING_DATE_TIME_REMOVE = "-r";	
	private static final String SUBSTRING_DATE_TIME_START = "start time";
	private static final String SUBSTRING_DATE_TIME_END = "end time";
	private static final String SUBSTRING_DATE_TIME_DURATION = "duration";
	private static final String SUBSTRING_DATE_TIME_DEADLINE = "deadline";
	private static final String SUBSTRING_DATE_TIME_SEARCH = "date/month/day/time";
	private static final String SUBSTRING_TASK_TYPE_SEARCH = "task type";
	private static final String SUBSTRING_LOCATION = "location";
	private static final String SUBSTRING_PATH_DIRECTORY = "path directory";
	private static final String SUBSTRING_INFO_REMOVE_TIME = "removes a timing";
	private static final String SUBSTRING_INFO_TIMING = "use at/from/on/by for timings";
	private static final String SUBSTRING_INFO_OPTIONAL = "optional";
	private static final String SUBSTRING_INFO_MULTIPLE = "multiple";
	
	// Colors to use for formatting
	private static final Color COLOR_DEFAULT = Color.web("#FFFFFF"); //white
	private static final Color COLOR_INDEX = Color.web("#FFAF4B"); //orange
	private static final Color COLOR_DESC = Color.web("#FFA3A3"); //pink
	private static final Color COLOR_DATE_TIME = Color.web("#86E086"); //green
	private static final Color COLOR_TASK_TYPE = Color.web("#559BFF"); //blue
	private static final Color COLOR_LOCATION = Color.web("#559BFF"); //blue
	private static final Color COLOR_PATH_DIRECTORY = Color.web("#559BFF"); //blue
	private static final Color COLOR_SUGGESTED_COMMANDS = Color.web("#B5B5B5"); //grey
	private static final Paint COLOR_INFO = Color.web("#B5B5B5"); //grey

	// Elements loaded using FXML
	@FXML
	private BorderPane typeSuggestionsPane;
	@FXML
	private Text commandWordText;
	@FXML
	private FlowPane suggestionsArea;
	@FXML
	private Text userSuggestionText;
	
	/**
	 * Creates a InputSuggestionsPopupController instance.
	 */
	public InputSuggestionsPopupController() {
		this.getStylesheets().addAll(getClass().getResource(PATH_INPUT_SUGGESTIONS_CSS).toExternalForm());
	}
	
	/**
	 * updates the suggested commands or input formats according to the current user input.
	 * @param suggestFeedback suggestFeedback object containing suggested command words or suggested format
	 */
	public void updateSuggestions(SuggestFeedback suggestFeedback) {
		suggestionsArea.getChildren().clear();
		if (suggestFeedback.isCommand()) {
			commandWordText.setText(suggestFeedback.getCurrCmd() + " ");
			commandWordText.setVisible(true);
		} else {
			commandWordText.setText("");
			commandWordText.setVisible(false);
		}
		for (String suggestionString : suggestFeedback.getSuggestions()) {
			suggestionsArea.getChildren().add(formatSingleSuggestion(suggestionString, suggestFeedback.isSuggestion()));
		}
		// remove last delimiter
		if (suggestionsArea.getChildren().size() > 0) {
			HBox lastItem = (HBox) suggestionsArea.getChildren().get(suggestionsArea.getChildren().size() - 1);
			lastItem.getChildren().remove(lastItem.getChildren().size() - 1);
		}
		userSuggestionText.setText(suggestFeedback.getUserInstructionsPrompt());
	}

	//identify and apply styles to keywords accordingly
	private HBox formatSingleSuggestion(String suggestionString, boolean isSuggestion) {
		HBox singleSuggestion = new HBox();
		ArrayList<Text> suggestionsTokenisedList = new ArrayList<Text>();
		StringTokenizer suggestionsTokeniser = new StringTokenizer(suggestionString, DELIMITER_CHAR);
		while (suggestionsTokeniser.hasMoreElements()) {
			String tokenized = suggestionsTokeniser.nextElement().toString();
			Text tokenizedText;
			switch (tokenized) {
			case SUBSTRING_INDEX:
				tokenizedText = new Text("[" + tokenized + "]");
				tokenizedText.setFill(COLOR_INDEX);
				break;
			case SUBSTRING_DESC: // fall-through
			case SUBSTRING_DESC_EDIT:
				tokenizedText = new Text("[" + tokenized + "]");
				tokenizedText.setFill(COLOR_DESC);
				break;
			case SUBSTRING_DATE_TIME_START: // fall-through
			case SUBSTRING_DATE_TIME_END: // fall-through
			case SUBSTRING_DATE_TIME_DEADLINE: // fall-through
			case SUBSTRING_DATE_TIME_DURATION: //fall-through
			case SUBSTRING_DATE_TIME_NEW: //fall-through
			case SUBSTRING_DATE_TIME_SEARCH:
				tokenizedText = new Text("[" + tokenized + "]");
				tokenizedText.setFill(COLOR_DATE_TIME);
				break;
			case SUBSTRING_DATE_TIME_REMOVE:
				tokenizedText = new Text(tokenized);
				tokenizedText.setFill(COLOR_TASK_TYPE);
				break;
			case SUBSTRING_TASK_TYPE_SEARCH:
				tokenizedText = new Text("[" + tokenized + "]");
				tokenizedText.setFill(COLOR_TASK_TYPE);
				break;
			case SUBSTRING_LOCATION:
				tokenizedText = new Text("[" + tokenized + "]");
				tokenizedText.setFill(COLOR_LOCATION);
				break;
			case SUBSTRING_PATH_DIRECTORY:
				tokenizedText = new Text("[" + tokenized + "]");
				tokenizedText.setFill(COLOR_PATH_DIRECTORY);
				break;
			case SUBSTRING_INFO_REMOVE_TIME: //fall-through
			case SUBSTRING_INFO_OPTIONAL: //fall-through
			case SUBSTRING_INFO_MULTIPLE:
				tokenizedText = new Text("(" + tokenized + ")");
				tokenizedText.setFill(COLOR_INFO);
				break;
			case SUBSTRING_INFO_TIMING:
				tokenizedText = new Text("<" + tokenized + ">");
				tokenizedText.setFill(COLOR_INFO);
				break;
			default:
				tokenizedText = new Text(tokenized);
				if(isSuggestion) {
					tokenizedText.setFill(COLOR_SUGGESTED_COMMANDS);
				} else {
					tokenizedText.setFill(COLOR_DEFAULT);
				}
				break;
			}
			suggestionsTokenisedList.add(tokenizedText);
		}
		singleSuggestion.getChildren().addAll(suggestionsTokenisedList);
		Text delimiter = new Text();
		if(isSuggestion) {
			delimiter.setText(DELIMITER_SUGGESTION);
			delimiter.setFill(COLOR_DEFAULT);
		} else {
			delimiter.setText(DELIMITER_NON_SUGGESTION);
			delimiter.setFill(COLOR_INFO);
		}
		singleSuggestion.getChildren().add(delimiter);
		return singleSuggestion;
	}
}
```
###### urgenda\gui\Main.java
``` java
package urgenda.gui;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;

import javafx.application.Application;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.fxml.FXMLLoader;
import javafx.geometry.BoundingBox;
import javafx.geometry.Bounds;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.layout.BorderPane;
import javafx.scene.text.Font;
import javafx.stage.Screen;
import javafx.stage.Stage;
import javafx.stage.StageStyle;
import urgenda.logic.Logic;
import urgenda.util.DemoStateFeedback;
import urgenda.util.StateFeedback;
import urgenda.util.SuggestFeedback;
import urgenda.util.TaskList;
import urgenda.util.UrgendaLogger;

/**
 * The main class in the UI component, in charge of initializing the program and
 * the sub-components of UI which are MainController and DisplayController.
 *
 * @author KangSoon
 */
public class Main extends Application {

	private static final String APP_NAME = "Urgenda";

	// File paths
	private static final String PATH_GUI_FXML = "fxml/MainView.fxml";
	public static final String PATH_REGULAR_FONT = new String("../../resources/Montserrat-Light.otf");
	public static final String PATH_BOLD_FONT = new String("../../resources/Montserrat-Regular.otf");
	public static final String PATH_LIGHT_FONT = new String("../../resources/Montserrat-UltraLight.ttf");

	// Display header texts
	private static final String HEADER_ALL_TASKS = "ALL TASKS";
	private static final String HEADER_ALL_WITH_COMPLETED_TASKS = "ALL TASKS WITH COMPLETED TASKS";
	private static final String HEADER_FREE_TIME = "AVAILABLE TIME PERIODS";
	private static final String HEADER_SEARCH_RESULTS = "SEARCH RESULTS";
	private static final String HEADER_ARCHIVE_TASKS = "ARCHIVE TASKS";
	private static final String HEADER_MULTIPLE_MATCHES = "MULTIPLE MATCHES";

	private static final int DEFAULT_REGULAR_FONT_SIZE = 20;
	private static final int DEFAULT_BOLD_FONT_SIZE = 20;
	private static final int DEFAULT_LIGHT_FONT_SIZE = 20;

	// Fonts
	public static final Font REGULAR_FONT = Font.loadFont(Main.class.getResourceAsStream(PATH_REGULAR_FONT),
			DEFAULT_REGULAR_FONT_SIZE);
	public static final Font BOLD_FONT = Font.loadFont(Main.class.getResourceAsStream(PATH_BOLD_FONT),
			DEFAULT_BOLD_FONT_SIZE);
	public static final Font LIGHT_FONT = Font.loadFont(Main.class.getResourceAsStream(PATH_LIGHT_FONT),
			DEFAULT_LIGHT_FONT_SIZE);

	// Private attributes
	private BorderPane _rootLayout;
	private Scene _scene;
	private MainController _mainController;
	private DisplayController _displayController;
	private Logic _logic;
	private static Stage _primaryStage;
	private StateFeedback _currState;

	@Override
	public void start(Stage primaryStage) {
		initLogger();
		initLogicComponent();
		initRootLayout();
		initDisplay();
		initStage(primaryStage);
		initFeatures();
	}

	private void initLogger() {
		UrgendaLogger.getInstance().getLogger().log(Level.INFO, "Successful initialisation of logger");
	}

	private void initLogicComponent() {
		_logic = Logic.getInstance();
		UrgendaLogger.getInstance().getLogger().log(Level.INFO, "Successful initialisation of logic");
	}

	private void initRootLayout() {
		try {
			FXMLLoader loader = new FXMLLoader();
			loader.setLocation(getClass().getResource(PATH_GUI_FXML));
			_rootLayout = loader.load();
			_mainController = loader.getController();
			_mainController.setMain(this);
		} catch (IOException e) {
			UrgendaLogger.getInstance().getLogger().log(Level.SEVERE,
					"Initialisation of root layout failed!");
			e.printStackTrace();
		}
		UrgendaLogger.getInstance().getLogger().log(Level.INFO, "Successful initialisation of root layout");
	}

	private void initDisplay() {
		_displayController = _mainController.getDisplayController();
		_displayController.setNoviceSettings(_logic.getNoviceSettings());
		_currState = retrieveStartupState();
		TaskList updatedTasks = _currState.getAllTasks();
		String displayHeader = createDisplayHeader(_currState);
		ArrayList<Integer> detailedIndexes = _currState.getDetailedIndexes();
		int displayPos = _currState.getDisplayPosition();
		boolean isShowNoviceHeaders = _logic.getNoviceSettings();
		_displayController.initDisplay(updatedTasks, displayHeader, detailedIndexes, displayPos, isShowNoviceHeaders);
		UrgendaLogger.getInstance().getLogger().log(Level.INFO, "Successful initialisation of display view");
	}

	private void initStage(Stage primaryStage) {
		_scene = new Scene(_rootLayout);
		_primaryStage = primaryStage;
		_primaryStage.initStyle(StageStyle.DECORATED);
		_primaryStage.setTitle(APP_NAME);
		_primaryStage.setResizable(false);
		_primaryStage.setScene(_scene);
		_primaryStage.sizeToScene();
		_primaryStage.show();
		UrgendaLogger.getInstance().getLogger().log(Level.INFO,
				"Successful initialisation of Urgenda window");
	}

	private void initFeatures() {
		// setup menu items and listeners for MainController
		_mainController.setup(_currState.getOverdueCount());
		// setup window focused listener
		_primaryStage.focusedProperty().addListener(new ChangeListener<Boolean>() {
			@Override
			public void changed(ObservableValue<? extends Boolean> observable, Boolean oldValue,
					Boolean newValue) {
				if (newValue) {
					_mainController.showSuggestionsPopup();
				} else {
					if (_mainController.getSuggestionsPopup() != null) {
						_mainController.hideSuggestionsPopup();
					}
				}

			}
		});
	}

	private StateFeedback retrieveStartupState() {
		StateFeedback state = _logic.retrieveStartupState();
		_mainController.displayFeedback(state.getFeedback());
		return state;
	}

	/**
	 * Calls the Logic component to handle user command line input.
	 * 
	 * @param commandLine
	 *            registered input command line by user
	 * @param isDemo
	 *            boolean indicating whether UI is currently in demo mode or not
	 * @return feedback to be displayed to the user
	 */
	protected String handleCommandLine(String commandLine) {
		_currState = _logic.executeCommand(commandLine, _displayController.getSelectedTaskIndex());
		TaskList updatedTasks = _currState.getAllTasks();
		String displayHeader = createDisplayHeader(_currState);
		ArrayList<Integer> detailedIndexes = _currState.getDetailedIndexes();
		int displayPos = _currState.getDisplayPosition();
		boolean isShowFreeTime = false;
		switch (_currState.getState()) {
		case HIDE:
			_primaryStage.setIconified(true);
			break;
		case SHOW_HELP:
			_mainController.showHelp();
			break;
		case EXIT:
			quit();
			break;
		case DEMO:
			return activateDemoScreen();
		case FIND_FREE:
			isShowFreeTime = true;
			// fall-through
		case ALL_TASKS:
			_mainController.setDemo(false);
			// fall-through
		default:
			_displayController.setDisplay(updatedTasks, displayHeader, detailedIndexes, displayPos, isShowFreeTime, false);
			break;
		}
		_mainController.updateOverdueCount(_currState.getOverdueCount());
		return _currState.getFeedback();
	}

	private String createDisplayHeader(StateFeedback state) {
		String display = "";
		switch (state.getState()) {
		case MULTIPLE_MATCHES:
			display = HEADER_MULTIPLE_MATCHES;
			break;
		case SHOW_SEARCH:
			display = HEADER_SEARCH_RESULTS;
			break;
		case ALL_TASK_AND_COMPLETED:
			display = HEADER_ALL_WITH_COMPLETED_TASKS;
			break;
		case SHOW_HELP:
			display = null; // previous display header not changed
			break;
		case FIND_FREE:
			display = HEADER_FREE_TIME;
			break;
		case ARCHIVE:
			display = HEADER_ARCHIVE_TASKS;
			break;
		case ALL_TASKS:
			// fall-through
		default:
			display = HEADER_ALL_TASKS;
			break;
		}
		return display;
	}

	private String activateDemoScreen() {
		_mainController.setDemo(true);
		StateFeedback state = new DemoStateFeedback();
		_displayController.setSelectedTaskByCall(0, true);
		_displayController.setDisplay(state.getAllTasks(), createDisplayHeader(state),
				state.getDetailedIndexes(), state.getDisplayPosition(), false, true);
		_mainController.updateOverdueCount(state.getOverdueCount());
		return state.getFeedback();
	}
	
	/**
	 * Toggles settings for novice or advanced view.
	 * 
	 * @param isNovice boolean for novice or advanced view
	 */
	public void changeNoviceSettings(boolean isNovice) {
		_logic.setNoviceSettings(isNovice);
	}
	
	/**
	 * Retrieves text for help menu.
	 * 
	 * @return array containing help text
	 */
	public ArrayList<String> getHelpText() {
		return _logic.displayHelp();
	}

	/**
	 * Retrieves text to be displayed at each step during demo mode.
	 * 
	 * @return array of text strings for each step during demo mode
	 */
	public ArrayList<String> getDemoText() {
		return _logic.getDemoText();
	}

	/**
	 * Retrieves the reference for which task to be selected at each step during
	 * demo mode.
	 * 
	 * @return array of indexes of tasks to be selected at each step during demo
	 *         mode
	 */
	public ArrayList<Integer> getDemoSelectionIndexes() {
		return _logic.getDemoSelectionIndexes();
	}

	/**
	 * Retrieves data file at current save directory.
	 * 
	 * @return File object referenced to the current directory of stored data
	 */
	public File getSaveDirectory() {
		File file = new File(_logic.getCurrentSaveDirectory());
		return file;
	}

	/**
	 * Retrieves input format suggestions according to current input command
	 * text by user.
	 * 
	 * @param text
	 *            current input command text by user
	 * @return SuggestFeedback object containing input format suggestions for
	 *         current input
	 */
	public SuggestFeedback retrieveSuggestions(String text) {
		return _logic.getSuggestions(text);
	}

	/**
	 * Calculates bound coordinates of Urgenda window with respect to the screen
	 * at time of method call.
	 * 
	 * @return bounds of window
	 */
	public Bounds computeAllScreenBounds() {
		double minX = Double.POSITIVE_INFINITY;
		double minY = Double.POSITIVE_INFINITY;
		double maxX = Double.NEGATIVE_INFINITY;
		double maxY = Double.NEGATIVE_INFINITY;
		for (Screen screen : Screen.getScreens()) {
			Rectangle2D screenBounds = screen.getBounds();
			if (screenBounds.getMinX() < minX) {
				minX = screenBounds.getMinX();
			}
			if (screenBounds.getMinY() < minY) {
				minY = screenBounds.getMinY();
			}
			if (screenBounds.getMaxX() > maxX) {
				maxX = screenBounds.getMaxX();
			}
			if (screenBounds.getMaxY() > maxY) {
				maxY = screenBounds.getMaxY();
			}
		}
		return new BoundingBox(minX, minY, maxX - minX, maxY - minY);
	}

	private void quit() {
		if (_mainController.getHelpController() != null) {
			_mainController.getHelpController().closeHelpWindow();
		}
		System.exit(0);
	}

	/**
	 * Returns MainController instance.
	 * 
	 * @return MainController object instance
	 */
	public MainController getController() {
		return _mainController;
	}

	/**
	 * Returns primaryStage instance.
	 * 
	 * @return primaryStage instance
	 */
	public Stage getPrimaryStage() {
		return _primaryStage;
	}

	/**
	 * Launches Urgenda.
	 * 
	 * @param args
	 *            directory of Urgenda.
	 */
	public static void main(String[] args) {
		launch(args);
	}
}
```
###### urgenda\gui\MainController.java
``` java
package urgenda.gui;

import java.io.File;
import java.io.IOException;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.logging.Level;

import org.ocpsoft.prettytime.shade.edu.emory.mathcs.backport.java.util.Arrays;

import javafx.application.Platform;
import javafx.beans.property.BooleanProperty;
import javafx.beans.property.SimpleBooleanProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.geometry.Bounds;
import javafx.scene.Parent;
import javafx.scene.control.Label;
import javafx.scene.control.MenuItem;
import javafx.scene.control.SeparatorMenuItem;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.text.Text;
import javafx.scene.text.TextFlow;
import javafx.stage.FileChooser;
import javafx.stage.Popup;
import urgenda.util.UrgendaLogger;
import javafx.stage.Stage;
/**
 * UI component that handles all user interaction regarding input and feedback.
 * 
 * @author KangSoon
 */
public class MainController {

	// Constants
	private static final int WINDOWS_TASKBAR_HEIGHT = 30;
	private static final double DEMO_WINDOW_WIDTH = 800;
	private static final double ALLOWANCE_WINDOW_WIDTH = 5;
	private static final String TITLE_SAVE_DIRECTORY = "Set Save Directory";
	private static final String MESSAGE_NOVICE_USER_VIEW = "Activated novice user view";
	private static final String MESSAGE_ADVANCED_USER_VIEW = "Activated advanced user view";
	private static final String MENUTEXT_ADVANCED_VIEW = "Activate Advanced View";
	private static final String MENUTEXT_NOVICE_VIEW = "Activate Novice View";
	
	// File paths
	private static final String PATH_TYPESUGGESTIONS_FXML = "fxml/InputSuggestionsView.fxml";
	private static final String PATH_DEMOTEXT_FXML = "fxml/DemoTextView.fxml";
	
	// Command keywords
	private static final String KEYWORD_UNDO = "undo";
	private static final String KEYWORD_REDO = "redo";
	public static final String KEYWORD_SHOW_ALL = "home";
	private static final String KEYWORD_CHANGE_SAVE_PATH = "saveto ";
	private static final String KEYWORD_SHOWMORE = "showmore";
	private static final String MESSAGE_WARNING = "Warning: ";
	private static final String DELIMITER_WARNING = "Warning: ";
	private static final String MESSAGE_ERROR = "ERROR: ";
	private static final String DELIMITER_ERROR = "Error: ";
	
	// Colors for styling feedback text
	private static final Color COLOR_ERROR = Color.web("#FA6969");
	private static final Color COLOR_WARNING = Color.web("#FFFF00");

	// Elements loaded using FXML
	@FXML
	private BorderPane backgroundPane;
	@FXML
	private TextField inputBar;
	@FXML
	private TextFlow feedbackArea;
	@FXML
	private Parent displayArea;
	@FXML
	private SeparatorMenuItem multipleSlotSeparator;
	@FXML
	private MenuItem menuPrevMultipleSlot;
	@FXML
	private MenuItem menuNextMultipleSlot;
	@FXML
	private MenuItem menuToggleAdvancedView;
	@FXML
	private Label overdueIndicatorLabel;
	@FXML
	private Circle overdueIndicatorCircle;
	@FXML
	private DisplayController displayAreaController;
	
	// Private attributes
	private Main _main;
	private Deque<String> _prevCommandLines = new ArrayDeque<String>();
	private Deque<String> _nextCommandLines = new ArrayDeque<String>();
	private BooleanProperty _isDemo = new SimpleBooleanProperty(false);
	private Popup _popupInputSuggestions;
	private InputSuggestionsPopupController _popupController;
	private BorderPane _demoTextPane;
	private DemoController _demoController;
	private HelpController _helpController;
	
	/**
	 * Creates a MainController object.
	 */
	public MainController() {
		//default constructor
	}
	
	private void initTypeSuggestions() {	
		_popupInputSuggestions = new Popup();
		_popupController = new InputSuggestionsPopupController();
		FXMLLoader loader = new FXMLLoader(getClass().getResource(PATH_TYPESUGGESTIONS_FXML));
		loader.setController(_popupController);
		try {
			_popupInputSuggestions.getContent().add((Parent)loader.load());
			UrgendaLogger.getInstance().getLogger().log(Level.INFO, "setup of type suggestions popup successful");
		} catch (IOException e) {
			UrgendaLogger.getInstance().getLogger().log(Level.SEVERE, "Error setting up type suggestions popup");
			e.printStackTrace();
		}
		_popupInputSuggestions.setX(_main.getPrimaryStage().getX());
		_popupInputSuggestions.setY(_main.getPrimaryStage().getY() + _main.getPrimaryStage().getHeight());
		if(inputBar.getText().isEmpty()) {
			_popupInputSuggestions.hide();
		} else {
			_popupInputSuggestions.show(_main.getPrimaryStage());
		}
	}
	
	private void initDemoPane() {	
		_demoController = new DemoController(this, _main.getDemoText(), _main.getDemoSelectionIndexes());
		FXMLLoader loader = new FXMLLoader(getClass().getResource(PATH_DEMOTEXT_FXML));
		loader.setController(_demoController);
		try {
			_demoTextPane = loader.load();
			UrgendaLogger.getInstance().getLogger().log(Level.INFO, "setup of demo text pane successful");
		} catch (IOException e) {
			UrgendaLogger.getInstance().getLogger().log(Level.SEVERE, "Error setting up demo text pane");
			e.printStackTrace();
		}
		backgroundPane.setRight(_demoTextPane);
		_demoController.init();
	}	
	
	/**
	 * Setup overdue indicators, listeners and menu options at initialization.
	 * 
	 * @param overdueCount total number of overdue tasks
	 */
	public void setup(int overdueCount) {
		// setup overdue indicator
		updateOverdueCount(overdueCount);
		// setup menu for novice and advanced option
		boolean isNovice = _main.getController().getDisplayController().getNoviceSettings();
		if(isNovice) {
			menuToggleAdvancedView.setText(MENUTEXT_ADVANCED_VIEW);
		} else {
			menuToggleAdvancedView.setText(MENUTEXT_NOVICE_VIEW);
		}	
		// listeners for demo view
		_isDemo.addListener(new ChangeListener<Boolean>() {
			@Override
			public void changed(ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean newValue) {
				if (!newValue.equals(oldValue)) { //check change
					if (newValue.equals(true)) {
						initDemoPane();
						_popupInputSuggestions.hide();
						_main.getPrimaryStage().setWidth(DEMO_WINDOW_WIDTH + ALLOWANCE_WINDOW_WIDTH);
					} else {
						_demoController = null;
						backgroundPane.getChildren().remove(_demoTextPane);
						_main.getPrimaryStage().setWidth(backgroundPane.getPrefWidth() + ALLOWANCE_WINDOW_WIDTH);
						displayFeedback(_main.handleCommandLine(KEYWORD_SHOW_ALL));	//return to all tasks view
					}
				}
			}
		});
		
		// listeners for suggestions popup
		inputBar.textProperty().addListener(new ChangeListener<String>() {
			@Override
			public void changed(ObservableValue<? extends String> observable, String oldValue, String newValue) {
				if (!_isDemo.get()) {
					showSuggestionsPopup();
				} else {
					_popupInputSuggestions.hide();
				}
			}		
		});
		ChangeListener<Number> windowPosChangeListener = new ChangeListener<Number>() {
			@Override
			public void changed(ObservableValue<? extends Number> observable, Number oldValue, Number newValue) {
				if(getSuggestionsPopup() != null) {
					_popupInputSuggestions.hide();					
				}
			}		
		};
		_main.getPrimaryStage().xProperty().addListener(windowPosChangeListener);	
		_main.getPrimaryStage().yProperty().addListener(windowPosChangeListener);
	}
	
	/**
	 * Displays popup for input suggestions.
	 */
	public void showSuggestionsPopup() {
		if(_popupInputSuggestions == null) {
			initTypeSuggestions();
		}
		_popupController.updateSuggestions(_main.retrieveSuggestions(inputBar.getText()));
		if(!windowOutOfBounds()) {
			if(inputBar.getText().isEmpty()) {
				_popupInputSuggestions.hide();
			} else {
				_popupInputSuggestions.show(_main.getPrimaryStage());
			}
			_popupInputSuggestions.setX(_main.getPrimaryStage().getX());
			_popupInputSuggestions.setY(_main.getPrimaryStage().getY() + _main.getPrimaryStage().getHeight());
		}
	}
	
	/**
	 * Hides popup for input suggestions.
	 */
	public void hideSuggestionsPopup() {
		_popupInputSuggestions.hide();
	}
	
	private boolean windowOutOfBounds() {
		Bounds bounds = _main.computeAllScreenBounds();
		double x = _main.getPrimaryStage().getX();
		double y = _main.getPrimaryStage().getY();
		double width = _main.getPrimaryStage().getWidth();
		double height = _main.getPrimaryStage().getHeight() + _popupInputSuggestions.getHeight() + WINDOWS_TASKBAR_HEIGHT;
		
		if (x < bounds.getMinX()) {
			return true;
		}
		if (x + width > bounds.getMaxX()) {
			return true;
		}
		if (y + height > bounds.getMaxY()) {
			return true;
		}
		return false;
	}

	@FXML
	private void sceneListener(KeyEvent event) {
		KeyCode code = event.getCode();
		if (code == KeyCode.TAB) {
			if (!inputBar.isFocused()) {
				inputBar.requestFocus();
			}
			if(_isDemo.get()) {
				if(event.isShiftDown()) {
					_demoController.prevPart();
				} else {
					_demoController.nextPart();
				}
			} 
		}
	}

	@FXML
	private void commandLineListener(KeyEvent event) {
		KeyCode code = event.getCode();
		if(code == KeyCode.TAB) {
			sceneListener(event); //pass control to scene
		} else if (code == KeyCode.ENTER) {
			if (!inputBar.getText().trim().equals("") && !inputBar.getText().equals("")) {
				while (!_nextCommandLines.isEmpty()) {
					_prevCommandLines.addFirst(_nextCommandLines.getFirst());
					_nextCommandLines.removeFirst();
				}
				_prevCommandLines.addFirst(inputBar.getText());
				String feedback = _main.handleCommandLine(inputBar.getText());
				if (feedback != null) { // null does not change feedback text
					displayFeedback(feedback);
				}
				inputBar.clear();
			} else { // inputbar has whitespaces
				inputBar.clear();
			}
		} else if (code == KeyCode.UP && !event.isControlDown()) {
			if (!_prevCommandLines.isEmpty()) {
				if (inputBar.getText().equals(_prevCommandLines.peekFirst())
						&& _prevCommandLines.size() > 1) {
					_nextCommandLines.addFirst(_prevCommandLines.getFirst());
					_prevCommandLines.removeFirst();
				}
				inputBar.setText(_prevCommandLines.getFirst());
			}
		} else if (code == KeyCode.DOWN && !event.isControlDown()) {
			if (!_nextCommandLines.isEmpty()) {
				_prevCommandLines.addFirst(_nextCommandLines.getFirst());
				_nextCommandLines.removeFirst();
				inputBar.setText(_prevCommandLines.getFirst());
			} else {
				inputBar.clear();
			}
		}
	}
	
	@FXML
	private void savePathChangeListener(ActionEvent e) {
		String feedback;
		FileChooser fileChooser = new FileChooser();
		fileChooser.setTitle(TITLE_SAVE_DIRECTORY);
		FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter(".txt files (*.txt)", "*.txt");
		fileChooser.getExtensionFilters().add(extFilter);
		fileChooser.setInitialDirectory(_main.getSaveDirectory());
		File selectedFileDirectory = fileChooser.showSaveDialog(new Stage());
		if (selectedFileDirectory != null) {
			feedback = _main.handleCommandLine(KEYWORD_CHANGE_SAVE_PATH + selectedFileDirectory.getAbsolutePath());
			displayFeedback(feedback);
			inputBar.clear();
		}
	}
	
	@FXML
	private void minimiseWindowListener(ActionEvent e) {
		_main.getPrimaryStage().setIconified(true);
	}
	
	@FXML
	private void taskToggleDownListener(ActionEvent e) {			
		displayAreaController.executeTraverse(DisplayController.Direction.DOWN);
	}

	@FXML
	private void taskToggleUpListener(ActionEvent e) {
		displayAreaController.executeTraverse(DisplayController.Direction.UP);
	}

	@FXML
	private void multipleSlotToggleLeftListener(ActionEvent e) {
		displayAreaController.executeTraverse(DisplayController.Direction.LEFT);
	}

	@FXML
	private void multipleSlotToggleRightListener(ActionEvent e) {
		displayAreaController.executeTraverse(DisplayController.Direction.RIGHT);
	}
	
	@FXML
	private void showmoreListener (ActionEvent e) {
		_main.handleCommandLine(KEYWORD_SHOWMORE);
	}

	@FXML
	private void showAllTasks(ActionEvent e) {
		String feedback = _main.handleCommandLine(KEYWORD_SHOW_ALL);
		displayFeedback(feedback);
		inputBar.clear();
	}

	@FXML
	private void handleUndo(ActionEvent e) {
		String feedback = _main.handleCommandLine(KEYWORD_UNDO);
		displayFeedback(feedback);
		inputBar.clear();
	}

	@FXML
	private void handleRedo(ActionEvent e) {
		String feedback = _main.handleCommandLine(KEYWORD_REDO);
		displayFeedback(feedback);
		inputBar.clear();
	}
	
	@FXML
	private void toggleAdvancedViewListener(ActionEvent e) {
		boolean isNovice = _main.getController().getDisplayController().getNoviceSettings();
		if(isNovice) {
			menuToggleAdvancedView.setText(MENUTEXT_NOVICE_VIEW);
		} else {
			menuToggleAdvancedView.setText(MENUTEXT_ADVANCED_VIEW);
		}
		_main.getController().getDisplayController().setNoviceSettings(!isNovice);
		_main.changeNoviceSettings(!isNovice);
		_main.handleCommandLine(KEYWORD_SHOW_ALL);
		if(isNovice) {
			displayFeedback(MESSAGE_ADVANCED_USER_VIEW);
		} else {
			displayFeedback(MESSAGE_NOVICE_USER_VIEW);
		}
		inputBar.clear();
	}

	@FXML
	private void handleHelp(ActionEvent event) {
		showHelp();
	}
	
	/**
	 * Sets up and displays help window.
	 */
	public void showHelp() {
		if (_helpController == null) {
			_helpController = new HelpController();
			try {
				_helpController.setupHelpStage(_main.getHelpText());
			} catch (IOException e) {
				e.printStackTrace();
			}
		} else {
			_helpController.showHelpStage();
		}
	}
	
	@FXML
	private void exit(ActionEvent e) {
		Platform.exit();
		System.exit(0);
	}
	
	/**
	 * Toggles showing of multiple slot options in menu
	 * @param show boolean to show multiple slot options or not
	 */
	public void toggleMultipleSlotMenuOption(boolean show) {
		multipleSlotSeparator.setVisible(show);
		menuPrevMultipleSlot.setVisible(show);
		menuNextMultipleSlot.setVisible(show);
	}
	/**
	 * Displays feedback from user interaction and styles any warnings or errors.
	 * @param feedback feedback text
	 */
	public void displayFeedback(String feedback) {
		Text feedbackText = null;
		ArrayList<Text> warningTexts = new ArrayList<Text>();
		ArrayList<Text> errorTexts = new ArrayList<Text>();
		//TODO refactor
		if (feedback.contains(DELIMITER_WARNING)) {
			String delim = DELIMITER_WARNING;
			@SuppressWarnings("unchecked")
			ArrayList<String> delimitedFeedback  = new ArrayList<String>(Arrays.asList(feedback.split(delim)));
			feedbackText = new Text(delimitedFeedback.get(0));
			for (int i = 1; i < delimitedFeedback.size(); i++) {
				Text warningText = new Text(MESSAGE_WARNING + delimitedFeedback.get(i));
				warningText.setFill(COLOR_WARNING);
				warningTexts.add(warningText);
			}
		} else if (feedback.contains("Error:")) {
			String delim = DELIMITER_ERROR;
			@SuppressWarnings("unchecked")
			ArrayList<String> delimitedFeedback  = new ArrayList<String>(Arrays.asList(feedback.split(delim)));
			feedbackText = new Text(delimitedFeedback.get(0));
			for (int i = 1; i < delimitedFeedback.size(); i++) {
				Text errorText = new Text(MESSAGE_ERROR + delimitedFeedback.get(i));
				errorText.setFill(COLOR_ERROR);
				errorTexts.add(errorText);
			}
		} else {
			feedbackText = new Text(feedback);
			
		}
		feedbackText.setFill(Color.WHITE);
		feedbackArea.getChildren().clear();
		feedbackArea.getChildren().add(feedbackText);
		if (warningTexts.size() > 0) {
			for(Text text: warningTexts) {
				feedbackArea.getChildren().add(text);
			}
		}
		if (errorTexts.size() > 0) {
			for(Text text: errorTexts) {
				feedbackArea.getChildren().add(text);
			}
		}
	}
	/**
	 * Updates the number of overdue tasks shown at the icon of Urgenda
	 * 
	 * @param overdueCount current total number of overdue tasks
	 */
	public void updateOverdueCount(int overdueCount) {
		if (overdueCount <= 0) {
			overdueIndicatorCircle.setVisible(false);
			overdueIndicatorLabel.setVisible(false);
		} else {
			overdueIndicatorCircle.setVisible(true);
			overdueIndicatorLabel.setVisible(true);
			if (overdueCount <= 99) {
				overdueIndicatorLabel.setText(String.valueOf(overdueCount));
			} else {
				overdueIndicatorLabel.setText("99+");
			}
		}
	}
	
	/**
	 * Sets the reference to the Main UI object instance for this class and displayController instance.
	 * @param main Main UI object instance
	 */
	public void setMain(Main main) {
		_main = main;
		displayAreaController.setMain(_main);
	}
	
	/**
	 * Returns DisplayController instance.
	 * @return DisplayController instance.
	 */
	public DisplayController getDisplayController() {
		return displayAreaController;
	}
	
	/**
	 * Returns HelpController instance.
	 * @return HelpController instance.
	 */
	public HelpController getHelpController() {
		return _helpController;
	}
	
	/**
	 * Returns DemoController instance.
	 * @return DemoController instance.
	 */
	public DemoController getDemoController() {
		return _demoController;
	}
	
	/**
	 * Returns Popup instance for suggestions.
	 * @return Popup instance for suggestions
	 */
	public Popup getSuggestionsPopup(){
		return _popupInputSuggestions;
	}
	
	/**
	 * Sets the demo state.
	 * @param demo boolean for demo state
	 */
	public void setDemo(boolean demo) {
		_isDemo.set(demo);
	}
	
	/**
	 * Returns whether demo state is activated or not.
	 * @return boolean whether demo state is activated or not
	 */
	public boolean isDemo() {
		return _isDemo.get();
	}
}
```
###### urgenda\gui\SimpleTaskController.java
``` java
package urgenda.gui;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.logging.Level;

import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.EventHandler;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.control.Label;
import javafx.scene.image.ImageView;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.RowConstraints;
import javafx.scene.text.Text;
import urgenda.gui.DisplayController.Direction;
import urgenda.gui.DisplayController.TaskDisplayType;
import urgenda.util.DateTimePair;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * UI component, invoked when showing a simple task panel for a single task.
 * 
 * @author KangSoon
 */
public class SimpleTaskController extends GridPane {
	
	// Constants
	private static final String COUNT_DOUBLE_DIGIT = "9+";
	private static final double HEIGHT_DEFAULT_TASK = 35;
	private static final int INT_DOUBLE_DIGIT = 10;

	// Header texts
	private static final String HEADER_OVERDUE_TASK = "Overdue Tasks";
	private static final String HEADER_TODAY_TASK = "Today's Tasks";
	private static final String HEADER_OTHER_TASK = "Other Tasks";
	private static final String HEADER_ARCHIVE_TASK = "Completed Tasks";
	
	// File paths
	private static final String PATH_TASK_FREETIME_CSS = "styles/TaskFreeTime.css";
	private static final String PATH_TASK_OVERDUE_CSS = "styles/TaskOverdue.css";
	private static final String PATH_TASK_TODAY_CSS = "styles/TaskToday.css";
	private static final String PATH_TASK_TODAY_OVERTIME_CSS = "styles/TaskTodayOvertime.css";
	private static final String PATH_TASK_NORMAL_CSS = "styles/TaskNormal.css";
	private static final String PATH_TASK_ARCHIVE_CSS = "styles/TaskArchive.css";
	private static final String PATH_SIMPLETASKVIEW_FXML = "fxml/SimpleTaskView.fxml";

	
	// Elements loaded using FXML
	@FXML
	protected GridPane taskPane;
	@FXML
	protected Pane selector;
	@FXML
	protected Pane selectorPane;
	@FXML
	protected Text taskIndexText;
	@FXML
	protected ImageView importantIndicator;
	@FXML
	protected Text taskDescText;
	@FXML
	protected Text taskDateTimeText;
	@FXML
	protected BorderPane noviceHeaderPane;
	@FXML
	protected Text noviceHeaderLabel;
	@FXML
	protected Pane multipleSlotPane;
	@FXML
	protected Label multipleSlotCounter;

	//Private attributes
	private int _multipleSlotIndex;
	
	// Attributes also inherited by DetailedTaskController
	protected int _index;
	protected Task _task;
	protected TaskDisplayType _taskDisplayType;
	protected boolean _isSelected;
	protected boolean _showHeader;
	protected ArrayList<DateTimePair> _multipleSlotList;
	protected DisplayController _displayController;

	/**
	 * Creates a SimpleTaskController using the given task.
	 * @param task task to show details for
	 * @param index index of the task
	 * @param taskDisplayType the enumerated type of the task
	 * @param showHeader boolean to show headers for the task or not
	 */
	public SimpleTaskController(Task task, int index, TaskDisplayType taskDisplayType, boolean showHeader) {
		_task = task;
		_taskDisplayType = taskDisplayType;
		_index = index;
		_showHeader = showHeader;
		_multipleSlotList = new ArrayList<DateTimePair>();
		loadFXML();
		setTaskClickHandler();
		initLabels();
		if (_task.isImportant()) {
			importantIndicator.setVisible(true);
		} else {
			importantIndicator.setVisible(false);
		}
		if(!showHeader) {
			taskPane.getRowConstraints().set(0, new RowConstraints(0));
			taskPane.setPrefHeight(HEIGHT_DEFAULT_TASK);
			noviceHeaderPane.setVisible(false);
		}
		if(_task.getSlot() != null) {
			multipleSlotPane.setVisible(true);
			multipleSlotCounter.setText(countMultipleSlots());
		} else {
			multipleSlotPane.setVisible(false);
			multipleSlotCounter.setVisible(false);
		}
		setSelected(false);
		this.heightProperty().addListener(new ChangeListener<Number>(){
			@Override
			public void changed(ObservableValue<? extends Number> observable, Number oldValue, Number newValue) {
				if(index == _displayController.getDisplayedTasksCount() - 1) {	//invoke when height of all tasks panels are set
					_displayController.setDisplayScrollHeight();
					_displayController.setSetup(false);
				}
			}		
		});
	}

	private String countMultipleSlots() {
		int count = _task.getSlot().getSlots().size() + 1;
		if (count < INT_DOUBLE_DIGIT) {
			return String.valueOf(count);
		} else {
			return COUNT_DOUBLE_DIGIT;
		}
	}
	
	//initialize text labels
	private void initLabels() {
		taskIndexText.setText(String.valueOf(_index + 1));
		taskDescText.setText(_task.getDesc());
		if (_task.getSlot() != null) { //task has multiple time slots
			_multipleSlotIndex = 0;
			_multipleSlotList.add(new DateTimePair(_task.getStartTime(), _task.getEndTime()));
			_multipleSlotList.addAll(_task.getSlot().getSlots());
			taskDateTimeText.setText(formatMultipleSlotDateTime());
		} else {
			_multipleSlotIndex = -1; //task has no multiple slots
			taskDateTimeText.setText(formatDateTime(_task.getStartTime(), _task.getEndTime()));
		}
		switch (_taskDisplayType) {
		case FREE_TIME:
			this.getStylesheets().addAll(getClass().getResource(PATH_TASK_FREETIME_CSS).toExternalForm());
			break;
		case OVERDUE:
			this.getStylesheets().addAll(getClass().getResource(PATH_TASK_OVERDUE_CSS).toExternalForm());
			noviceHeaderLabel.setText(HEADER_OVERDUE_TASK);
			break;
		case TODAY:
			if(_task.isCompleted()) {
				this.getStylesheets().addAll(getClass().getResource(PATH_TASK_TODAY_OVERTIME_CSS).toExternalForm());
			} else {
				this.getStylesheets().addAll(getClass().getResource(PATH_TASK_TODAY_CSS).toExternalForm());
			}	
			noviceHeaderLabel.setText(HEADER_TODAY_TASK);
			break;
		case NORMAL:
			this.getStylesheets().addAll(getClass().getResource(PATH_TASK_NORMAL_CSS).toExternalForm());
			noviceHeaderLabel.setText(HEADER_OTHER_TASK);
			break;
		case ARCHIVE:
			this.getStylesheets().addAll(getClass().getResource(PATH_TASK_ARCHIVE_CSS).toExternalForm());
			noviceHeaderLabel.setText(HEADER_ARCHIVE_TASK);
			break;
		}
	}

	//set event handler for mouse clicks on view to set as selected
	private void setTaskClickHandler() {
		this.setOnMouseClicked(new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent e) {
				if(!_displayController.getMain().getController().isDemo()) {
					_displayController.setSelectedTaskByCall(_index, false);
				}
				if(e.getClickCount() == 2) { //double click
					_displayController.toggleSelectedDetailsOnClick();
				}
			}
		});
	}
	
	/**
	 * Formats dates and times of task according to number of instances of dates and times.
	 * @param dateTime1 first date-time instance
	 * @param dateTime2 second date-time instance
	 * @return formatted text for dates and times
	 */
	protected String formatDateTime(LocalDateTime dateTime1, LocalDateTime dateTime2) {
		String dateTimeFormatter = "";
		if(dateTime2 != null) {
			if(dateTime1 == null) {	//format for deadline
				dateTimeFormatter += "by ";
				dateTimeFormatter += formatDate(dateTime2) + " ";
				dateTimeFormatter += formatTime(dateTime2);
			} else { //format for event
				DateTimePair timeDiff = new DateTimePair(dateTime1, dateTime2);
					dateTimeFormatter += formatDate(dateTime1) + " ";
				dateTimeFormatter += formatTime(dateTime1) + " ";
				dateTimeFormatter += "to ";
				if (!timeDiff.isSameDay()) {
					dateTimeFormatter += formatDate(dateTime2) + " ";
				}
				dateTimeFormatter += formatTime(dateTime2);				
			}
		}
		return dateTimeFormatter;
	}
	
	private String formatDate(LocalDateTime dateTime) {
		DateTimePair timeLeft = new DateTimePair(LocalDateTime.now(), dateTime);
		String formattedDate = "";
		if(timeLeft.getRoundedDays() == 0) {
			formattedDate += "Today";
		} else if(timeLeft.getRoundedDays() == 1) {
			if(timeLeft.firstIsBefore()) {
				formattedDate += "Tomorrow";
			} else {
				formattedDate += "Yesterday";
			}
		} else {
			if (dateTime.getYear() != LocalDateTime.now().getYear()) {
				formattedDate += timeLeft.getDateTime2().format(DateTimeFormatter.ofPattern("dd MMM yyyy"));
			} else {				
				formattedDate += timeLeft.getDateTime2().format(DateTimeFormatter.ofPattern("dd MMM"));
			}
		}
		return formattedDate;
	}
	
	private String formatTime(LocalDateTime dateTime) {
		return dateTime.format(DateTimeFormatter.ofPattern("h:mma"));
	}
	
	/**
	 * Loads FXML resources to setup view in display.
	 */
	protected void loadFXML() {
		FXMLLoader loader = new FXMLLoader(getClass().getResource(PATH_SIMPLETASKVIEW_FXML));
		loader.setController(this);
		loader.setRoot(this);
		try {
			loader.load();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Toggles this controller as selected.
	 * @param isSelected boolean whether this controller is selected or not
	 */
	public void setSelected(boolean isSelected) {
		_isSelected = isSelected;
		selector.setVisible(_isSelected);
		selectorPane.setVisible(_isSelected);
	}
	
	/**
	 * Sets the reference for DisplayController.
	 * @param displayController reference for DisplayController
	 */
	public void setDisplayController(DisplayController displayController) {
		_displayController = displayController;
	}

	/**
	 * Traverse multiple time slots for this controller if task has multiple slots
	 * @param direction direction to traverse to
	 */
	public void traverseMultipleSlot(Direction direction) {
		if (!_multipleSlotList.isEmpty()) {
			switch(direction) {
			case LEFT:
				if (_multipleSlotIndex > 0) {
					_multipleSlotIndex--;
					taskDateTimeText.setText(formatMultipleSlotDateTime());
				}
				break;
			case RIGHT:
				if (_multipleSlotIndex < _multipleSlotList.size() - 1) {
					_multipleSlotIndex++;
					taskDateTimeText.setText(formatMultipleSlotDateTime());
				}
				break;
			default:
				UrgendaLogger.getInstance().getLogger().log(Level.SEVERE, "Issue with call of multipleslot toggle");
				break;
			}
		}
	}

	private String formatMultipleSlotDateTime() {
		return formatDateTime(_multipleSlotList.get(_multipleSlotIndex).getEarlierDateTime(), _multipleSlotList.get(_multipleSlotIndex).getLaterDateTime());
	}
	
	/**
	 * Returns whether task in this controller has multiple time slots or not.
	 * @return boolean indicating whether task has multiple time slots
	 */
	public boolean isMultipleSlot() {
		if (_multipleSlotIndex >= 0) {
			return true;
		} else {
			return false;
		}
	}
}
```
###### urgenda\util\DateTimePair.java
``` java
package urgenda.util;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.logging.Level;

public class DateTimePair {

	private static final String LOGGER_NULL_VALUE = "DateTimePair instance contains one or more null values";
	
	private LocalDateTime _dateTime1;
	private LocalDateTime _dateTime2;
	private boolean _firstIsBefore;

	public DateTimePair(LocalDateTime dateTime1, LocalDateTime dateTime2) {
		_dateTime1 = dateTime1;
		_dateTime2 = dateTime2;
		checkRelativeDateTimes();
	}

	public LocalDateTime getDateTime1() {
		return _dateTime1;
	}

	public LocalDateTime getDateTime2() {
		return _dateTime2;
	}
	
	public LocalDateTime getEarlierDateTime() {
		if(_firstIsBefore) {
			return _dateTime1;
		} else {
			return _dateTime2;
		}
	}
	
	public LocalDateTime getLaterDateTime() {
		if(_firstIsBefore) {
			return _dateTime2;
		} else {
			return _dateTime1;
		}
	}
	
	public void addToEarlierDateTime(int number, ChronoUnit chronoUnit) {
		if (_dateTime1 != null && _dateTime2 != null) {
			if (_firstIsBefore) {
				_dateTime1 = _dateTime1.plus(number, chronoUnit);
			} else {
				_dateTime2 = _dateTime2.plus(number, chronoUnit);
			}
			checkRelativeDateTimes();
		} else {
			UrgendaLogger.getInstance().getLogger().log(Level.SEVERE, LOGGER_NULL_VALUE);
		}
	}


	public void minusFromEarlierDateTime(int number, ChronoUnit chronoUnit) {
		if (_dateTime1 != null && _dateTime2 != null) {
			if (_firstIsBefore) {
				_dateTime1 = _dateTime1.minus(number, chronoUnit);
			} else {
				_dateTime2 = _dateTime2.minus(number, chronoUnit);
			}
			checkRelativeDateTimes();
		} else {
			UrgendaLogger.getInstance().getLogger().log(Level.SEVERE, LOGGER_NULL_VALUE);
		}
	}

	public void addToLaterDateTime(int number, ChronoUnit chronoUnit) {
		if (_dateTime1 != null && _dateTime2 != null) {
			if (!_firstIsBefore) {
				_dateTime1 = _dateTime1.plus(number, chronoUnit);
			} else {
				_dateTime2 = _dateTime2.plus(number, chronoUnit);
			}
			checkRelativeDateTimes();
		} else {
			UrgendaLogger.getInstance().getLogger().log(Level.SEVERE, LOGGER_NULL_VALUE);
		}
	}

	public void minusFromLaterDateTime(int number, ChronoUnit chronoUnit) {
		if (_dateTime1 != null && _dateTime2 != null) {
			if (!_firstIsBefore) {
				_dateTime1 = _dateTime1.minus(number, chronoUnit);
			} else {
				_dateTime2 = _dateTime2.minus(number, chronoUnit);
			}
			checkRelativeDateTimes();
		} else {
			UrgendaLogger.getInstance().getLogger().log(Level.SEVERE, LOGGER_NULL_VALUE);
		}
	}
	public boolean equals(DateTimePair d) {
		if (_dateTime1 != null && _dateTime2 != null) {
			if(d.getEarlierDateTime().equals(this.getEarlierDateTime()) && d.getLaterDateTime().equals(this.getLaterDateTime())) {
				return true;
			}
		} else {
			UrgendaLogger.getInstance().getLogger().log(Level.SEVERE, LOGGER_NULL_VALUE);
		}
		return false;
	}
	
	public int getRoundedDays() {
		LocalDate d1 = getEarlierDateTime().toLocalDate();
		LocalDate d2 = getLaterDateTime().toLocalDate();
		return (int) ChronoUnit.DAYS.between(d1, d2);
	}
	
	public boolean isSameDay() {
		if(_dateTime1.getYear() == _dateTime2.getYear() && _dateTime1.getDayOfYear() == _dateTime2.getDayOfYear()) {
			return true;
		}
		return false;
	}
	
	public boolean firstIsBefore() {
		return _firstIsBefore;
	}
	
	private void checkRelativeDateTimes() {
		if(_dateTime1 != null && _dateTime2 != null) {
			if(_dateTime1.isBefore(_dateTime2)) {
				_firstIsBefore = true;
			} else if(_dateTime1.isAfter(_dateTime2)) {
				_firstIsBefore = false;
			}
		} else {
			UrgendaLogger.getInstance().getLogger().log(Level.SEVERE, LOGGER_NULL_VALUE);
		}
	}
}
```
###### urgenda\util\DemoStateFeedback.java
``` java
package urgenda.util;

import java.time.LocalDateTime;
import java.util.ArrayList;

/**
 * Utility class to create a StateFeedback object used during demo.
 * 
 * @author KangSoon
 */
public class DemoStateFeedback extends StateFeedback {
	
	/**
	 * Creates a DemoStateFeedback instance.
	 */
	public DemoStateFeedback() {
		super();
		Task taskOverdue = new Task("Complete tutorial", null, null,
				LocalDateTime.now().minusDays(1).withHour(23).withMinute(59), false);
		Task taskTodayImportant = new Task("Breakfast with mum and dad", null,
				LocalDateTime.now().withHour(7).withMinute(0), LocalDateTime.now().withHour(8).withMinute(0),
				 false);
		taskTodayImportant.setIsCompleted(true);
		Task taskToday1 = new Task("NUS Overseas Colleges Workshop", null,
				LocalDateTime.now().minusDays(1).withHour(10).withMinute(0),
				LocalDateTime.now().plusDays(1).withHour(22).withMinute(0), false);
		Task taskImportant = new Task("Internship interview", null,
				LocalDateTime.now().plusDays(6).withHour(10).withMinute(0),
				LocalDateTime.now().plusDays(6).withHour(11).withMinute(0), true);
		taskImportant.setSlot(new MultipleSlot());
		taskImportant.getSlot().addTimeSlot(LocalDateTime.now().plusDays(6).withHour(11).withMinute(0),
				LocalDateTime.now().plusDays(6).withHour(12).withMinute(0));
		taskImportant.getSlot().addTimeSlot(LocalDateTime.now().plusDays(6).withHour(12).withMinute(0),
				LocalDateTime.now().plusDays(6).withHour(13).withMinute(0));
		Task taskOverrun = new Task("Get groceries", "Supermarket",
				LocalDateTime.now().plusDays(2).withHour(17).withMinute(0),
				LocalDateTime.now().plusDays(2).withHour(18).withMinute(0), false);
		taskOverrun.setSlot(new MultipleSlot());
		taskOverrun.getSlot().addTimeSlot(LocalDateTime.now().plusDays(3).withHour(17).withMinute(0),
				LocalDateTime.now().plusDays(3).withHour(18).withMinute(0));
		Task taskDetailedLong = new Task(
				"Success is the sum of small efforts, repeated day in and day out. - Robert Collier", null, null, null,
				 false);
		Task taskCompleted = new Task("Dental Appointment", "Hougang Polyclinic",
				LocalDateTime.now().minusDays(8).withHour(10).withMinute(30),
				LocalDateTime.now().minusDays(8).withHour(12).withMinute(00), false);

		ArrayList<Task> tasks = new ArrayList<Task>();
		ArrayList<Task> archives = new ArrayList<Task>();
		tasks.add(taskOverdue);
		tasks.add(taskTodayImportant);
		tasks.add(taskToday1);
		tasks.add(taskImportant);
		tasks.add(taskOverrun);
		tasks.add(taskDetailedLong);
		archives.add(taskCompleted);
		this.setAllTasks(new TaskList(tasks, archives, 1, 2, 3, 1));
		this.setFeedback("Welcome to Urgenda's demo view!\n Type \"home\" to exit.");
		this.addDetailedTaskIdx(4);
		this.addDetailedTaskIdx(6);
		this.setOverdueCount(1);
		this.setState(StateFeedback.State.ALL_TASKS);
	}
}
```
###### urgenda\util\StateFeedback.java
``` java
package urgenda.util;

import java.util.ArrayList;
import java.util.Collections;

/**
 * Utility used when returning from Logic component to UI component to pass the state to be displayed, all 
 * tasks to display, the task to set as selected, and the number of overdue tasks.
 * 
 * @author KangSoon
 *
 */
public class StateFeedback {

	// Enumerations
	public enum State {
		ALL_TASKS, MULTIPLE_MATCHES, SHOW_SEARCH, ALL_TASK_AND_COMPLETED, 
		DISPLAY, ERROR, SHOW_HELP, EXIT, ARCHIVE, FIND_FREE, HIDE, DEMO
	}
	
	// Private attributes
	private State _state;
	private TaskList _allTasks;
	private String _feedback;
	private int _displayPosition = 0;
	private int _overdueCount = 0;
	private ArrayList<Integer> _showMoreIndexes; // index of tasks to show details for

	/**
	 * Creates a StateFeedback with default private attribute values.
	 */
	public StateFeedback() {
		_showMoreIndexes = new ArrayList<Integer>();
	}

	/**
	 * Creates a StateFeeback with array of tasks, and count for overdue, today, and
	 * remaining tasks.
	 * 
	 * @param tasks
	 *            array of tasks
	 * @param overdue
	 *            number of overdue tasks
	 * @param today
	 *            number of today tasks
	 * @param remaining
	 *            number of remaining tasks
	 */
	public StateFeedback(ArrayList<Task> tasks, int overdue, int today, int remaining) {
		_allTasks = new TaskList(tasks, overdue, today, remaining);
		_showMoreIndexes = new ArrayList<Integer>();
	}

	/**
	 * constructor when the array of archive tasks, and count for archive tasks
	 * are passed.
	 * 
	 * @param archives
	 *            array of archive tasks
	 * @param archive
	 *            number of archive tasks
	 */
	public StateFeedback(ArrayList<Task> archives, int archive) {
		_allTasks = new TaskList(archives, archive);
		_showMoreIndexes = new ArrayList<Integer>();
	}

	/**
	 * constructor using a Tasklist object that contains the list of tasks.
	 * 
	 * @param taskList
	 *            TaskList object containing list of tasks
	 */
	public StateFeedback(TaskList taskList) {
		_allTasks = taskList;
		_showMoreIndexes = new ArrayList<Integer>();
	}

	/**
	 * getter for task list.
	 * 
	 * @return Tasklist object
	 */
	public TaskList getAllTasks() {
		return _allTasks;
	}

	/**
	 * getter for display feedback.
	 * 
	 * @return feedback string
	 */
	public String getFeedback() {
		return _feedback;
	}

	/**
	 * getter for array of detailed indexes.
	 * 
	 * @return array of detailed indexes
	 */
	public ArrayList<Integer> getDetailedIndexes() {
		return _showMoreIndexes;

	}

	/**
	 * setter for Tasklist object.
	 * 
	 * @param tasks
	 *            Tasklist object to be set
	 */
	public void setAllTasks(TaskList tasks) {
		_allTasks = tasks;
	}

	/**
	 * setter for feedback string.
	 * 
	 * @param feedback
	 *            feedback string to be set
	 */
	public void setFeedback(String feedback) {
		_feedback = feedback;
	}

	/**
	 * getter for state type.
	 * 
	 * @return state type enumeration used
	 */
	public State getState() {
		return _state;
	}

	/**
	 * setter for state type.
	 * 
	 * @param stateType
	 *            state type to be used
	 */
	public void setState(State stateType) {
		_state = stateType;
	}

	/**
	 * adds index for task to show details for.
	 * 
	 * @param index
	 *            index of task to show details for
	 */
	public void addDetailedTaskIdx(int index) {
		_showMoreIndexes.add(index);
		Collections.sort(_showMoreIndexes);
	}

	/**
	 * getter for index of task to set as selected.
	 * 
	 * @return index of task to be set as selected
	 */
	public int getDisplayPosition() {
		return _displayPosition;
	}

	/**
	 * setter for index of task to be set as selected.
	 * 
	 * @param displayPosition
	 *            index of task to be set as selected
	 */
	public void setDisplayPosition(int displayPosition) {
		_displayPosition = displayPosition;
	}

	/**
	 * setter for overdue tasks count.
	 * 
	 * @param overdueCount
	 *            count of overdue tasks to be set
	 */
	public void setOverdueCount(int overdueCount) {
		_overdueCount = overdueCount;
	}

	/**
	 * getter for overdue tasks count.
	 * 
	 * @return count of overdue tasks
	 */
	public int getOverdueCount() {
		return _overdueCount;
	}
}
```
###### urgenda\util\SuggestFeedback.java
``` java
package urgenda.util;

import java.util.ArrayList;
import java.util.StringTokenizer;

public class SuggestFeedback {

	private ArrayList<String> _suggestions;
	private String _currCmd;
	private String _userInstructionsPrompt;
	// isCommand is true only if the entire command is detected. else is either partial commands/add 
	private boolean _isCommand = false;
	private boolean _isSuggestion = false;
	
	/**
	 * TODO
	 * @param suggestions
	 * @param currCmd
	 * @param isCommand
	 */
	public SuggestFeedback(ArrayList<String> suggestions, String currCmd, boolean isCommand) {
		_currCmd = currCmd;
		_isCommand = isCommand;
		_suggestions = new ArrayList<String>();
		if (isCommand) {
			StringTokenizer tk = new StringTokenizer(suggestions.get(0), "|");
			while (tk.hasMoreElements()) {
				String next = tk.nextElement().toString();
				_suggestions.add(next);
			}
			_userInstructionsPrompt = suggestions.get(1);
		}
	}
	
	/**
	 * TODO
	 * @param suggestions
	 * @param isCommand
	 */
	public SuggestFeedback(ArrayList<String> suggestions, boolean isCommand) {
		_suggestions = suggestions;
		_isCommand = isCommand;
		_currCmd = null;
		_userInstructionsPrompt = suggestions.get(suggestions.size() - 1);
		_suggestions.remove(_suggestions.size() - 1);
	}

	/**
	 * TODO
	 * @return
	 */
	public ArrayList<String> getSuggestions() {
		return _suggestions;
	}
	
	/**
	 * TODO
	 * @return
	 */
	public String getCurrCmd() {
		return _currCmd;
	}

	/**
	 * TODO
	 * @return
	 */
	public boolean isCommand() {
		return _isCommand;
	}
	
	/**
	 * TODO
	 * @return
	 */
	public String getUserInstructionsPrompt() {
		return _userInstructionsPrompt;
	}
	
	/**
	 * TODO
	 * @param isSuggestion
	 */
	public void setIsSuggestion(boolean isSuggestion) {
		_isSuggestion = isSuggestion;
	}
	
	/**
	 * TODO
	 * @return
	 */
	public boolean isSuggestion() {
		return _isSuggestion;
	}
}
```
