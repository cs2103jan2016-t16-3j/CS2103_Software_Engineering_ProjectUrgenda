# A0126888L
###### test\testCommand\FreeTimeTest.java
``` java
package test.testCommand;

import static org.junit.Assert.*;

import java.time.LocalDateTime;
//import java.time.format.DateTimeFormatter;
import java.util.ArrayList;

import org.junit.FixMethodOrder;
import org.junit.Test;

import org.junit.runners.MethodSorters;

import urgenda.command.FindFree;
import urgenda.logic.LogicData;
import urgenda.util.Task;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class FreeTimeTest {

	private static final String MESSAGE_INVALID_TIME_RANGE = "Invalid time range for finding available time";
	

	/**
	 * 1 task comparing with range timing is from 11.59 to 17.00 start time
	 * outside range, end time inside range
	 */
	@Test
	public void test016SplitTime() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 22, 23, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 1, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// configuring expected outputs
		String expectedPhrase = "Showing available time slots between 22/3, 23:00 to 23/3, 01:00";
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 22, 23, 0);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 00, 0);
		exTask1.setDesc("1 hour ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);
		Task exTask2 = new Task();
		LocalDateTime exStart2 = LocalDateTime.of(2017, 3, 23, 0, 0);
		LocalDateTime exEnd2 = LocalDateTime.of(2017, 3, 23, 1, 0);
		exTask2.setDesc("1 hour ");
		exTask2.setStartTime(exStart2);
		exTask2.setEndTime(exEnd2);
		expectedList.add(exTask2);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
//		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
			assertEquals(expected.getDesc(), actual.getDesc());
		}
	}
	
	/**
	 * start time of range is before current time
	 */
	@Test
	public void test015ModifiedRange() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2016, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 6.01pm to 7pm starttime and endtime both infront of
		// range
		// removed all tasks to test modified range. 
//		Task task1 = new Task();
//		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 11, 58);
//		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 12, 01);
//		task1.setStartTime(start1);
//		task1.setEndTime(end1);
//		task1.updateTaskType();
//		data.addTask(task1);

		// configuring expected outputs
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.now();
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 18, 0);
		exTask1.setDesc("5 hours 49 minutes "); //this desc is obviously wrong. But so is actual desc?
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = e.getMessage();
			assertEquals(MESSAGE_INVALID_TIME_RANGE, actualPhrase);
		}
		
	}

	/**
	 * End time of range is before current timing
	 */
	@Test
	public void test014InvalidRange() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2016, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2016, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 6.01pm to 7pm starttime and endtime both infront of
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 11, 58);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 12, 01);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType();
		data.addTask(task1);
		Task task2 = new Task();
		LocalDateTime start2 = LocalDateTime.of(2017, 3, 23, 11, 59);
		LocalDateTime end2 = LocalDateTime.of(2017, 3, 23, 12, 11);
		task2.setStartTime(start2);
		task2.setEndTime(end2);
		task2.updateTaskType(start2, end2);
		data.addTask(task2);

		// configuring expected outputs
		String expectedPhrase = MESSAGE_INVALID_TIME_RANGE;
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 23, 12, 11);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 18, 0);
		exTask1.setDesc("5 hours 49 minutes ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = e.getMessage();
			assertEquals(MESSAGE_INVALID_TIME_RANGE, actualPhrase);
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

	/**
	 * Start time of range is after end time of range
	 */
	@Test
	public void test013InvalidRange() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 18, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 12, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 6.01pm to 7pm starttime and endtime both infront of
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 11, 58);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 12, 01);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType();
		data.addTask(task1);
		Task task2 = new Task();
		LocalDateTime start2 = LocalDateTime.of(2017, 3, 23, 11, 59);
		LocalDateTime end2 = LocalDateTime.of(2017, 3, 23, 12, 11);
		task2.setStartTime(start2);
		task2.setEndTime(end2);
		task2.updateTaskType(start2, end2);
		data.addTask(task2);

		// configuring expected outputs
		String expectedPhrase = MESSAGE_INVALID_TIME_RANGE;
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 23, 12, 11);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 18, 0);
		exTask1.setDesc("5 hours 49 minutes ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = e.getMessage();
			assertEquals(MESSAGE_INVALID_TIME_RANGE, actualPhrase);
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		/*
		 * TODO: Why is everything still running fine when test.execute() is
		 * supposed to throw an exception and not have executed everything
		 * below?
		 */
		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

	/**
	 * two tasks 1st has start time in front of range, end time inside range 2nd
	 * has start time in front of range after start time, end time inside range,
	 * after 1st end time
	 */
	@Test
	public void test012FreeTimeMultipleTask() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 6.01pm to 7pm starttime and endtime both infront of
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 11, 58);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 12, 01);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType();
		data.addTask(task1);
		Task task2 = new Task();
		LocalDateTime start2 = LocalDateTime.of(2017, 3, 23, 11, 59);
		LocalDateTime end2 = LocalDateTime.of(2017, 3, 23, 12, 11);
		task2.setStartTime(start2);
		task2.setEndTime(end2);
		task2.updateTaskType(start2, end2);
		data.addTask(task2);

		// configuring expected outputs
		String expectedPhrase = "Showing available time slots between 23/3, 12:00 to 23/3, 18:00";
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 23, 12, 11);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 18, 0);
		exTask1.setDesc("5 hours 49 minutes ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

	/**
	 * two tasks 1st has start time in front of range, end time inside range 2nd
	 * has start time in front of range, end time inside range, after 1st end
	 * time
	 */
	@Test
	public void test011FreeTimeMultipleTask() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 6.01pm to 7pm starttime and endtime both infront of
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 11, 59);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 12, 01);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType();
		data.addTask(task1);
		Task task2 = new Task();
		LocalDateTime start2 = LocalDateTime.of(2017, 3, 23, 11, 58);
		LocalDateTime end2 = LocalDateTime.of(2017, 3, 23, 12, 11);
		task2.setStartTime(start2);
		task2.setEndTime(end2);
		task2.updateTaskType(start2, end2);
		data.addTask(task2);

		// configuring expected outputs
		String expectedPhrase = "Showing available time slots between 23/3, 12:00 to 23/3, 18:00";
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 23, 12, 11);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 18, 0);
		exTask1.setDesc("5 hours 49 minutes ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

	/**
	 * two tasks 1st has start time in front of range, end time inside range 2nd
	 * has start time inside range, end time after the range
	 */
	@Test
	public void test010FreeTimeMultipleTask() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 6.01pm to 7pm starttime and endtime both infront of
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 11, 59);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 12, 01);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType(start1, end1);
		data.addTask(task1);
		Task task2 = new Task();
		LocalDateTime start2 = LocalDateTime.of(2017, 3, 23, 17, 59);
		LocalDateTime end2 = LocalDateTime.of(2017, 3, 23, 18, 01);
		task2.setStartTime(start2);
		task2.setEndTime(end2);
		task2.updateTaskType(start2, end2);
		data.addTask(task2);

		// configuring expected outputs
		String expectedPhrase = "Showing available time slots between 23/3, 12:00 to 23/3, 18:00";
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 23, 12, 1);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 17, 59);
		exTask1.setDesc("5 hours 58 minutes ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

	/**
	 * two tasks, both inside range
	 */
	@Test
	public void test009FreeTimeMultipleTask() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 6.01pm to 7pm starttime and endtime both infront of
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 12, 01);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 13, 00);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType(start1, end1);
		data.addTask(task1);
		Task task2 = new Task();
		LocalDateTime start2 = LocalDateTime.of(2017, 3, 23, 17, 00);
		LocalDateTime end2 = LocalDateTime.of(2017, 3, 23, 17, 59);
		task2.setStartTime(start2);
		task2.setEndTime(end2);
		task2.updateTaskType(start2, end2);
		data.addTask(task2);

		// configuring expected outputs
		String expectedPhrase = "Showing available time slots between 23/3, 12:00 to 23/3, 18:00";
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 12, 1);
		exTask1.setDesc("1 minute ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);
		Task exTask2 = new Task();
		LocalDateTime exStart2 = LocalDateTime.of(2017, 3, 23, 13, 0);
		LocalDateTime exEnd2 = LocalDateTime.of(2017, 3, 23, 17, 0);
		exTask2.setDesc("4 hours ");
		exTask2.setStartTime(exStart2);
		exTask2.setEndTime(exEnd2);
		expectedList.add(exTask2);
		Task exTask3 = new Task();
		LocalDateTime exStart3 = LocalDateTime.of(2017, 3, 23, 17, 59);
		LocalDateTime exEnd3 = LocalDateTime.of(2017, 3, 23, 18, 0);
		exTask3.setDesc("1 minute ");
		exTask3.setStartTime(exStart3);
		exTask3.setEndTime(exEnd3);
		expectedList.add(exTask3);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

	/**
	 * no tasks for comparison with range
	 */
	@Test
	public void test008FreeTimeNoTask() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// configuring expected outputs
		String expectedPhrase = "Showing available time slots between 23/3, 12:00 to 23/3, 18:00";
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 18, 0);
		exTask1.setDesc("6 hours ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

	/**
	 * 1 task comparing with range timing is from 11.59pm to 18.01pm. start time
	 * is in front of range, end time is after the range
	 */
	@Test
	public void test007NoFreeTimeOneTask() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 12.01pm to 17.59pm starttime and endtime both infront
		// of
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 11, 59);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 18, 01);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType(start1, end1);
		data.addTask(task1);

		// configuring expected outputs
		String expectedPhrase = "There are no available time between 23/3, 12:00 to 23/3, 18:00";

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
	}

	/**
	 * 1 task comparing with range timing is from 12.00pm to 18.00pm. start time
	 * and end time are the same as the range
	 */
	@Test
	public void test006NoFreeTimeOneTask() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 12.01pm to 17.59pm starttime and endtime both infront
		// of
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 18, 0);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType(start1, end1);
		data.addTask(task1);

		// configuring expected outputs
		String expectedPhrase = "There are no available time between 23/3, 12:00 to 23/3, 18:00";

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

	/**
	 * 1 task comparing with range timing is from 6.01pm to 7pm. both start time
	 * and end time is outside range
	 */
	@Test
	public void test005FreeTimeOneTask() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 6.01pm to 7pm starttime and endtime both infront of
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 18, 01);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 19, 00);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType(start1, end1);
		data.addTask(task1);

		// configuring expected outputs
		String expectedPhrase = "Showing available time slots between 23/3, 12:00 to 23/3, 18:00";
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 18, 0);
		exTask1.setDesc("6 hours ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

	/**
	 * 1 task comparing with range timing is from 12.01pm to 7pm. start time is
	 * inside range next to range start, end time outside range
	 */
	@Test
	public void test004FreeTimeOneTask() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 12.01 to 7pm starttime and endtime both infront of
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 12, 01);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 19, 00);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType(start1, end1);
		data.addTask(task1);

		// configuring expected outputs
		String expectedPhrase = "Showing available time slots between 23/3, 12:00 to 23/3, 18:00";
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 12, 1);
		exTask1.setDesc("1 minute ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

	/**
	 * 1 task comparing with range timing is from 5.59pm to 7pm. start time is
	 * inside range next to range end, end time outside range
	 */
	@Test
	public void test003FreeTimeOneTask() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 10.00 to 11.59 starttime and endtime both infront of
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 17, 59);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 19, 00);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType(start1, end1);
		data.addTask(task1);

		// configuring expected outputs
		String expectedPhrase = "Showing available time slots between 23/3, 12:00 to 23/3, 18:00";
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 17, 59);
		exTask1.setDesc("5 hours 59 minutes ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

	/**
	 * 1 task comparing with range timing is from 10.00 to 11.59 start time and
	 * end time both in front of range
	 */
	@Test
	public void test002FreeTimeOneTask() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 10.00 to 11.59 starttime and endtime both infront of
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 10, 0);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 11, 59);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType(start1, end1);
		data.addTask(task1);

		// configuring expected outputs
		String expectedPhrase = "Showing available time slots between 23/3, 12:00 to 23/3, 18:00";
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 18, 0);
		exTask1.setDesc("6 hours ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

	/**
	 * 1 task comparing with range timing is from 11.59 to 17.00 start time
	 * outside range, end time inside range
	 */
	@Test
	public void test001FreeTimeOneTask() {
		// setting up the test
		LogicData data = LogicData.getInstance();
		data.clearTasks();
		ArrayList<Task> expectedList = new ArrayList<Task>();
		LocalDateTime rangeStart = LocalDateTime.of(2017, 3, 23, 12, 0);
		LocalDateTime rangeEnd = LocalDateTime.of(2017, 3, 23, 18, 0);
		FindFree test = new FindFree(rangeStart, rangeEnd);

		// timing is from 11.59 to 14.00 starttime outside range, endtime inside
		// range
		Task task1 = new Task();
		LocalDateTime start1 = LocalDateTime.of(2017, 3, 23, 11, 59);
		LocalDateTime end1 = LocalDateTime.of(2017, 3, 23, 17, 0);
		task1.setStartTime(start1);
		task1.setEndTime(end1);
		task1.updateTaskType(start1, end1);
		data.addTask(task1);

		// configuring expected outputs
		String expectedPhrase = "Showing available time slots between 23/3, 12:00 to 23/3, 18:00";
		Task exTask1 = new Task();
		LocalDateTime exStart1 = LocalDateTime.of(2017, 3, 23, 17, 0);
		LocalDateTime exEnd1 = LocalDateTime.of(2017, 3, 23, 18, 0);
		exTask1.setDesc("1 hour ");
		exTask1.setStartTime(exStart1);
		exTask1.setEndTime(exEnd1);
		expectedList.add(exTask1);

		// getting actual outputs
		String actualPhrase;
		try {
			actualPhrase = test.execute();
		} catch (Exception e) {
			actualPhrase = MESSAGE_INVALID_TIME_RANGE;
			assertEquals(MESSAGE_INVALID_TIME_RANGE, e.getMessage());
		}
		assertEquals(expectedPhrase, actualPhrase);
		ArrayList<Task> actualList = data.getDisplays();

		// comparing expected and actual free time range
		assertEquals(expectedList.size(), actualList.size());
		for (int i = 0; i < expectedList.size(); i++) {
			Task actual = actualList.get(i);
			Task expected = expectedList.get(i);
			assertEquals(expected.getDesc(), actual.getDesc());
			assertEquals(expected.getStartTime(), actual.getStartTime());
			assertEquals(expected.getEndTime(), actual.getEndTime());
		}
	}

}
```
###### urgenda\storage\Decryptor.java
``` java
package urgenda.storage;

import java.time.LocalDateTime;
import java.util.ArrayList;

import urgenda.util.MultipleSlot;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * Decryptor class is a sub-class of JsonCipher class. It is used specifically
 * for decrypting Strings in JSON formats to Task objects.
 *
 */
public class Decryptor extends JsonCipher {
	private static UrgendaLogger logger = UrgendaLogger.getInstance();

	public Decryptor() {
		super();
	}

	/**
	 * Decrypts the Strings retrieved from the file into Task objects. Used
	 * specifically for current Tasks with ids starting from 0.
	 * 
	 * @param taskStrList
	 *            Strings must be in JSON format for a Task object.
	 * @return ArrayList of Tasks objects
	 */
	public ArrayList<Task> decryptTaskList(ArrayList<String> taskStrList) {
		ArrayList<Task> taskList = new ArrayList<Task>();
		for (int i = 0; i < taskStrList.size(); i++) {
			convertStringToTask(taskStrList, taskList, i);
		}
		return taskList;
	}

	private void convertStringToTask(ArrayList<String> taskStrList, ArrayList<Task> taskList, int i) {
		_detailsString = taskStrList.get(i);
		if (isJsonValid(_detailsString)) {
			convertToMap();
			Task newTask = generateTask(i + 1);
			taskList.add(newTask);
		} else {
			logger.getLogger().info("String is not in JSON format, discarded");
		}
	}

	/**
	 * Decrypts the Strings retrieved from the file into Tasks objects. Used
	 * specifically for completed Tasks with ids starting from -1 to
	 * differentiate between incomplete and completed tasks.
	 * 
	 * @param archiveStrList
	 *            Strings must be in JSON format for a Task object.
	 * @return ArrayList of Tasks objects for archives.
	 */
	public ArrayList<Task> decryptArchiveList(ArrayList<String> archiveStrList) {
		ArrayList<Task> archiveList = new ArrayList<Task>();
		for (int i = 0, j = -1; i < archiveStrList.size(); i++, j--) {
			convertStringtoArchiveTask(archiveStrList, archiveList, i, j);
		}
		return archiveList;
	}

	private void convertStringtoArchiveTask(ArrayList<String> archiveStrList, ArrayList<Task> archiveList, int i,
			int j) {
		_detailsString = archiveStrList.get(i);
		if (isJsonValid(_detailsString)) {
			convertToMap();
			Task newTask = generateTask(j);
			archiveList.add(newTask);
		} else {
			logger.getLogger().info("String is not in JSON format, discarded");
		}
	}

	/*
	 * Creates a task from the LinkedHashMap when converted from String to
	 * LinkedHashMap.
	 */
	private Task generateTask(int i) {
		int id = i;
		String desc = getDesc();
		String type = getType();
		String location = getLocation();
		boolean isCompleted = checkCompleted();
		boolean isImportant = checkImportant();
		boolean isOverdue = checkOverdue();
		LocalDateTime startTime = getStartTime();
		LocalDateTime endTime = getEndTime();
		LocalDateTime dateAdded = getDateAdded();
		LocalDateTime dateModified = getDateModified();
		MultipleSlot newSlot = getMultiple();
		Task newTask = new Task(id, desc, type, location, isCompleted, isImportant, isOverdue, startTime, endTime,
				dateAdded, dateModified, newSlot);
		return newTask;
	}

}
```
###### urgenda\storage\Encryptor.java
``` java
package urgenda.storage;

import java.util.ArrayList;
import java.util.LinkedHashMap;

import urgenda.util.Task;

/**
 * Encryptor class is a sub-class of JsonCipher class. It is used specifically
 * for encrypting Tasks into Strings in JSON formats.
 *
 */
public class Encryptor extends JsonCipher {

	public Encryptor() {
		super();
	}

	/**
	 * Encrypts a list of Task objects into Strings in JSON format for Task objects.
	 * @param taskList The list of task to be converted to JSON Strings.
	 * @return an ArrayList of converted Tasks into JSON Strings.
	 */
	public ArrayList<String> encrypt(ArrayList<Task> taskList) {
		ArrayList<String> stringList = new ArrayList<String>();
		for (Task task : taskList) {
			_detailsMap = new LinkedHashMap<String, String>();
			getTaskDetail(task);
			convertToString();
			stringList.add(_detailsString);
		}
		return stringList;
	}
	
	

	// getting Task attributes and storing in a LinkedHashMap
	private void getTaskDetail(Task task) {
		setDesc(task);
		setType(task); 
		setLocation(task);
		setStartTime(task);
		setEndTime(task);
		setDateAdded(task);
		setDateModified(task);
		setCompleted(task);
		setImportant(task);
		setOverdue(task);
		setMultiple(task);
	}

}
```
###### urgenda\storage\FileEditor.java
``` java
package urgenda.storage;

import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.NoSuchFileException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

import urgenda.util.InvalidFolderException;
import urgenda.util.UrgendaLogger;

/**
 * FileEditor class is the class used for file manipulation. The 2 files that
 * requires editing, the settings file and the main data file, are done using
 * this class.
 * 
 * @author User
 *
 */
public class FileEditor {
	private static final String LIST_SEPARATOR_ARCHIVE = "archive";

	private File _file;
	private File _parentDir;
	private static UrgendaLogger logger = UrgendaLogger.getInstance();

	/**
	 * Constructor of the FileEditor class. Builds a folder and constructs the
	 * file.
	 * 
	 * @param path
	 *            The directory that stores the file to be used for retrieval
	 *            and editing.
	 * @param name
	 *            The name of the file to be used for retrieval and editing.
	 */
	public FileEditor(String path, String name) {
		logger.getLogger().info("constructing FileEditor Object");
		initParentDir(path);
		initFile(name);
		checkIfFileExist();
		logger.getLogger().info("FileEditor object created");
	}

	private void initFile(String name) {
		_file = new File(_parentDir, name);
	}

	private void initParentDir(String path) {
		_parentDir = new File(path);
		_parentDir.mkdir();
	}

	private void checkIfFileExist() {
		if (_file.exists() == false) {
			try {
				_file.createNewFile();
				setUpFile();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}

	private void setUpFile() {
		ArrayList<String> create = new ArrayList<String>();
		writeToFile(create, create);

	}

	/**
	 * Reads the file into a single String. Used for settings file.
	 * 
	 * @return details from the file in a String.
	 */
	public String retrieveFromFile() {
		String phrase = null;
		try {
			FileReader reader = new FileReader(_file);
			BufferedReader breader = new BufferedReader(reader);
			StringBuffer stringBuffer = new StringBuffer();
			phrase = readFileToString(breader, stringBuffer);
			phrase = stringBuffer.toString().trim();
			breader.close();
			reader.close();
			logger.getLogger().info("successful retrieval of data");
		} catch (FileNotFoundException e) {
			logger.getLogger().info("no such file found" + e);
		} catch (IOException e) {
			e.printStackTrace();
		}
		return phrase;
	}

	private String readFileToString(BufferedReader breader, StringBuffer stringBuffer) throws IOException {
		String phrase;
		while ((phrase = breader.readLine()) != null) {
			stringBuffer.append(phrase).append("\n");
		}
		return phrase;
	}

	/**
	 * Reads the file into two separate arraylists. Strings before the word
	 * "archive" are added to the first arraylist while Strings after are added
	 * to the second arraylist.
	 * 
	 * @param fileDataStringArr
	 *            ArrayList for current uncompleted Tasks.
	 * @param archiveStringArr
	 *            ArrayList for completed archived Tasks.
	 */
	public void retrieveFromFile(ArrayList<String> fileDataStringArr, ArrayList<String> archiveStringArr) {
		try {
			FileReader reader = new FileReader(_file);
			BufferedReader breader = new BufferedReader(reader);
			addToTaskArray(breader, fileDataStringArr);
			addToArchiveArray(breader, archiveStringArr);
			breader.close();
			reader.close();
			logger.getLogger().info("successful retrieval of data");
		} catch (FileNotFoundException e) {
			logger.getLogger().info("no such file found");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	private void addToTaskArray(BufferedReader breader, ArrayList<String> fileDataStringArr) throws IOException {
		boolean hasNoMoreTasks = false;
		while (!hasNoMoreTasks) {
			String taskString = breader.readLine();
			if (taskString == null || taskString.equals(LIST_SEPARATOR_ARCHIVE)) {
				hasNoMoreTasks = true;
			} else if (taskString.isEmpty()) {
				hasNoMoreTasks = false;
			} else {
				fileDataStringArr.add(taskString);
			}
		}
	}

	private void addToArchiveArray(BufferedReader breader, ArrayList<String> archiveStringArr) throws IOException {
		boolean isEmpty = false;
		while (!isEmpty) {
			String taskString = breader.readLine();
			if (taskString == null) {
				isEmpty = true;
			} else if (taskString.isEmpty()) {
				isEmpty = false;
			} else {
				archiveStringArr.add(taskString);
			}
		}
	}

	/**
	 * Writes into the file the two separate arraylists. The first arraylist is
	 * separated from the second arraylist by the word "archive".
	 * 
	 * @param fileDataStringArr
	 *            ArrayList for current uncompleted Tasks.
	 * @param archiveStringArr
	 *            ArrayList for completed archived Tasks.
	 */
	public void writeToFile(ArrayList<String> fileDataStringArr, ArrayList<String> archiveStringArr) {
		try {
			PrintWriter writer = new PrintWriter(_file);
			for (String phrase : fileDataStringArr) {
				writer.println(phrase);
			}
			writer.println(LIST_SEPARATOR_ARCHIVE);
			for (String phrase : archiveStringArr) {
				writer.println(phrase);
			}
			writer.close();
		} catch (FileNotFoundException e) {
			logger.getLogger().info("no such file found");
		}
	}

	/**
	 * Writes into the file the String. Used for settings file.
	 * 
	 * @param phrase
	 *            details to be written into the file.
	 */
	public void writeToFile(String phrase) {
		try {
			PrintWriter writer = new PrintWriter(_file);
			writer.println(phrase);
			writer.close();
		} catch (FileNotFoundException e) {
			logger.getLogger().info("no such file found");
		}
	}

	/**
	 * Clears the file, erasing all data in it.
	 */
	public void clearFile() {
		try {
			PrintWriter writer = new PrintWriter(_file);
			writer.close();
		} catch (FileNotFoundException e) {
			logger.getLogger().info("no such file found");
		}
	}

	/**
	 * Renames the file into the given name. If such a name already exist in
	 * that particular directory, it will be replaced.
	 * 
	 * @param name
	 *            the new name for the file to be renamed to.
	 */
	public void rename(String name) {
		Path source = _file.toPath();
		try {
			Files.move(source, source.resolveSibling(name), REPLACE_EXISTING);
		} catch (IOException e) {
			e.printStackTrace();
		}
		initFile(name);
	}

	/**
	 * Changes the file directory to the given file directory. If a file with
	 * the same name already exist in the new directory, it will be replaced.
	 * 
	 * @param path
	 *            the new file directory for the file to be moved to.
	 * @throws InvalidFolderException
	 *             If the given file directory is of an invalid folder type,
	 *             then the file will not be moved there.
	 */
	public void relocate(String path) throws InvalidFolderException {
		Path source = _file.toPath();
		File parentDir = new File(path);
		parentDir.mkdir();
		Path newSource = Paths.get(path);
		try {
			Files.move(source, newSource.resolve(source.getFileName()), REPLACE_EXISTING);
		} catch (NoSuchFileException e) {
			logger.getLogger().info(source + " does not exist, unable to proceed with file relocation");
			throw new InvalidFolderException(path);
		} catch (IOException e) {
			e.printStackTrace();
		}
		_parentDir = parentDir;
		_file = new File(_parentDir, source.getFileName().toString());
	}

	/**
	 * Checks if a file of a particular name currently exists in the particular
	 * directory.
	 * 
	 * @param dir
	 *            the file directory to be checked for existing file.
	 * @param name
	 *            the file name to be checked for existing file.
	 * @return true if file already exists, false if otherwise.
	 */
	public static boolean isExistingFile(String dir, String name) {
		File file = new File(dir, name);
		if (file.exists()) {
			return true;
		} else {
			return false;
		}
	}

	/*
	 * Used for testing purposes only.
	 */
	public void paths() {
		System.out.println("Absolute Path " + _file.getAbsolutePath());
		System.out.println("Name " + _file.getName());
		System.out.println("Path " + _file.getPath());
		System.out.println("Parent " + _file.getParent());
		System.out.println("String " + _file.toString());
		System.out.println("Path path " + _file.toPath());
	}

	/**
	 * Returns the name of the file. This should only be the name, appended with ".txt". 
	 * 
	 * @return name of the file. 
	 */
	public String getFileName() {
		return _file.getName();
	}

	/**
	 * Returns the absolute path of the file. This includes the name of the
	 * file.
	 * 
	 * @return absolute path of the file.
	 */
	public String getAbsolutePath() {
		return _file.getAbsolutePath();
	}

	/**
	 * Returns the absolut epath of the directory.
	 * 
	 * @return absolute path of the directory. 
	 */
	public String getDirAbsolutePath() {
		return _parentDir.getAbsolutePath();
	}

	/**
	 * Deletes the file, as well as the file directory. The file will be deleted
	 * only if no other pointers are pointing to it. The file directory will be
	 * deleted only if there are no other objects in it.
	 */
	public void delete() {
		_file.delete();
		_parentDir.delete();
	}

	/**
	 * Deletes the file and the file directory on exit, without needing to call
	 * them at the end. The file will be deleted only if no other pointers are
	 * pointing to it. The file directory will be deleted only if there are no
	 * other objects in it.
	 */
	public void deleteOnExit() {
		_file.deleteOnExit();
		_parentDir.deleteOnExit();
	}

}
```
###### urgenda\storage\JsonCipher.java
``` java
package urgenda.storage;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.LinkedHashMap;

import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

import urgenda.util.MultipleSlot;
import urgenda.util.UrgendaLogger;
import urgenda.util.Task;
import urgenda.util.DateTimePair;

/**
 * JsonCipher class is the main class used for conversion between a Task and
 * String. JsonCipher extracts the relevant information from the Task, storing
 * it a LinkedHashMap before it is converted into a String. JsonCipher has two
 * derived classes from it: Encryptor and Decryptor.
 *
 */
public class JsonCipher {
	private static final String HASHMAP_KEY_DESC = "desc";
	private static final String HASHMAP_KEY_TYPE = "type";
	private static final String HASHMAP_KEY_LOCATION = "location";
	private static final String HASHMAP_KEY_STARTTIME = "startTime";
	private static final String HASHMAP_KEY_ENDTIME = "endTime";
	private static final String HASHMAP_KEY_DATEADDED = "dateAdded";
	private static final String HASHMAP_KEY_DATEMODIFIED = "dateModified";
	private static final String HASHMAP_KEY_COMPLETED = "completed";
	private static final String HASHMAP_KEY_IMPORTANT = "important";
	private static final String HASHMAP_KEY_OVERDUE = "overdue";
	private static final String HASHMAP_KEY_MULTIPLE_DESC = "multipleDesc";
	private static final String HASHMAP_KEY_FILE_DIRECTORY = "directory";
	private static final String HASHMAP_KEY_FILE_NAME = "name";
	private static final String HASHMAP_KEY_NOVICE_SETTINGS = "novice";

	private static final String DELIMITER_MULTIPLE_WITHIN_PAIRS = "~";
	private static final String DELIMITER_MULTIPLE_BET_PAIRS = "`";

	private static final String TASKTYPE_EVENT = "EVENT";
	private static final String TASKTYPE_DEADLINE = "DEADLINE";
	private static final String TASKTYPE_FLOATING = "FLOATING";

	private static final String DEFAULT_FILE_LOCATION = "settings";
	private static final String DEFAULT_FILE_NAME = "data.txt";

	private static final int MULTIPLE_START = 0;
	private static final int MULTIPLE_END = 1;

	private static UrgendaLogger logger = UrgendaLogger.getInstance();

	protected Gson _gson;
	protected LinkedHashMap<String, String> _detailsMap;
	protected String _detailsString;

	/**
	 * default constructor for JsonCipher class. Initializes a new Gson and new
	 * LinkedHashMap.
	 */
	public JsonCipher() {
		_gson = new Gson();
		_detailsMap = new LinkedHashMap<String, String>();
	}

	/**
	 * Constructor taking in a String, automatically converting it to a
	 * LinkedHashMap if possible.
	 * 
	 * @param detailsString
	 *            String should be JSON format for conversion to a LinkedHashMap
	 *            to take place.
	 */
	public JsonCipher(String detailsString) {
		_gson = new Gson();
		if (isJsonValid(detailsString)) {
			_detailsString = detailsString;
			convertToMap();
			checkIfMapExist();
		} else {
			_detailsMap = new LinkedHashMap<String, String>();
		}
	}

	/**
	 * Clears the attributes of JsonCipher.
	 */
	public void reset() {
		_detailsMap.clear();
		_detailsString = new String();
	}

	/**
	 * Checks if LinkedHashMap is of NULL value.
	 */
	public void checkIfMapExist() {
		if (_detailsMap == null) {
			_detailsMap = new LinkedHashMap<String, String>();
		}
	}

	/**
	 * Checks if LinkedHashMap is empty.
	 * 
	 * @return true if LinkedHashMap is empty, false otherwise.
	 */
	public boolean isEmptyMap() {
		if (_detailsMap.isEmpty()) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Checks if give phrase is of valid Json format.
	 * 
	 * @param phrase
	 *            given phrase for checking.
	 * @return true if is valid Json format for Task objects, false otherwise.
	 */
	protected boolean isJsonValid(String phrase) {
		try {
			_gson.fromJson(phrase, new TypeToken<LinkedHashMap<String, String>>() {
			}.getType());
			return true;
		} catch (com.google.gson.JsonSyntaxException ex) {
			logger.getLogger().info(ex.toString());
			logger.getLogger()
					.info("String not in required json format for Tasks. Unable to parse, will be overwritten.");
			return false;
		}
	}

	/**
	 * converts stored String to LinkedHashMap.
	 */
	public void convertToMap() {
		_detailsMap = _gson.fromJson(_detailsString, new TypeToken<LinkedHashMap<String, String>>() {
		}.getType());
	}

	/**
	 * Converts stored LinkedHashMap to String.
	 */
	public void convertToString() {
		_detailsString = _gson.toJson(_detailsMap);
	}

	/**
	 * extracts multiple slots from Task to be place in LinkedHashMap.
	 * 
	 * @param task
	 *            Given task to be converted to LinkedHashMap.
	 */
	public void setMultiple(Task task) {
		if (task.getSlot() == null) {
			_detailsMap.put(HASHMAP_KEY_MULTIPLE_DESC, null);
		} else {
			convertSlotsToString(task);
		}
	}

	/*
	 * converts multipleslots in a task to a string to be stored in
	 * LinkedHashMap.
	 */
	private void convertSlotsToString(Task task) {
		ArrayList<DateTimePair> pairs = task.getSlot().getSlots();
		String slots = new String();
		slots = convertPairToString(pairs, slots);
		_detailsMap.put(HASHMAP_KEY_MULTIPLE_DESC, slots);
	}

	private String convertPairToString(ArrayList<DateTimePair> pairs, String slots) {
		for (DateTimePair pair : pairs) {
			slots = slots + pair.getEarlierDateTime().toString() + DELIMITER_MULTIPLE_WITHIN_PAIRS
					+ pair.getLaterDateTime().toString();
			slots = slots + DELIMITER_MULTIPLE_BET_PAIRS;
		}
		return slots;
	}

	/**
	 * Returns the slots of a Task object.
	 * 
	 * @return MultipleSlot format for multiple timeslots of a Task object.
	 */
	public MultipleSlot getMultiple() {
		if (_detailsMap.get(HASHMAP_KEY_MULTIPLE_DESC) == null) {
			return null;
		} else if (_detailsMap.get(HASHMAP_KEY_MULTIPLE_DESC).isEmpty()) {
			MultipleSlot slots = new MultipleSlot();
			return slots;
		} else {
			MultipleSlot slots = new MultipleSlot();
			String slotsString = _detailsMap.get(HASHMAP_KEY_MULTIPLE_DESC);
			String[] slotsArray = slotsString.split(DELIMITER_MULTIPLE_BET_PAIRS);
			convertStringtoSlot(slots, slotsArray);
			return slots;
		}
	}

	private void convertStringtoSlot(MultipleSlot slots, String[] slotsArray) {
		for (String pair : slotsArray) {
			String[] pairArray = pair.split(DELIMITER_MULTIPLE_WITHIN_PAIRS);
			LocalDateTime start = LocalDateTime.parse(pairArray[MULTIPLE_START]);
			LocalDateTime end = LocalDateTime.parse(pairArray[MULTIPLE_END]);
			slots.addTimeSlot(start, end);
		}
	}

	/**
	 * Extracts the boolean value of Overdue from Task and associates the key
	 * with the boolean value, placing it in the relevant LinkedHashMap mapping.
	 * 
	 * @param task
	 *            Given task to be converted to LinkedHashMap.
	 */
	public void setOverdue(Task task) {
		_detailsMap.put(HASHMAP_KEY_OVERDUE, String.valueOf(task.isOverdue()));
	}

	/**
	 * Extracts the boolean value of Important from Task and associates the key
	 * with the boolean value, placing it in the relevant LinkedHashMap mapping.
	 * 
	 * @param task
	 *            Given task to be converted to LinkedHashMap.
	 */
	public void setImportant(Task task) {
		_detailsMap.put(HASHMAP_KEY_IMPORTANT, String.valueOf(task.isImportant()));
	}

	/**
	 * Extracts the boolean value of Completed from Task and associates the key
	 * with the boolean value, placing it in the relevant LinkedHashMap mapping.
	 * 
	 * @param task
	 *            Given task to be converted to LinkedHashMap.
	 */
	public void setCompleted(Task task) {
		_detailsMap.put(HASHMAP_KEY_COMPLETED, String.valueOf(task.isCompleted()));
	}

	/**
	 * Extracts the LocalDateTime value of DateModified from Task and associates
	 * the key with the LocalDateTime value, placing it in the relevant
	 * LinkedHashMap mapping.
	 * 
	 * @param task
	 *            Given task to be converted to LinkedHashMap.
	 */
	public void setDateModified(Task task) {
		if (task.getDateModified() == null) {
			_detailsMap.put(HASHMAP_KEY_DATEMODIFIED, null);
		} else {
			_detailsMap.put(HASHMAP_KEY_DATEMODIFIED, task.getDateModified().toString());
		}
	}

	/**
	 * Extracts the LocalDateTime value of DateAdded from Task and associates
	 * the key with the LocalDateTime value, placing it in the relevant
	 * LinkedHashMap mapping.
	 * 
	 * @param task
	 *            Given task to be converted to LinkedHashMap.
	 */
	public void setDateAdded(Task task) {
		if (task.getDateAdded() == null) {
			_detailsMap.put(HASHMAP_KEY_DATEADDED, null);
		} else {
			_detailsMap.put(HASHMAP_KEY_DATEADDED, task.getDateAdded().toString());
		}
	}

	/**
	 * Extracts the LocalDateTime value of EndTime from Task and associates the
	 * key with the LocalDateTime value, placing it in the relevant
	 * LinkedHashMap mapping.
	 * 
	 * @param task
	 *            Given task to be converted to LinkedHashMap.
	 */
	public void setEndTime(Task task) {
		if (task.getEndTime() == null) {
			_detailsMap.put(HASHMAP_KEY_ENDTIME, null);
		} else {
			_detailsMap.put(HASHMAP_KEY_ENDTIME, task.getEndTime().toString());
		}
	}

	/**
	 * Extracts the LocalDateTime value of StartTime from Task and associates
	 * the key with the LocalDateTime value, placing it in the relevant
	 * LinkedHashMap mapping.
	 * 
	 * @param task
	 *            Given task to be converted to LinkedHashMap.
	 */
	public void setStartTime(Task task) {
		if (task.getStartTime() == null) {
			_detailsMap.put(HASHMAP_KEY_STARTTIME, null);
		} else {
			_detailsMap.put(HASHMAP_KEY_STARTTIME, task.getStartTime().toString());
		}
	}

	/**
	 * Extracts the String value of Location from Task and associates the key
	 * with the String value, placing it in the relevant LinkedHashMap mapping.
	 * 
	 * @param task
	 *            Given task to be converted to LinkedHashMap.
	 */
	public void setLocation(Task task) {
		if (task.getLocation() == null) {
			_detailsMap.put(HASHMAP_KEY_LOCATION, null);
		} else {
			_detailsMap.put(HASHMAP_KEY_LOCATION, task.getLocation());
		}
	}

	/**
	 * Extracts the Type value of TaskType from Task and associates the key with
	 * the Type value, placing it in the relevant LinkedHashMap mapping.
	 * 
	 * @param task
	 *            Given task to be converted to LinkedHashMap.
	 */
	public void setType(Task task) {
		if (task.getTaskType().toString().equals(TASKTYPE_EVENT)) {
			_detailsMap.put(HASHMAP_KEY_TYPE, TASKTYPE_EVENT);
		} else if (task.getTaskType().toString().equals(TASKTYPE_DEADLINE)) {
			_detailsMap.put(HASHMAP_KEY_TYPE, TASKTYPE_DEADLINE);
		} else {
			_detailsMap.put(HASHMAP_KEY_TYPE, TASKTYPE_FLOATING);
		}
	}

	/**
	 * Extracts the String value of Description from Task and associates the key
	 * with the String value, placing it in the relevant LinkedHashMap mapping.
	 * 
	 * @param task
	 *            Given task to be converted to LinkedHashMap.
	 */
	public void setDesc(Task task) {
		if (task.getDesc() == null) {
			_detailsMap.put(HASHMAP_KEY_DESC, null);
		} else {
			_detailsMap.put(HASHMAP_KEY_DESC, task.getDesc());
		}
	}

	/**
	 * Associates the String given with the key to place it in the relevant
	 * LinkedHashMap mapping of the file directory.
	 * 
	 * @param path
	 *            Given String for file directory.
	 */
	public void setDirectory(String path) {
		_detailsMap.put(HASHMAP_KEY_FILE_DIRECTORY, path);
	}

	/**
	 * Associates the String given with the key to place it in the relevant
	 * LinkedHashMap mapping of the file name.
	 * 
	 * @param name
	 *            Given String for file name.
	 */
	public void setFileName(String name) {
		_detailsMap.put(HASHMAP_KEY_FILE_NAME, name);
	}
	
	
	/**
	 * Retrieves the value stored in the LinkedHashMap associated with the DateModified key.
	 * 
	 * @return LocalDateTime format of DateModified.
	 */
	public LocalDateTime getDateModified() {
		if (_detailsMap.get(HASHMAP_KEY_DATEMODIFIED) == null) {
			return null;
		} else {
			return LocalDateTime.parse(_detailsMap.get(HASHMAP_KEY_DATEMODIFIED));
		}
	}
	
	/**
	 * Retrieves the value stored in the LinkedHashMap associated with the DateAdded key.
	 * 
	 * @return LocalDateTime format of DateAdded.
	 */
	public LocalDateTime getDateAdded() {
		if (_detailsMap.get(HASHMAP_KEY_DATEADDED) == null) {
			return null;
		} else {
			return LocalDateTime.parse(_detailsMap.get(HASHMAP_KEY_DATEADDED));
		}
	}
	
	/**
	 * Retrieves the value stored in the LinkedHashMap associated with the EndTime key.
	 * 
	 * @return LocalDateTime format of EndTime.
	 */
	public LocalDateTime getEndTime() {
		if (_detailsMap.get(HASHMAP_KEY_ENDTIME) == null) {
			return null;
		} else {
			return LocalDateTime.parse(_detailsMap.get(HASHMAP_KEY_ENDTIME));
		}
	}

	/**
	 * Retrieves the value stored in the LinkedHashMap associated with the StartTime key.
	 * 
	 * @return LocalDateTime format of StartTime.
	 */
	public LocalDateTime getStartTime() {
		if (_detailsMap.get(HASHMAP_KEY_STARTTIME) == null) {
			return null;
		} else {
			return LocalDateTime.parse(_detailsMap.get(HASHMAP_KEY_STARTTIME));
		}
	}
	
	/**
	 * Retrieves the value stored in the LinkedHashMap associated with the Overdue key.
	 * 
	 * @return boolean value of Overdue.
	 */
	public boolean checkOverdue() {
		return Boolean.parseBoolean(_detailsMap.get(HASHMAP_KEY_OVERDUE));
	}

	/**
	 * Retrieves the value stored in the LinkedHashMap associated with the Important key.
	 * 
	 * @return boolean value of Important.
	 */
	public boolean checkImportant() {
		return Boolean.parseBoolean(_detailsMap.get(HASHMAP_KEY_IMPORTANT));
	}

	/**
	 * Retrieves the value stored in the LinkedHashMap associated with the Completed key.
	 * 
	 * @return boolean value of Completed.
	 */
	public boolean checkCompleted() {
		return Boolean.parseBoolean(_detailsMap.get(HASHMAP_KEY_COMPLETED));
	}

	/**
	 * Retrieves the value stored in the LinkedHashMap associated with the Location key.
	 * 
	 * @return String value of Location.
	 */
	public String getLocation() {
		return _detailsMap.get(HASHMAP_KEY_LOCATION);
	}

	/**
	 * Retrieves the value stored in the LinkedHashMap associated with the Type key.
	 * 
	 * @return String value of Type.
	 */
	public String getType() {
		return _detailsMap.get(HASHMAP_KEY_TYPE);
	}

	/**
	 * Retrieves the value stored in the LinkedHashMap associated with the Description key.
	 * 
	 * @return String value of Description.
	 */
	public String getDesc() {
		return _detailsMap.get(HASHMAP_KEY_DESC);
	}
	
	/**
	 * Retrieves the value stored in the LinkedHashMap associated with the Directory key.
	 * 
	 * @return String value of Directory.
	 */
	public String getDirectory() {
		if (_detailsMap.get(HASHMAP_KEY_FILE_DIRECTORY) == null) {
			return DEFAULT_FILE_LOCATION;
		} else {
			return _detailsMap.get(HASHMAP_KEY_FILE_DIRECTORY);
		}
	}
	
	/**
	 * Retrieves the value stored in the LinkedHashMap associated with the FileName key.
	 * 
	 * @return String value of FileName.
	 */
	public String getFileName() {
		if (_detailsMap.get(HASHMAP_KEY_FILE_NAME) == null) {
			return DEFAULT_FILE_NAME;
		} else {
			return _detailsMap.get(HASHMAP_KEY_FILE_NAME);
		}
	}
	
	/**
	 * Returns the JSON format String of a Task object.
	 * 
	 * @return String of a Task object
	 */
	public String getDetailsString() {
		return _detailsString;
	}

	/**
	 * Returns the LinkedHashMap of a Task object. 
	 * 
	 * @return LinkedHashMap of a Task object.
	 */
	public LinkedHashMap<String, String> getDetailsMap() {
		return _detailsMap;
	}

	public void setNoviceSettings(boolean isNovice) {
		_detailsMap.put(HASHMAP_KEY_NOVICE_SETTINGS, String.valueOf(isNovice));
		
	}

	public boolean getNoviceSettings() {
		return Boolean.parseBoolean(_detailsMap.get(HASHMAP_KEY_NOVICE_SETTINGS));
	}

}
```
###### urgenda\storage\SettingsEditor.java
``` java
package urgenda.storage;

import java.util.LinkedHashMap;

import urgenda.util.UrgendaLogger;

/**
 * The SettingsEditor class handles all matters related to the settings of
 * Urgenda. It consists of a FileEditor and JsonCipher object. Since the
 * settings are not a Task object, it does not need to convert from a String to
 * a LinkedHashMap to a Task. Hence it can converted directly through the
 * JsonCipher class alone with the help of the derived classes Encryptor or
 * Decryptor.
 * 
 */
public class SettingsEditor {
	private static UrgendaLogger logger = UrgendaLogger.getInstance();
	private static final String SETTINGS_DIRECTORY = "settings";
	private static final String SETTINGS_FILENAME = "settings.txt";

	private static final String DEFAULT_FILE_LOCATION = "settings";
	private static final String DEFAULT_FILE_NAME = "data.txt";
	private static final boolean DEFAULT_NOVICE_SETTINGS = true;

	private JsonCipher _cipher;
	private FileEditor _settings;
	private String _settingsString;

	/**
	 * Default constructor for SettingsEditor. Uses the default directory where
	 * settings should be stored.
	 */
	public SettingsEditor() {
		logger.getLogger().info("constructing SettingsEditor Object");
		_settings = new FileEditor(SETTINGS_DIRECTORY, SETTINGS_FILENAME);
		_settingsString = _settings.retrieveFromFile();
		_cipher = new JsonCipher(_settingsString);
		checkIfEmptyMap();
	}

	/**
	 * Constructor used for testing, to provide a testing bed for file
	 * manipulation, and saving the settings.
	 * 
	 * @param path
	 *            the file directory where the settings file is stored.
	 * @param name
	 *            the file name of the settings file.
	 */
	public SettingsEditor(String path, String name) {
		_settings = new FileEditor(path, name);
		_settingsString = _settings.retrieveFromFile();
		_cipher = new JsonCipher(_settingsString);
		checkIfEmptyMap();
	}

	/**
	 * Checks if the settings file is empty, adding in the default locations if
	 * so.
	 */
	public void checkIfEmptyMap() {
		if (_cipher.isEmptyMap()) {
			logger.getLogger().info("Empty cipher map. adding default locations.");
			setAllFieldsAsDefaultSettings();
			saveSettings();
		}
	}

	/**
	 * saves the settings by writing to the file after conversion to JSON
	 * format.
	 */
	public void saveSettings() {
		logger.getLogger().info("Saving settings.");
		_cipher.convertToString();
		_settingsString = _cipher.getDetailsString();
		_settings.writeToFile(_settingsString);
	}

	/**
	 * Resets all settings to default. Used for testing purposes to ensure less
	 * messy file directories when testing.
	 */
	public void resetDefault() {
		_cipher.reset();
		setAllFieldsAsDefaultSettings();
		saveSettings();
	}

	private void setAllFieldsAsDefaultSettings() {
		_cipher.setDirectory(DEFAULT_FILE_LOCATION);
		_cipher.setFileName(DEFAULT_FILE_NAME);
		_cipher.setNoviceSettings(DEFAULT_NOVICE_SETTINGS);
	}

	public void setNoviceSettings(boolean isNovice) {
		_cipher.setNoviceSettings(isNovice);
		saveSettings();
	}

	public boolean getNoviceSettings() {
		return _cipher.getNoviceSettings();
	}

	/**
	 * Returns the directory where the main data file is stored.
	 * 
	 * @return String value of the File Directory.
	 */
	public String getFileDir() {
		return _cipher.getDirectory();
	}

	/**
	 * Returns the name of the main data file.
	 * 
	 * @return String value of the name of the main data file.
	 */
	public String getFileName() {
		return _cipher.getFileName();
	}

	/**
	 * Changes the directory of the main data file in the settings file. This
	 * does not change where the main data file is located, only changes the
	 * value in the LinkedHashMap for the settings file.
	 * 
	 * @param path
	 *            the given file directory that will be changed.
	 */
	public void setFileDir(String path) {
		_cipher.setDirectory(path);
	}

	/**
	 * Changes the name of the main data file in the settings file. This does
	 * not change the name of the main data file, only changes the value in the
	 * LinkedHashMap for the settings file.
	 * 
	 * @param name
	 *            the given file name that will be changed.
	 */
	public void setFileName(String name) {
		_cipher.setFileName(name);
	}

	/*
	 * Used for testing purposes to ensure LinkedHashMap is updated accordingly.
	 */
	public LinkedHashMap<String, String> getMap() {
		return _cipher.getDetailsMap();
	}

	/**
	 * Used for testing purposes to delete additional files and directories
	 * created for testing.
	 */
	public void delete() {
		_settings.delete();
	}

	/**
	 * Used for testing purposes to delete additional files and directories
	 * created for testing, without the need to delete on the last line.
	 */
	public void deleteOnExit() {
		_settings.deleteOnExit();
	
	}

}
```
###### urgenda\storage\Storage.java
``` java
package urgenda.storage;

import java.util.ArrayList;

import urgenda.util.*;

/**
 * Storage class for the Storage component of Urgenda. Acts as the facade for
 * the storage requirements of Urgenda.
 *
 */
public class Storage {
	private static UrgendaLogger logger = UrgendaLogger.getInstance();

	private static final String DELIMITER_FILE_TYPE = "\\";
	private static final String HELP_TYPE = "HELP";
	private static final String DEMO_TYPE = "DEMO";
	private static final String TEXT_FILE_TYPE = ".txt";
	private static final String DIRECTORY_SEPARATOR_FWD_SLASH = "/";
	private static final String DIRECTORY_SEPARATOR_BCK_SLASH = "\\";
	private static final String DESC_INTRO_TASK = "Add your first Task! Press Help or Alt + F1 for guidance";

	private static final int FILE_TYPE_CHAR_SIZE = 4;

	protected FileEditor _file;
	protected Manual _help;
	protected Manual _demo;
	protected SettingsEditor _settings;
	protected ArrayList<String> _fileDataStringArr = new ArrayList<String>();
	protected ArrayList<String> _archiveStringArr = new ArrayList<String>();
	protected Decryptor _decryptor = new Decryptor();
	protected Encryptor _encryptor = new Encryptor();

	/**
	 * Constructor for Storage class. Retrieves previous settings from settings
	 * directory to initialize main data file.
	 */
	public Storage() {
		logger.getLogger().info("constructing Storage Object");
		_settings = new SettingsEditor();
		String path = _settings.getFileDir();
		String name = _settings.getFileName();
		_help = new Manual(HELP_TYPE);
		_demo = new Manual(DEMO_TYPE);
		_file = new FileEditor(path, name);
		_file.retrieveFromFile(_fileDataStringArr, _archiveStringArr);
		// checkIfEmptyFile();
		logger.getLogger().info("Storage object created.");
	}

	private void checkIfEmptyFile() {
		if (_fileDataStringArr.isEmpty() && _archiveStringArr.isEmpty()) {
			createIntroTask();
		}

	}

	private void createIntroTask() {
		Task introTask = new Task();
		introTask.setDesc(DESC_INTRO_TASK);
		introTask.updateTaskType();
		ArrayList<Task> introList = new ArrayList<Task>();
		ArrayList<Task> introArchive = new ArrayList<Task>();
		introList.add(introTask);
		save(introList, introArchive);

	}

	/**
	 * Constructor for Storage class. Takes in 2 parameters that defines the
	 * location and name of the main data file.
	 * 
	 * @param path
	 *            The directory where the main data file should be located.
	 * @param name
	 *            The name of the main data file.
	 */
	public Storage(String path, String name) {
		logger.getLogger().info("constructing Storage Object");
		_settings = new SettingsEditor();
		_help = new Manual("HELP");
		_demo = new Manual("DEMO");
		_file = new FileEditor(path, name);
		_file.retrieveFromFile(_fileDataStringArr, _archiveStringArr);
	}

	/**
	 * Creates an ArrayList of Tasks from an ArrayList of String formatted
	 * tasks. Uses the list from the current tasks.
	 * 
	 * @return ArrayList of Tasks from TaskList.
	 */
	public ArrayList<Task> updateCurrentTaskList() {
		ArrayList<Task> tasks = _decryptor.decryptTaskList(_fileDataStringArr);
		return tasks;
	}

	/**
	 * Creates an ArrayList of Tasks from an ArrayList of String formatted
	 * tasks. Uses the list from archives.
	 * 
	 * @return ArrayList of Tasks from Archives.
	 */
	public ArrayList<Task> updateArchiveTaskList() {
		ArrayList<Task> archives = _decryptor.decryptArchiveList(_archiveStringArr);
		return archives;
	}

	/**
	 * Saves 2 ArrayList of Tasks into a text file.
	 * 
	 * @param tasks
	 *            Contains a list of uncompleted tasks.
	 * @param archive
	 *            Contains a list of completed tasks.
	 */
	public void save(ArrayList<Task> tasks, ArrayList<Task> archive) {
		_fileDataStringArr = _encryptor.encrypt(tasks);
		_archiveStringArr = _encryptor.encrypt(archive);
		_file.writeToFile(_fileDataStringArr, _archiveStringArr);
	}

	/**
	 * Changes the file settings of the main data file, the file directory and
	 * file name.
	 * 
	 * @param path
	 *            The absolute path of the new file directory and file name for
	 *            the main data file.
	 * @throws StorageException
	 *             If such a file with the same file type, same file name exists
	 *             in that particular file directory
	 * @throws InvalidFolderException
	 *             If the path given is not in the correct absolute path format.
	 */
	public void changeFileSettings(String path) throws StorageException, InvalidFolderException {
		String correctPath = checkDirectorySeparator(path);
		String fileType = getFileTypeFromPath(correctPath);
		if (fileType.equals(TEXT_FILE_TYPE)) {
			String dir = getDirFromPath(correctPath);
			String name = getNameFromPath(correctPath);
			checkIfFileExists(dir, name);
		} else {
			checkIfFileExists(correctPath, _file.getFileName());
		}
	}

	private String checkDirectorySeparator(String path) {
		String newPath = path;
		if (path.contains(DIRECTORY_SEPARATOR_FWD_SLASH)) {
			newPath = path.replace(DIRECTORY_SEPARATOR_FWD_SLASH, DIRECTORY_SEPARATOR_BCK_SLASH);
		}
		return newPath;
	}

	private String getFileTypeFromPath(String path) {
		return path.trim().substring(path.length() - FILE_TYPE_CHAR_SIZE);
	}

	private String getNameFromPath(String path) {
		return path.trim().substring(path.lastIndexOf(DELIMITER_FILE_TYPE) + 1, path.length());
	}

	private String getDirFromPath(String path) {
		return path.trim().substring(0, path.lastIndexOf(DELIMITER_FILE_TYPE));
	}

	/*
	 * checks if there is an existing file with such a name in that particular
	 * directory.
	 */
	private void checkIfFileExists(String dir, String name) throws StorageException, InvalidFolderException {
		if (!FileEditor.isExistingFile(dir, name)) {
			_file.relocate(dir);
			_file.rename(name);
			setFileSettings(dir, name);
		} else {
			setFileSettings(dir, name);
			throw new StorageException(dir, name);
		}
	}

	private void setFileSettings(String dir, String name) {
		_settings.setFileDir(dir);
		_settings.setFileName(name);
		_settings.saveSettings();
	}

	/**
	 * Retrieves help manual
	 * 
	 * @return ArrayList of String for Help.
	 */
	public ArrayList<String> getHelp() {
		logger.getLogger().info("inside getHelp function");
		ArrayList<String> help;
		help = _help.getManual();
		logger.getLogger().info("retrieved from file.");
		return help;
	}

	/**
	 * Retrieves the absolute directory of the main data file.
	 * 
	 * @return
	 */
	public String getDirPath() {
		return _file.getDirAbsolutePath();
	}

	/**
	 * For testing purposes, to delete all additional files used for testing.
	 */
	public void delete() {
		_file.delete();
		_settings.delete();
	}

	/**
	 * Retrieves demo manual
	 * 
	 * @return ArrayList of String for Demo.
	 */
	public ArrayList<String> getDemoText() {
		logger.getLogger().info("inside getDemoText function");
		ArrayList<String> demo;
		demo = _demo.getManual();
		logger.getLogger().info("retrieved from file. ");
		return demo;
	}

	/**
	 * Retrieves demo indexes for demo tasks selection
	 * 
	 * @return ArrayList of Integers consisting of Demo Indexes.
	 */
	public ArrayList<Integer> getDemoSelectionIndexes() {
		return _demo.getIndexes();
	}

	public boolean getNoviceSettings() {
		return _settings.getNoviceSettings();
	}

	public void setNoviceSettings(boolean isNovice) {
		_settings.setNoviceSettings(isNovice);
		_settings.saveSettings();
		
	}
}
```
###### urgenda\storage\StorageTester.java
``` java
package urgenda.storage;

public class StorageTester extends Storage{
	private static final String TEST_SETTINGS_DIRECTORY = "testfiles";
	private static final String TEST_SETTINGS_NAME = "settings.txt";
	private static final String TEST_FILE_LOCATION = "testfiles";
	private static final String TEST_FILE_NAME = "test.txt";
	
	public StorageTester(String filePath, String fileName){
		super(filePath, fileName);
		_settings = new SettingsEditor(TEST_SETTINGS_DIRECTORY, TEST_SETTINGS_NAME);
		_file.deleteOnExit();
		_settings.deleteOnExit();
	}
	
	public StorageTester(){
		super(TEST_FILE_LOCATION, TEST_FILE_NAME);
		_settings = new SettingsEditor(TEST_SETTINGS_DIRECTORY, TEST_SETTINGS_NAME);
		_file.deleteOnExit();
		_settings.deleteOnExit();
	}
}
```
###### urgenda\util\InvalidFolderException.java
``` java
package urgenda.util;

public class InvalidFolderException extends Exception{

	/**
	 * System Generated serial number for InvalidFolderException.
	 */
	private static final long serialVersionUID = 1L;
	private static final String ERROR_MESSAGE = "%1$s is an invalid folder path. Please enter a valid folder path.";
	
	private String _path;
	
	/**
	 * Default constructor for InvalidFolderException
	 * 
	 * @param path absolute path of preferred file destination 
	 */
	public InvalidFolderException(String path){
		_path = path;
	}
	
	/**
	 * Returns the path of the file dest.
	 * @return String of the file dest.
	 */
	public String getPath(){
		return _path;
	}
	
	/**
	 * Returns 
	 */
	@Override
	public String getMessage(){
		return String.format(ERROR_MESSAGE, _path.toUpperCase());
	}

}
```
###### urgenda\util\StorageException.java
``` java
package urgenda.util;

public class StorageException extends Exception {
	/**
	 * System Generated serial number for StorageException.
	 */
	private static final long serialVersionUID = 1L;

	private static final String ERROR_MESSAGE = "%1$s already exist in %2$s. \nLoading tasks from existing file";

	private String _dir;
	private String _name;

	/**
	 * Default constructor for Storage Exception.
	 * 
	 * @param dir
	 *            directory containing the existing file.
	 * @param name
	 *            name of the existing file.
	 */
	public StorageException(String dir, String name) {
		_dir = dir;
		_name = name;
	}

	/**
	 * Returns the directory containing the existing file.
	 * 
	 * @return String of the directory.
	 */
	public String getDir() {
		return _dir;
	}

	/**
	 * Returns the existing file name.
	 * 
	 * @return String of the file name.
	 */
	public String getName() {
		return _name;
	}
	
	/**
	 * Returns the error message containing the name and folder of the existing file.
	 * 
	 * @return String of the error message together with incorrect file dest.
	 */
	@Override
	public String getMessage() {
		String error = String.format(ERROR_MESSAGE, _name, _dir.toUpperCase());
		return error;
	}
}
```
