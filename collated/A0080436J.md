# A0080436J
###### src\test\testUrgenda\UrgendaTest.java
``` java
package test.testUrgenda;

import static org.junit.Assert.*;

import java.time.LocalDateTime;
import java.util.ArrayList;

import org.junit.Test;

import urgenda.logic.Logic;
import urgenda.util.DateTimePair;
import urgenda.util.MultipleSlot;
import urgenda.util.StateFeedback;
import urgenda.util.Task;
import urgenda.util.TaskList;

// test for integration across logic and parser.
public class UrgendaTest {
	
	private static final String ADD_COMMAND = "add ";
	private static final String DELETE_COMMAND = "delete ";
	private static final String UNDO_COMMAND = "undo";
	private static final String REDO_COMMAND = "redo";
	private static final String MESSAGE_ADDED = " added";
	private static final String MESSAGE_REMOVE = " removed";
	private static final String MESSAGE_UNDO = "Undo: ";
	private static final String MESSAGE_REDO = "Redo: ";
	private static final String MESSAGE_EVENT = "\"%1$s\" on %2$d/%3$d %4$02d:%5$02d - "
			+ "%6$d/%7$d %8$02d:%9$02d";
	private static final String MESSAGE_EVENT_DATETIME = ", %1$d/%2$d, %3$02d:%4$02d - %5$02d:%6$02d";
	private static final String MESSAGE_FLOAT = "\"%1$s\"";
	private static final String MESSAGE_DEADLINE = "\"%1$s\" by %2$d/%3$d, %4$02d:%5$02d";

	private static final int ADD_INDEX = 0;

	// Test case of adding a floating task across logic and parser, using a stubbed location for storage.
	@Test
	public void testAddFloating() {
		String desc = "floating task";
		String timing = " ";
		LocalDateTime start = null;
		LocalDateTime end = null;
		
		Logic logic = Logic.getInstance(true);
		StateFeedback actualOutput = logic.executeCommand(ADD_COMMAND + desc + timing, ADD_INDEX);
		Task newTask = new Task(desc, null, start, end);
		ArrayList<Task> expectedTasks = new ArrayList<Task>();
		expectedTasks.add(newTask);
		ArrayList<Task> expectedArchives = new ArrayList<Task>();
		TaskList expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 1, 0);
		TaskList actualList = actualOutput.getAllTasks();
		ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
		String expectedFeedback = taskMessageWithMulti(newTask) + MESSAGE_ADDED;
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		assertEquals(actualOutput.getDisplayPosition(), 0);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		logic.clearStorageTester();
	}

	// test case for adding an event
	@Test
	public void testAddEvent() {
		String desc = "event task";
		String timing = " 31/5 10am to 1/6 9pm";
		LocalDateTime start = LocalDateTime.of(2016, 5, 31, 10, 0);
		LocalDateTime end = LocalDateTime.of(2016, 6, 1, 21, 0);
		
		Logic logic = Logic.getInstance(true);
		StateFeedback actualOutput = logic.executeCommand(ADD_COMMAND + desc + timing, ADD_INDEX);
		Task newTask = new Task(desc, null, start, end);
		ArrayList<Task> expectedTasks = new ArrayList<Task>();
		expectedTasks.add(newTask);
		ArrayList<Task> expectedArchives = new ArrayList<Task>();
		TaskList expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 1, 0);
		TaskList actualList = actualOutput.getAllTasks();
		ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
		String expectedFeedback = taskMessageWithMulti(newTask) + MESSAGE_ADDED;
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		assertEquals(actualOutput.getDisplayPosition(), 0);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		logic.clearStorageTester();
	}

	// test case for adding of deadline task.
	@Test
	public void testAddDeadline() {
		String desc = "deadline task";
		String timing = " by 1/6 9pm";
		LocalDateTime start = null;
		LocalDateTime end = LocalDateTime.of(2016, 6, 1, 21, 0);
		
		Logic logic = Logic.getInstance(true);
		StateFeedback actualOutput = logic.executeCommand(ADD_COMMAND + desc + timing, ADD_INDEX);
		Task newTask = new Task(desc, null, start, end);
		ArrayList<Task> expectedTasks = new ArrayList<Task>();
		expectedTasks.add(newTask);
		ArrayList<Task> expectedArchives = new ArrayList<Task>();
		TaskList expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 1, 0);
		TaskList actualList = actualOutput.getAllTasks();
		ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
		String expectedFeedback = taskMessageWithMulti(newTask) + MESSAGE_ADDED;
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		assertEquals(actualOutput.getDisplayPosition(), 0);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		logic.clearStorageTester();
	}

	// test the adding of multiple tasks of different type across logic and parser.
	// checks for the positioning of the tasks being inserted as well.
	@Test
	public void testAddMulitple() {
		String desc1 = "deadline task";
		String timing1 = " by 1/6 9pm";
		LocalDateTime start1 = null;
		LocalDateTime end1 = LocalDateTime.of(2016, 6, 1, 21, 0);
		String desc2 = "event task";
		String timing2 = " 31/5 10am to 1/6 9pm";
		LocalDateTime start2 = LocalDateTime.of(2016, 5, 31, 10, 0);
		LocalDateTime end2 = LocalDateTime.of(2016, 6, 1, 21, 0);
		String desc3 = "floating task";
		String timing3 = " ";
		LocalDateTime start3 = null;
		LocalDateTime end3 = null;
		String desc4 = "abc task";
		String timing4 = " ";
		LocalDateTime start4 = null;
		LocalDateTime end4 = null;
		
		Logic logic = Logic.getInstance(true);
		
		StateFeedback actualOutput = logic.executeCommand(ADD_COMMAND + desc1 + timing1, ADD_INDEX);
		Task newTask = new Task(desc1, null, start1, end1);
		ArrayList<Task> expectedTasks = new ArrayList<Task>();
		expectedTasks.add(newTask);
		ArrayList<Task> expectedArchives = new ArrayList<Task>();
		TaskList expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 1, 0);
		TaskList actualList = actualOutput.getAllTasks();
		ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
		String expectedFeedback = taskMessageWithMulti(newTask) + MESSAGE_ADDED;
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		assertEquals(actualOutput.getDisplayPosition(), 0);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		actualOutput = logic.executeCommand(ADD_COMMAND + desc2 + timing2, ADD_INDEX);
		newTask = new Task(desc2, null, start2, end2);
		// inserts at the front due to sorting
		expectedTasks.add(0, newTask);
		expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 2, 0);
		actualList = actualOutput.getAllTasks();
		expectedIndexes = new ArrayList<Integer>();
		expectedFeedback = taskMessageWithMulti(newTask) + MESSAGE_ADDED;
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		assertEquals(actualOutput.getDisplayPosition(), 0);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		actualOutput = logic.executeCommand(ADD_COMMAND + desc3 + timing3, ADD_INDEX);
		newTask = new Task(desc3, null, start3, end3);
		// inserts at the front due to sorting
		expectedTasks.add(newTask);
		expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 3, 0);
		actualList = actualOutput.getAllTasks();
		expectedIndexes = new ArrayList<Integer>();
		expectedFeedback = taskMessageWithMulti(newTask) + MESSAGE_ADDED;
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		// position shifted to 2 due to being inserted as last
		assertEquals(actualOutput.getDisplayPosition(), 2);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		actualOutput = logic.executeCommand(ADD_COMMAND + desc4 + timing4, ADD_INDEX);
		newTask = new Task(desc4, null, start4, end4);
		// inserts at the front due to sorting
		expectedTasks.add(2, newTask);
		expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 4, 0);
		actualList = actualOutput.getAllTasks();
		expectedIndexes = new ArrayList<Integer>();
		expectedFeedback = taskMessageWithMulti(newTask) + MESSAGE_ADDED;
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		// position shifted to 2 due to being inserted at third position by alphabetical sort
		assertEquals(actualOutput.getDisplayPosition(), 2);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		logic.clearStorageTester();
	}

	// tests the undo and redo functionality of adding a task.
	@Test
	public void testUndoAndRedo() {
		String desc = "event task";
		String timing = " 31/5 10am to 1/6 9pm";
		LocalDateTime start = LocalDateTime.of(2016, 5, 31, 10, 0);
		LocalDateTime end = LocalDateTime.of(2016, 6, 1, 21, 0);
		
		Logic logic = Logic.getInstance(true);
		StateFeedback actualOutput = logic.executeCommand(ADD_COMMAND + desc + timing, ADD_INDEX);
		Task newTask = new Task(desc, null, start, end);
		ArrayList<Task> expectedTasks = new ArrayList<Task>();
		expectedTasks.add(newTask);
		ArrayList<Task> expectedArchives = new ArrayList<Task>();
		TaskList expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 1, 0);
		TaskList actualList = actualOutput.getAllTasks();
		ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
		String expectedFeedback = taskMessageWithMulti(newTask) + MESSAGE_ADDED;
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		assertEquals(actualOutput.getDisplayPosition(), 0);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		actualOutput = logic.executeCommand(UNDO_COMMAND, 0);
		expectedTasks.remove(newTask);
		expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 0, 0);
		actualList = actualOutput.getAllTasks();
		expectedFeedback = MESSAGE_UNDO + taskMessageWithMulti(newTask) + MESSAGE_REMOVE;
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		assertEquals(actualOutput.getDisplayPosition(), 0);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		actualOutput = logic.executeCommand(REDO_COMMAND, 0);
		expectedTasks.add(newTask);
		expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 1, 0);
		actualList = actualOutput.getAllTasks();
		expectedFeedback = MESSAGE_REDO + taskMessageWithMulti(newTask) + MESSAGE_ADDED;
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		assertEquals(actualOutput.getDisplayPosition(), 0);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		logic.clearStorageTester();
	}

	// tests for deletion of a task by the position of the task.
	@Test
	public void testDelete() {
		String desc = "event task";
		String timing = " 31/5 10am to 1/6 9pm";
		LocalDateTime start = LocalDateTime.of(2016, 5, 31, 10, 0);
		LocalDateTime end = LocalDateTime.of(2016, 6, 1, 21, 0);
		
		Logic logic = Logic.getInstance(true);
		StateFeedback actualOutput = logic.executeCommand(ADD_COMMAND + desc + timing, ADD_INDEX);
		Task newTask = new Task(desc, null, start, end);
		ArrayList<Task> expectedTasks = new ArrayList<Task>();
		expectedTasks.add(newTask);
		ArrayList<Task> expectedArchives = new ArrayList<Task>();
		TaskList expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 1, 0);
		TaskList actualList = actualOutput.getAllTasks();
		ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
		String expectedFeedback = taskMessageWithMulti(newTask) + MESSAGE_ADDED;
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		assertEquals(actualOutput.getDisplayPosition(), 0);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		actualOutput = logic.executeCommand(DELETE_COMMAND + "1", 0);
		expectedTasks.remove(0);
		expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 0, 0);
		actualList = actualOutput.getAllTasks();
		expectedFeedback = taskMessageWithMulti(newTask) + MESSAGE_REMOVE;
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		assertEquals(actualOutput.getDisplayPosition(), 0);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		logic.clearStorageTester();
	}

	// tests the deletion of multiple tasks through location.
	@Test
	public void testDeleteMultiple() {
		String desc1 = "deadline task";
		String timing1 = " by 1/6 9pm";
		LocalDateTime start1 = null;
		LocalDateTime end1 = LocalDateTime.of(2016, 6, 1, 21, 0);
		String desc2 = "event task";
		String timing2 = " 31/5 10am to 1/6 9pm";
		LocalDateTime start2 = LocalDateTime.of(2016, 5, 31, 10, 0);
		LocalDateTime end2 = LocalDateTime.of(2016, 6, 1, 21, 0);
		String desc3 = "floating task";
		String timing3 = " ";
		LocalDateTime start3 = null;
		LocalDateTime end3 = null;
		String desc4 = "abc task";
		String timing4 = " ";
		LocalDateTime start4 = null;
		LocalDateTime end4 = null;
		
		Logic logic = Logic.getInstance(true);
		
		StateFeedback actualOutput = logic.executeCommand(ADD_COMMAND + desc1 + timing1, ADD_INDEX);
		Task newTask = new Task(desc1, null, start1, end1);
		ArrayList<Task> expectedTasks = new ArrayList<Task>();
		expectedTasks.add(newTask);
		ArrayList<Task> expectedArchives = new ArrayList<Task>();
		ArrayList<Integer> expectedIndexes = new ArrayList<Integer>();
		
		actualOutput = logic.executeCommand(ADD_COMMAND + desc2 + timing2, ADD_INDEX);
		newTask = new Task(desc2, null, start2, end2);
		expectedTasks.add(0, newTask);
		
		actualOutput = logic.executeCommand(ADD_COMMAND + desc3 + timing3, ADD_INDEX);
		newTask = new Task(desc3, null, start3, end3);
		expectedTasks.add(newTask);
		
		actualOutput = logic.executeCommand(ADD_COMMAND + desc4 + timing4, ADD_INDEX);
		newTask = new Task(desc4, null, start4, end4);
		expectedTasks.add(2, newTask);
		TaskList expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 4, 0);
		TaskList actualList = actualOutput.getAllTasks();
		expectedIndexes = new ArrayList<Integer>();
		String expectedFeedback = taskMessageWithMulti(newTask) + MESSAGE_ADDED;
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		// position shifted to 2 due to being inserted at third position by alphabetical sort
		assertEquals(actualOutput.getDisplayPosition(), 2);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		assertEquals(actualOutput.getFeedback(), expectedFeedback);
		
		actualOutput = logic.executeCommand(DELETE_COMMAND + "1-4", 0);
		expectedTasks.clear();
		expectedList = new TaskList(expectedTasks, expectedArchives, 0, 0, 0, 0);
		actualList = actualOutput.getAllTasks();
		
		compareTaskList(expectedList, actualList);
		assertEquals(actualOutput.getState(), StateFeedback.State.ALL_TASKS);
		assertEquals(actualOutput.getDisplayPosition(), 0);
		assertEquals(actualOutput.getDetailedIndexes(), expectedIndexes);
		
		logic.clearStorageTester();
	}
	
	// comparator function for tasklists.
	private void compareTaskList(TaskList expectedList, TaskList actualList) {
		// tests the TaskList object in state feedback
		ArrayList<Task> actualTasks = actualList.getTasks();
		ArrayList<Task> expectedTasks = expectedList.getTasks();
		for (int i = 0; i < actualTasks.size(); i++) {
			Task exTask = expectedTasks.get(i);
			Task actlTask = actualTasks.get(i);
			assertEquals(exTask.getDesc(), actlTask.getDesc());
			assertEquals(exTask.getLocation(), actlTask.getLocation());
			assertEquals(exTask.isCompleted(), actlTask.isCompleted());
			assertEquals(exTask.isImportant(), actlTask.isImportant());
			assertEquals(exTask.isOverdue(), actlTask.isOverdue());
			assertEquals(exTask.getStartTime(), actlTask.getStartTime());
			assertEquals(exTask.getEndTime(), actlTask.getEndTime());
			assertEquals(exTask.getTaskType(), actlTask.getTaskType());			
		}
		ArrayList<Task> actualArchives = actualList.getArchives();
		ArrayList<Task> expectedArchives = expectedList.getTasks();
		for (int i = 0; i < actualArchives.size(); i++) {
			Task exTask = expectedArchives.get(i);
			Task actlTask = actualArchives.get(i);
			assertEquals(exTask.getDesc(), actlTask.getDesc());
			assertEquals(exTask.getLocation(), actlTask.getLocation());
			assertEquals(exTask.isCompleted(), actlTask.isCompleted());
			assertEquals(exTask.isImportant(), actlTask.isImportant());
			assertEquals(exTask.isOverdue(), actlTask.isOverdue());
			assertEquals(exTask.getStartTime(), actlTask.getStartTime());
			assertEquals(exTask.getEndTime(), actlTask.getEndTime());
			assertEquals(exTask.getTaskType(), actlTask.getTaskType());			
		}
		
		assertEquals(expectedList.getOverdueCount(), actualList.getOverdueCount());
		assertEquals(expectedList.getTodayCount(), actualList.getTodayCount());
		assertEquals(expectedList.getRemainingCount(), actualList.getRemainingCount());
		assertEquals(expectedList.getArchiveCount(), actualList.getArchiveCount());
		assertEquals(expectedList.getUncompletedCount(), actualList.getUncompletedCount());
	}

	// for generation of messages of the task given as input, includes multiple tasks
	private String taskMessageWithMulti(Task task) {
		String feedback = taskMessage(task);
		if (task.getSlot() != null) {
			feedback += additionalTimings(task.getSlot());
		}
		return feedback;
	}

	// for generation of messages of task given as input, excludes multiple tasks
	private String taskMessage(Task task) {
		Task.Type taskType = task.getTaskType();
		String feedback = null;
		switch (taskType) {
		case EVENT :
			feedback = String.format(MESSAGE_EVENT, task.getDesc(), task.getStartTime().getDayOfMonth(),
					task.getStartTime().getMonthValue(), task.getStartTime().getHour(), 
					task.getStartTime().getMinute(), task.getEndTime().getDayOfMonth(), 
					task.getEndTime().getMonthValue(), task.getEndTime().getHour(),
					task.getEndTime().getMinute());
			break;
		case FLOATING :
			feedback = String.format(MESSAGE_FLOAT, task.getDesc());
			break;
		case DEADLINE :
			feedback = String.format(MESSAGE_DEADLINE, task.getDesc(), task.getEndTime().getDayOfMonth(),
					task.getEndTime().getMonthValue(), task.getEndTime().getHour(),
					task.getEndTime().getMinute());
			break;
		}
		return feedback;
	}

	// generator for feedback message for slots
	private String additionalTimings(MultipleSlot block) {
		String feedback = "";
		ArrayList<DateTimePair> slots = block.getSlots();
		for (DateTimePair pair : slots) {
			LocalDateTime start = pair.getEarlierDateTime();
			LocalDateTime end = pair.getLaterDateTime();
			feedback += String.format(MESSAGE_EVENT_DATETIME, start.getDayOfMonth(), start.getMonthValue(),
					start.getHour(), start.getMinute(), end.getHour(), end.getMinute());
		}
		return feedback;
	}
}
```
###### src\test\testUtils\MultipleSlotTest.java
``` java
package test.testUtils;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.time.LocalDateTime;
import java.util.ArrayList;

import org.junit.Test;

import urgenda.util.DateTimePair;
import urgenda.util.MultipleSlot;

// test cases for the methods in multipleslot
public class MultipleSlotTest {

	@Test
	public void testConstructor() {
		ArrayList<DateTimePair> empty = new ArrayList<DateTimePair>();
		MultipleSlot test = new MultipleSlot();
		assertEquals(test.getSlots(), empty);
	}

	@Test
	public void testAddTimeSlot() {
		LocalDateTime now = LocalDateTime.now();
		MultipleSlot test = new MultipleSlot();
		test.addTimeSlot(now, now);
		assertTrue(test.getSlots().size() == 1);
		assertFalse(test.getSlots().size() < 1);
		assertFalse(test.getSlots().size() > 1);

		assertEquals(test.getSlots().get(0).getDateTime1(), now);
		assertEquals(test.getSlots().get(0).getDateTime2(), now);

		LocalDateTime newTime = now.plusMonths(1);
		test = new MultipleSlot();
		test.addTimeSlot(now, newTime);
		assertTrue(test.getSlots().size() == 1);
		assertFalse(test.getSlots().size() < 1);
		assertFalse(test.getSlots().size() > 1);

		assertEquals(test.getSlots().get(0).getDateTime1(), now);
		assertEquals(test.getSlots().get(0).getDateTime2(), newTime);
	}

	@Test
	public void testRemoveNextSlot() {
		LocalDateTime now = LocalDateTime.now();
		ArrayList<DateTimePair> slots = new ArrayList<DateTimePair>();
		MultipleSlot test = new MultipleSlot();

		// Boundary case where size is zero and nothing happens
		// test case for empty slot
		assertEquals(test.getSlots(), slots);
		assertTrue(test.isEmpty());
		test.removeNextSlot();
		assertEquals(test.getSlots(), slots);
		assertTrue(test.isEmpty());

		// test case for one slot
		test.addTimeSlot(now, now);
		assertFalse(test.isEmpty());
		test.removeNextSlot();
		assertEquals(test.getSlots(), slots);
		assertTrue(test.isEmpty());

		// test case for multiple slots
		test.addTimeSlot(now, now.plusMonths(1));
		test.addTimeSlot(now.plusMonths(2), now.plusMonths(3));
		assertFalse(test.isEmpty());
		test.removeNextSlot();
		ArrayList<DateTimePair> remains = test.getSlots();
		assertEquals(remains.get(0).getDateTime1(), now.plusMonths(2));
		assertEquals(remains.get(0).getDateTime2(), now.plusMonths(3));

		// test case for multiple slots and the number of calls is more than the
		// slots
		test.addTimeSlot(now, now.plusMonths(1));
		test.addTimeSlot(now.plusMonths(2), now.plusMonths(3));
		assertFalse(test.isEmpty());
		test.removeNextSlot();
		test.removeNextSlot();
		test.removeNextSlot();
		remains = test.getSlots();
		assertEquals(remains, slots);
		assertTrue(remains.isEmpty());
	}

	@Test
	public void testGetNextSlot() {
		LocalDateTime now = LocalDateTime.now();
		MultipleSlot test = new MultipleSlot();
		assertEquals(test.getNextSlot(), null);

		test.addTimeSlot(now, now.plusMonths(1));
		test.addTimeSlot(now.plusMonths(2), now.plusMonths(3));
		assertEquals(test.getNextSlot().getDateTime1(), now);
		assertEquals(test.getNextSlot().getDateTime2(), now.plusMonths(1));

		test.removeNextSlot();
		assertEquals(test.getNextSlot().getDateTime1(), now.plusMonths(2));
		assertEquals(test.getNextSlot().getDateTime2(), now.plusMonths(3));
	}

}
```
###### src\urgenda\command\AddTask.java
``` java
package urgenda.command;

import java.time.LocalDateTime;
import java.util.ArrayList;

import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * AddTask is the command object used for adding of tasks to Urgenda.
 *
 */
public class AddTask extends TaskCommand {

	private static UrgendaLogger logger = UrgendaLogger.getInstance();

	private static final String MESSAGE_ADDED = " added";
	private static final String MESSAGE_REMOVE = " removed";
	private static final String MESSAGE_ERROR = "Error: ";
	private static final String MESSAGE_OVERLAP = "\nWarning: Overlaps with ";
	private static final String MESSAGE_EVENT_PASSED = "\nWarning: Event added has already passed";
	private static final String MESSAGE_DEADLINE_PASSED = "\nWarning: Deadline added has already passed";

	private Task _newTask;
	private LogicData _data;

	/**
	 * Default constructor for creating a new AddTask command object.
	 */
	public AddTask() {
		_newTask = new Task();
	}

	/**
	 * Alternative constructor for AddTask command object with the new task to
	 * be added.
	 * 
	 * @param newTask
	 *            New Task object that is to be added.
	 */
	public AddTask(Task newTask) {
		_newTask = newTask;
	}

	/**
	 * Execute command of AddTask which adds newTask to Urgenda.
	 * 
	 * @throws LogicException
	 *             When the task added is invalid.
	 */
	public String execute() throws LogicException {
		logger.getLogger().warning("Can cause exception");
		_data = LogicData.getInstance();
		updateNewTask();
		return addNewTask();
	}

	/*
	 * Adds newTask to LogicData of Urgenda. Checks if the task is valid.
	 */
	private String addNewTask() throws LogicException {
		String feedback;
		try {
			checkTaskValidity(_newTask);
			_data.addTask(_newTask);
			_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			_data.setTaskPointer(_newTask);
			_data.clearShowMoreTasks();
			feedback = checkPassed();
			feedback += findOverlaps();
		} catch (LogicException e) {
			logger.getLogger().severe("Exception occurred" + e);
			_data.setCurrState(LogicData.DisplayState.INVALID_TASK);
			// throws exception to prevent AddTask being added to undo stack
			throw new LogicException(MESSAGE_ERROR + e.getMessage());
		}
		return taskMessageWithMulti(_newTask) + MESSAGE_ADDED + feedback;
	}

	/*
	 * Updates all the attributes of newTask according to current time and new
	 * task id.
	 */
	private void updateNewTask() {
		LocalDateTime now = LocalDateTime.now();
		_newTask.setId(_data.getCurrentId());
		_newTask.setSlot(null);
		_newTask.setDateAdded(now);
		_newTask.setDateModified(now);
		_data.updateCurrentId();
	}

	/*
	 * Checks if newTask has already passed based on current time.
	 */
	private String checkPassed() {
		if (_newTask.getTaskType() == Task.Type.EVENT) {
			if (_newTask.getEndTime().isBefore(LocalDateTime.now())) {
				return MESSAGE_EVENT_PASSED;
			}
		} else if (_newTask.getTaskType() == Task.Type.DEADLINE) {
			if (_newTask.getEndTime().isBefore(LocalDateTime.now())) {
				return MESSAGE_DEADLINE_PASSED;
			}
		}
		return "";
	}

	/*
	 * Finds all overlapping task with newTask and returns task message of
	 * overlaps.
	 */
	private String findOverlaps() {
		ArrayList<Task> overlaps;
		overlaps = _data.overlappingTasks(_newTask);
		if (overlaps.size() == 0) {
			return "";
		} else {
			return generateOverlapMessage(overlaps);
		}
	}

	/*
	 * Generates all the message of tasks that overlap with the newTask.
	 */
	private String generateOverlapMessage(ArrayList<Task> overlaps) {
		String feedback = MESSAGE_OVERLAP + taskMessage(overlaps.get(0));
		overlaps.remove(0);
		for (Task task : overlaps) {
			feedback += ", " + taskMessage(task);
		}
		return feedback;
	}

	/**
	 * Undo method of AddTask which undos the adding of the task into task list.
	 */
	public String undo() {
		_data.deleteTask(_newTask);
		return taskMessageWithMulti(_newTask) + MESSAGE_REMOVE;
	}

	/**
	 * Redo method of AddTask which redo the action and adds the task back.
	 */
	public String redo() {
		_newTask.setDateModified(LocalDateTime.now());
		_data.addTask(_newTask);
		_data.setTaskPointer(_newTask);
		return taskMessageWithMulti(_newTask) + MESSAGE_ADDED + findOverlaps();
	}

	/**
	 * Setter for the newTask.
	 * 
	 * @param newTask
	 *            New Task that is to be added to Urgenda.
	 */
	public void setNewTask(Task newTask) {
		_newTask = newTask;
	}

}
```
###### src\urgenda\command\BlockSlots.java
``` java
package urgenda.command;

import java.time.LocalDateTime;
import java.util.ArrayList;

import urgenda.logic.LogicData;
import urgenda.util.DateTimePair;
import urgenda.util.LogicException;
import urgenda.util.MultipleSlot;
import urgenda.util.Task;

/**
 * BlockSlots is the command used for adding tasks with multiple slots.
 *
 */
public class BlockSlots extends TaskCommand {

	private static final String MESSAGE_ADDED = " added";
	private static final String MESSAGE_BLOCK = "Blocked ";
	private static final String MESSAGE_REMOVE = " removed";
	private static final String MESSAGE_ERROR = "Error: ";
	private static final String MESSAGE_INVALID_TYPE = "Please input an EVENT for blocking of timeslots";
	private static final String MESSAGE_INSUFFICIENT_SLOTS = "Insufficient slots entered for "
			+ "blocking of timeslots";
	private static final String MESSAGE_INVALID_SLOTS = "Invalid slots entered for blocking of timeslots";

	private MultipleSlot _block;
	private LogicData _data;
	private Task _newTask;

	/**
	 * Default constructor for creating a new BlockSlot command.
	 */
	public BlockSlots() {

	}

	/**
	 * Constructor for adding of a newTask with multiple slots.
	 * 
	 * @param newTask
	 *            new Task object consisting of all details.
	 */
	public BlockSlots(Task newTask) {
		_newTask = newTask;
	}

	/**
	 * Execute method for blocking of slots which adds new Task to Urgenda.
	 * 
	 * @throws LogicException
	 *             Exception is thrown when the blocks added are invalid blocks
	 *             or when task is invalid.
	 */
	public String execute() throws LogicException {
		_data = LogicData.getInstance();
		updateSlot();
		setTaskDetails();
		addBlockTask();
		return MESSAGE_BLOCK + taskMessageWithMulti(_newTask) + MESSAGE_ADDED;
	}

	/*
	 * Adds the block task to Urgenda and sets necessary settings.
	 */
	private void addBlockTask() {
		_data.addTask(_newTask);
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		_data.setTaskPointer(_newTask);
		_data.clearShowMoreTasks();
		_data.toggleShowMoreTasks(_newTask);
	}

	/*
	 * Sets all the details for the new Task. Checks if task is valid type.
	 */
	private void setTaskDetails() throws LogicException {
		checkTaskType();
		_newTask.setId(_data.getCurrentId());
		_data.updateCurrentId();
		LocalDateTime now = LocalDateTime.now();
		_newTask.setDateAdded(now);
		_newTask.setDateModified(now);
		_data.updateMultipleSlot(_newTask);
	}

	/*
	 * Checks if the task for blocking is an event type task. Throws
	 * LogicException if invalid.
	 */
	private void checkTaskType() throws LogicException {
		if (_newTask.getTaskType() != Task.Type.EVENT) {
			throw new LogicException(MESSAGE_ERROR + MESSAGE_INVALID_TYPE);
		}
	}

	/*
	 * Updates the slot given from parser and sorts the slots accordingly.
	 * Throws LogicException if insufficient or invalid slots.
	 */
	private void updateSlot() throws LogicException {
		_block = _newTask.getSlot();
		checkValidBlock();
		_block.sortSlots();
		DateTimePair time = _block.getNextSlot();
		_block.removeNextSlot();
		_newTask.setStartTime(time.getDateTime1());
		_newTask.setEndTime(time.getDateTime2());
		_newTask.updateTaskType();
		checkEmptyBlock();
	}

	/*
	 * Checks for valid blocks given in the task. Throws exception if invalid to
	 * prevent the adding of invalid task.
	 */
	private void checkValidBlock() throws LogicException {
		if (_block == null || _block.isEmpty()) {
			throw new LogicException(MESSAGE_ERROR + MESSAGE_INSUFFICIENT_SLOTS);
		} else if (!isValidBlock(_block)) {
			throw new LogicException(MESSAGE_ERROR + MESSAGE_INVALID_SLOTS);
		}
	}

	/*
	 * Returns if all the blocks within are valid blocks.
	 */
	private boolean isValidBlock(MultipleSlot block) {
		ArrayList<DateTimePair> slots = block.getSlots();
		if (slots == null) {
			return false;
		} else if (slots.isEmpty()) {
			return false;
		} else {
			return hasValidSlots(slots);
		}
	}

	/*
	 * Goes through all slots within. Defensive check to ensure that no blank
	 * slots are included.
	 */
	private boolean hasValidSlots(ArrayList<DateTimePair> slots) {
		for (DateTimePair pair : slots) {
			if (pair.getDateTime1() == null || pair.getDateTime2() == null) {
				return false;
			} else if (pair.getDateTime2().isBefore(pair.getDateTime1())
					|| pair.getDateTime1().equals(pair.getDateTime2())) {
				return false;
			}
		}
		return true;
	}

	/*
	 * Checks if the block is empty. If empty exception is thrown to prevent
	 * code from adding.
	 */
	private void checkEmptyBlock() throws LogicException {
		if (_block.isEmpty()) {
			throw new LogicException(MESSAGE_ERROR + MESSAGE_INSUFFICIENT_SLOTS);
		}
	}

	/**
	 * Setter for the new Block Task to be added.
	 * 
	 * @param newTask
	 *            New Task that is filled with multiple slots.
	 */
	public void setNewTask(Task newTask) {
		_newTask = newTask;
	}

	/**
	 * Undo function for BlockSlots which removes the added task.
	 */
	public String undo() {
		_data.deleteTask(_newTask);
		return taskMessageWithMulti(_newTask) + MESSAGE_REMOVE;
	}

	/**
	 * Redo function for BlockSlots which adds back the new task.
	 */
	public String redo() {
		_newTask.setDateModified(LocalDateTime.now());
		_data.addTask(_newTask);
		_data.setTaskPointer(_newTask);
		return MESSAGE_BLOCK + taskMessageWithMulti(_newTask) + MESSAGE_ADDED;
	}

}
```
###### src\urgenda\command\Command.java
``` java
package urgenda.command;

import java.time.LocalDateTime;
import java.util.ArrayList;

import urgenda.util.DateTimePair;
import urgenda.util.LogicException;
import urgenda.util.MultipleSlot;
import urgenda.util.Task;

/**
 * Command abstract class for implementation of subsequent command classes. Used
 * for the command pattern. Includes all different versions of generating task
 * messages which can be used across all inherited classes.
 *
 */
public abstract class Command {

	private static final String MESSAGE_EVENT = "\"%1$s\" on %2$d/%3$d %4$02d:%5$02d - "
			+ "%6$d/%7$d %8$02d:%9$02d";
	private static final String MESSAGE_EVENT_VENUE = "\"%1$s\" at %2$s on %3$d/%4$d %5$02d:%6$02d - "
			+ "%7$d/%8$d %9$02d:%10$02d";
	private static final String MESSAGE_EVENT_DATETIME = ", %1$d/%2$d, %3$02d:%4$02d - %5$02d:%6$02d";
	private static final String MESSAGE_FLOAT = "\"%1$s\"";
	private static final String MESSAGE_FLOAT_VENUE = "\"%1$s\" at %2$s";
	private static final String MESSAGE_DEADLINE = "\"%1$s\" by %2$d/%3$d, %4$02d:%5$02d";
	private static final String MESSAGE_DEADLINE_VENUE = "\"%1$s\" at %2$s by %3$d/%4$d, %5$02d:%6$02d";

	/**
	 * Abstract method for execution of specific command.
	 * 
	 * @return String of the feedback to the user.
	 * @throws LogicException
	 *             When the command on the task is invalid.
	 */
	public abstract String execute() throws LogicException;

	/**
	 * Generates a task message for the task with multiple slots.
	 * 
	 * @param task
	 *            Task object for generating of message.
	 * @return Feedback for given task.
	 */
	public String taskMessageWithMulti(Task task) {
		String feedback = taskMessage(task);
		if (task.getSlot() != null) {
			feedback += additionalTimings(task.getSlot());
		}
		return feedback;
	}

	/**
	 * Generate task message for the task with location. Used when location may
	 * be edited.
	 * 
	 * @param task
	 *            Task object for generating of message.
	 * @return Feedback for given task.
	 */
	public String taskMessageWithLocation(Task task) {
		Task.Type taskType = task.getTaskType();
		String feedback = null;
		if (task.getLocation() == null || task.getLocation().equals("")) {
			feedback = taskMessage(task);
		} else {
			feedback = generateTaskMessageWithVenue(task, taskType, feedback);
		}
		if (task.getSlot() != null) {
			feedback += additionalTimings(task.getSlot());
		}
		return feedback;
	}

	/*
	 * Returns the task message with location placed within.
	 */
	private String generateTaskMessageWithVenue(Task task, Task.Type taskType, String feedback) {
		switch (taskType) {
		case EVENT :
			feedback = String.format(MESSAGE_EVENT_VENUE, task.getDesc(), task.getLocation(),
					task.getStartTime().getDayOfMonth(), task.getStartTime().getMonthValue(),
					task.getStartTime().getHour(), task.getStartTime().getMinute(),
					task.getEndTime().getDayOfMonth(), task.getEndTime().getMonthValue(),
					task.getEndTime().getHour(), task.getEndTime().getMinute());
			break;
		case FLOATING :
			feedback = String.format(MESSAGE_FLOAT_VENUE, task.getDesc(), task.getLocation());
			break;
		case DEADLINE :
			feedback = String.format(MESSAGE_DEADLINE_VENUE, task.getDesc(), task.getLocation(),
					task.getEndTime().getDayOfMonth(), task.getEndTime().getMonthValue(),
					task.getEndTime().getHour(), task.getEndTime().getMinute());
			break;
		}
		return feedback;
	}

	/**
	 * For generating of generic task message, regardless of location and
	 * multipleslots.
	 * 
	 * @param task
	 *            Task object for generating of message.
	 * @return Feedback for given task.
	 */
	public String taskMessage(Task task) {
		Task.Type taskType = task.getTaskType();
		String feedback = null;
		switch (taskType) {
		case EVENT :
			feedback = String.format(MESSAGE_EVENT, task.getDesc(), task.getStartTime().getDayOfMonth(),
					task.getStartTime().getMonthValue(), task.getStartTime().getHour(),
					task.getStartTime().getMinute(), task.getEndTime().getDayOfMonth(),
					task.getEndTime().getMonthValue(), task.getEndTime().getHour(),
					task.getEndTime().getMinute());
			break;
		case FLOATING :
			feedback = String.format(MESSAGE_FLOAT, task.getDesc());
			break;
		case DEADLINE :
			feedback = String.format(MESSAGE_DEADLINE, task.getDesc(), task.getEndTime().getDayOfMonth(),
					task.getEndTime().getMonthValue(), task.getEndTime().getHour(),
					task.getEndTime().getMinute());
			break;
		}
		return feedback;
	}

	/*
	 * Generates the feedback for the block within the given block from the
	 * task.
	 */
	private String additionalTimings(MultipleSlot block) {
		String feedback = "";
		ArrayList<DateTimePair> slots = block.getSlots();
		for (DateTimePair pair : slots) {
			LocalDateTime start = pair.getEarlierDateTime();
			LocalDateTime end = pair.getLaterDateTime();
			feedback += String.format(MESSAGE_EVENT_DATETIME, start.getDayOfMonth(), start.getMonthValue(),
					start.getHour(), start.getMinute(), end.getHour(), end.getMinute());
		}
		return feedback;
	}
}
```
###### src\urgenda\command\Complete.java
``` java
package urgenda.command;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;

import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * Complete command for completing of a given task in Urgenda.
 *
 */
public class Complete extends TaskCommand {

	private static UrgendaLogger logger = UrgendaLogger.getInstance();

	private static final String MESSAGE_DONE = "Done ";
	private static final String MESSAGE_UNDONE = " unmarked from done";
	private static final String MESSAGE_MULTIPLE_FOUND = "Multiple tasks with description \"%1$s\" found";
	private static final String MESSAGE_NO_COMPLETE_MATCH = "No matches found to complete";
	private static final String MESSAGE_NUM_DONE = "%1$s tasks have been marked as done: ";
	private static final String MESSAGE_NUM_UNDONE = "%1$s have been unmarked from done: ";
	private static final String MESSAGE_TASK_DESC = "\"%1$s\", ";
	private static final String COMMA_DELIMITER = ",";

	private String _desc;
	private ArrayList<Integer> _positions;
	private ArrayList<Task> _completedTasks;
	private LogicData _data;

	/**
	 * Executes the command of Complete, which completes the selected task(s).
	 * 
	 * @throws LogicException
	 *             When there is no match or multiple matches found for
	 *             completion.
	 */
	public String execute() throws LogicException {
		logger.getLogger().warning("Can cause exception");
		_data = LogicData.getInstance();
		findMatchingTask();
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		checkForValidTask();
		updateTasks();
		return completeFeedback();
	}

	/*
	 * Updates the state of the task(s) being completed.
	 */
	private void updateTasks() {
		completeTasks(true);
		updateDateModified(_completedTasks);
		_data.deleteTasks(_completedTasks);
		_data.addArchive(_completedTasks);
	}

	/*
	 * Checks if the task(s) is a valid task.
	 */
	private void checkForValidTask() throws LogicException {
		if (_completedTasks == null || _completedTasks.isEmpty()) {
			logger.getLogger().severe("Exception(No complete match) thrown");
			throw new LogicException(MESSAGE_NO_COMPLETE_MATCH);
		}
	}

	/*
	 * Finds all possible matches to the given input. Throws exception if
	 * multiple matches were found.
	 */
	private void findMatchingTask() throws LogicException {
		ArrayList<Task> matches;
		if (_desc != null) {
			matches = _data.findMatchingDesc(_desc);
			if (matches.size() == 1) {
				_completedTasks = matches;
			} else if (matches.size() > 1) {
				setExceptionState(matches);
				throw new LogicException(String.format(MESSAGE_MULTIPLE_FOUND, _desc));
			} // else matches has no match hence _completedTasks remains null
		} else if (_positions != null && _positions.size() != 0) {
			Collections.sort(_positions);
			_completedTasks = _data.findMatchingPosition(_positions);
		}
	}

	/*
	 * Sets the exception state in the scenario when multiple matches is found
	 * for description.
	 */
	private void setExceptionState(ArrayList<Task> matches) {
		_data.clearDisplays();
		_data.setDisplays(matches);
		_data.setCurrState(LogicData.DisplayState.MULTIPLE_COMPLETE);
		logger.getLogger().severe("Exception(Multiple complete) thrown");
	}

	/*
	 * Generates the feedback for completion of task(s).
	 */
	private String completeFeedback() {
		if (_completedTasks.size() == 1) {
			return MESSAGE_DONE + taskMessageWithMulti(_completedTasks.get(0)) + "!";
		} else {
			String feedback = String.format(MESSAGE_NUM_DONE, _completedTasks.size());
			feedback += multipleTaskFeedback();
			return feedback;
		}
	}

	/*
	 * Generates the feedback for the situation of multiple completions.
	 */
	private String multipleTaskFeedback() {
		String feedback = "";
		for (Task task : _completedTasks) {
			feedback += String.format(MESSAGE_TASK_DESC, task.getDesc());
		}
		feedback = feedback.substring(0, feedback.lastIndexOf(COMMA_DELIMITER));
		return feedback;
	}

	/*
	 * Completes all the tasks within completedTasks.
	 */
	private void completeTasks(boolean isComplete) {
		for (Task task : _completedTasks) {
			task.setIsCompleted(isComplete);
			task.setDateModified(LocalDateTime.now());
		}
	}

	/**
	 * Undo method for complete which makes the task undone.
	 */
	public String undo() {
		completeTasks(false);
		updateDateModified(_completedTasks);
		_data.removeArchive(_completedTasks);
		_data.addTasks(_completedTasks);
		_data.setTaskPointer(_completedTasks.get(0));
		return uncompletedFeedback();
	}

	/*
	 * Generates the feedback for uncompleting of the task.
	 */
	private String uncompletedFeedback() {
		if (_completedTasks.size() == 1) {
			return taskMessageWithMulti(_completedTasks.get(0)) + MESSAGE_UNDONE + "!";
		} else {
			String feedback = String.format(MESSAGE_NUM_UNDONE, _completedTasks.size());
			feedback += multipleTaskFeedback();
			return feedback;
		}
	}

	/**
	 * Redo method for completing the tasks again.
	 */
	public String redo() {
		updateTasks();
		return completeFeedback();
	}

	/*
	 * Updates all date modified for tasks.
	 */
	private void updateDateModified(ArrayList<Task> tasks) {
		LocalDateTime now = LocalDateTime.now();
		for (Task task : tasks) {
			task.setDateModified(now);
		}
	}

	/**
	 * Setter for the description for completion.
	 * 
	 * @param desc
	 *            String of the description of task to be completed.
	 */
	public void setDesc(String desc) {
		_desc = desc;
	}

	/**
	 * Setter for positions for completion.
	 * 
	 * @param positions
	 *            ArrayList of Integer positions for completion.
	 */
	public void setPositions(ArrayList<Integer> positions) {
		_positions = positions;
	}

}
```
###### src\urgenda\command\Confirm.java
``` java
package urgenda.command;

import java.time.LocalDateTime;

import urgenda.logic.LogicData;
import urgenda.util.DateTimePair;
import urgenda.util.LogicException;
import urgenda.util.MultipleSlot;
import urgenda.util.Task;

/**
 * Confirm class for confirming of a blocked slot previously blocked in Urgenda.
 *
 */
public class Confirm extends TaskCommand {

	private static final String MESSAGE_NO_POSITION = "Invalid position to confirm";
	private static final String MESSAGE_INVALID_TIME = "Invalid confirm time";
	private static final String MESSAGE_NO_MULTIPLE = "Task does not have multiple slots";
	private static final String MESSAGE_NO_MATCH = "No matches found for %1$d/%2$d, %3$02d:%4$02d - "
			+ "%5$d/%6$d, %7$02d:%8$02d";
	private static final String MESSAGE_CONFIRM = "Confirmed ";
	private static final String MESSAGE_BLOCK = "Blocked ";

	private Integer _id;
	private DateTimePair _confirmed;
	private LogicData _data;
	private Task _prevTask;
	private Task _confirmedTask;

	/**
	 * Execute method for confirm. Confirms the blocked slot if valid.
	 * 
	 * @throws LogicException
	 *             When there is no match for the confirmed slot or invalid task
	 *             to confirm.
	 */
	public String execute() throws LogicException {
		_data = LogicData.getInstance();
		checkValidTime();
		findMatchingTask();
		checkValidTask();
		return updateConfirmedTask();
	}

	/*
	 * Updates the task with the confirmed slot.
	 */
	private String updateConfirmedTask() throws LogicException {
		_confirmedTask = new Task(_prevTask);
		DateTimePair currPair = new DateTimePair(_confirmedTask.getStartTime(), _confirmedTask.getEndTime());
		if (currPair.equals(_confirmed)) {
			updateTask();
			return MESSAGE_CONFIRM + taskMessageWithMulti(_confirmedTask);
		} else {
			return checkSlotsForMatch();
		}
	}

	/*
	 * Updates the task in Urgenda to be replaced with the new confirmed task.
	 */
	private void updateTask() {
		_confirmedTask.setSlot(null);
		_data.deleteTask(_prevTask);
		_data.addTask(_confirmedTask);
		_data.setTaskPointer(_confirmedTask);
		_data.clearShowMoreTasks();
	}

	/*
	 * Iterates through all possible slots within the task to check if the slot
	 * is matching given time slot.
	 */
	private String checkSlotsForMatch() throws LogicException {
		DateTimePair currPair;
		MultipleSlot tempSlot = new MultipleSlot(_confirmedTask.getSlot());
		while (tempSlot != null && !(tempSlot.isEmpty())) {
			currPair = tempSlot.getNextSlot();
			tempSlot.removeNextSlot();
			if (currPair.equals(_confirmed)) {
				updateConfirmedSlot(currPair);
				return MESSAGE_CONFIRM + taskMessageWithMulti(_confirmedTask);
			}
		}
		_data.setTaskPointer(_prevTask);
		throw new LogicException(String.format(MESSAGE_NO_MATCH, _confirmed.getEarlierDateTime().getDayOfMonth(),
				_confirmed.getEarlierDateTime().getMonthValue(), _confirmed.getEarlierDateTime().getHour(),
				_confirmed.getEarlierDateTime().getMinute(), _confirmed.getLaterDateTime().getDayOfMonth(),
				_confirmed.getLaterDateTime().getMonthValue(), _confirmed.getLaterDateTime().getHour(),
				_confirmed.getLaterDateTime().getMinute()));
	}

	/*
	 * Updates the confirmed slot details with the new details.
	 */
	private void updateConfirmedSlot(DateTimePair currPair) {
		_confirmedTask.setStartTime(currPair.getEarlierDateTime());
		_confirmedTask.setEndTime(currPair.getLaterDateTime());
		updateDateModified();
		updateTask();
	}

	/*
	 * Checks if the task is a valid task based on the input given.
	 */
	private void checkValidTask() throws LogicException {
		if (_prevTask == null) {
			throw new LogicException(MESSAGE_NO_POSITION);
		} else if (_prevTask.getSlot() == null) {
			_data.setTaskPointer(_prevTask);
			throw new LogicException(MESSAGE_NO_MULTIPLE);
		}
	}

	/*
	 * Sets the task to match the position given.
	 */
	private void findMatchingTask() throws LogicException {
		if (_id == null) {
			throw new LogicException(MESSAGE_NO_POSITION);
		} else {
			_prevTask = _data.findMatchingPosition(_id.intValue());
		}
	}

	/*
	 * Checks if the given time is a valid range.
	 */
	private void checkValidTime() throws LogicException {
		if (_confirmed == null) {
			throw new LogicException(MESSAGE_INVALID_TIME);
		} else if (_confirmed.getEarlierDateTime() == null || _confirmed.getLaterDateTime() == null) {
			throw new LogicException(MESSAGE_INVALID_TIME);
		}
	}

	private void updateDateModified() {
		_prevTask.setDateModified(LocalDateTime.now());
		_confirmedTask.setDateModified(LocalDateTime.now());

	}

	/**
	 * Undo method for confirming of slots. Returns the task to the previous
	 * version of blocked task.
	 */
	public String undo() {
		updateDateModified();
		_data.deleteTask(_confirmedTask);
		_data.addTask(_prevTask);
		_data.setTaskPointer(_prevTask);
		return MESSAGE_BLOCK + taskMessageWithMulti(_prevTask);
	}

	/**
	 * Redo method for confirming of slots. Reconfirms the task to the confirmed
	 * slot.
	 */
	public String redo() {
		updateDateModified();
		_data.deleteTask(_prevTask);
		_data.addTask(_confirmedTask);
		_data.setTaskPointer(_confirmedTask);
		return MESSAGE_CONFIRM + taskMessageWithMulti(_confirmedTask);
	}

	/**
	 * Setter method for setting the location of the task to be confirmed.
	 * 
	 * @param id
	 *            Current location of the task to be confirmed.
	 */
	public void setId(int id) {
		_id = Integer.valueOf(id);
	}

	/**
	 * Sets the time slot to be confirmed.
	 * 
	 * @param start
	 *            LocalDateTime of the start time of confirm.
	 * @param end
	 *            LocalDateTime of the end time of the confirm.
	 */
	public void setTimeSlot(LocalDateTime start, LocalDateTime end) {
		_confirmed = new DateTimePair(start, end);
	}

}
```
###### src\urgenda\command\DeleteTask.java
``` java
package urgenda.command;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;

import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * DeleteTask class for the deletion of tasks in Urgenda.
 *
 */
public class DeleteTask extends TaskCommand {

	private static UrgendaLogger logger = UrgendaLogger.getInstance();

	private static final String MESSAGE_ADDED = " added";
	private static final String MESSAGE_REMOVE = " removed";
	private static final String MESSAGE_NO_DELETE_MATCH = "No matches found to delete";
	private static final String MESSAGE_MULTIPLE_FOUND = "Multiple tasks with description \"%1$s\" found";
	private static final String MESSAGE_NUM_REMOVED = "%1$s tasks have been removed: ";
	private static final String MESSAGE_NUM_ADDED = "%1$s tasks have been added: ";
	private static final String MESSAGE_TASK_DESC = "\"%1$s\", ";
	private static final String COMMA_DELIMITER = ",";

	private String _desc;
	private ArrayList<Integer> _positions;
	private ArrayList<Task> _deletedTasks;
	private LogicData _data;

	/**
	 * Execute method for deletion of tasks which removes the task from Urgenda.
	 * 
	 * @throws LogicException
	 *             When there are no matches found or multiple matches found.
	 */
	public String execute() throws LogicException {
		logger.getLogger().warning("Can cause exception");
		_data = LogicData.getInstance();
		findMatchingTask();
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		checkValidTask();
		updateTask();
		return deleteFeedback();
	}

	/*
	 * Updates the task(s) in Urgenda.
	 */
	private void updateTask() {
		updateDateModified(_deletedTasks);
		_data.deleteTasks(_deletedTasks);
		_data.clearShowMoreTasks();
	}

	/*
	 * Checks if the task(s) is not empty and not null.
	 */
	private void checkValidTask() throws LogicException {
		if (_deletedTasks == null || _deletedTasks.isEmpty()) {
			logger.getLogger().severe("Exception(No del match) thrown");
			throw new LogicException(MESSAGE_NO_DELETE_MATCH);
		}
	}

	/*
	 * Finds matching task based on the description or positions given.
	 */
	private void findMatchingTask() throws LogicException {
		if (_desc != null) {
			matchGivenDesc();
		} else if (_positions != null && _positions.size() != 0) {
			Collections.sort(_positions);
			_deletedTasks = _data.findMatchingPosition(_positions);
		}
	}

	/*
	 * Finds matching task based on the desciption given.
	 */
	private void matchGivenDesc() throws LogicException {
		ArrayList<Task> matches;
		matches = _data.findMatchingDesc(_desc);
		if (matches.size() == 1) {
			_deletedTasks = matches;
		} else if (matches.size() > 1) {
			setExceptionState(matches);
			throw new LogicException(String.format(MESSAGE_MULTIPLE_FOUND, _desc));
		}
	}

	/*
	 * Sets up the exception state due to multiple matches.
	 */
	private void setExceptionState(ArrayList<Task> matches) {
		_data.clearDisplays();
		_data.setDisplays(matches);
		_data.setCurrState(LogicData.DisplayState.MULTIPLE_DELETE);
		logger.getLogger().severe("Exception(Multiple delete) thrown");
	}

	/*
	 * Generates the feedback for deletion of task(s).
	 */
	private String deleteFeedback() {
		if (_deletedTasks.size() == 1) {
			return taskMessageWithMulti(_deletedTasks.get(0)) + MESSAGE_REMOVE;
		} else {
			String feedback = String.format(MESSAGE_NUM_REMOVED, _deletedTasks.size());
			feedback += multipleTaskFeedback();
			return feedback;
		}
	}

	/*
	 * Feedback for appending multiple deletion of tasks.
	 */
	private String multipleTaskFeedback() {
		String feedback = "";
		for (Task task : _deletedTasks) {
			feedback += String.format(MESSAGE_TASK_DESC, task.getDesc());
		}
		feedback = feedback.substring(0, feedback.lastIndexOf(COMMA_DELIMITER));
		return feedback;
	}

	/**
	 * Undo method of delete, which restores the deleted task(s) to Urgenda.
	 */
	public String undo() {
		updateDateModified(_deletedTasks);
		_data.addTasks(_deletedTasks);
		_data.setTaskPointer(_deletedTasks.get(0));
		return addFeedback();
	}

	/*
	 * Feedback for re-adding of the task(s) back into Urgenda from an undo.
	 */
	private String addFeedback() {
		if (_deletedTasks.size() == 1) {
			return taskMessageWithMulti(_deletedTasks.get(0)) + MESSAGE_ADDED;
		} else {
			String feedback = String.format(MESSAGE_NUM_ADDED, _deletedTasks.size());
			feedback += multipleTaskFeedback();
			return feedback;
		}
	}

	/**
	 * Redo method for DeleteTask. Deletes the task(s) again.
	 */
	public String redo() {
		updateDateModified(_deletedTasks);
		_data.deleteTasks(_deletedTasks);
		return deleteFeedback();
	}

	private void updateDateModified(ArrayList<Task> tasks) {
		LocalDateTime now = LocalDateTime.now();
		for (Task task : tasks) {
			task.setDateModified(now);
		}
	}

	/**
	 * Setter for the input description of the task to be deleted.
	 * 
	 * @param desc
	 *            String description of the task for deletion.
	 */
	public void setDesc(String desc) {
		_desc = desc;
	}

	/**
	 * Setter for the positions of the task(s) to be deleted.
	 * 
	 * @param positions
	 *            ArrayList of Integers containing all the positions for
	 *            deletion.
	 */
	public void setPositions(ArrayList<Integer> positions) {
		_positions = positions;
	}

}
```
###### src\urgenda\command\FindFree.java
``` java
package urgenda.command;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Deque;

import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.Task;

/**
 * FindFree command for Urgenda. Responsible for finding all possible free time
 * between a given set of timings.
 *
 */
public class FindFree extends Command {

	private static final String MESSAGE_FREE_TIME = "Showing available time slots between "
			+ "%1$d/%2$d, %3$02d:%4$02d to %5$d/%6$d, %7$02d:%8$02d";
	private static final String MESSAGE_NO_FREE_TIME = "There are no available time between "
			+ "%1$d/%2$d, %3$02d:%4$02d to %5$d/%6$d, %7$02d:%8$02d";
	private static final String MESSAGE_INVALID_TIME_RANGE = "Invalid time range for finding available time";
	private static final String MESSAGE_HOURS = " hours ";
	private static final String MESSAGE_MINUTES = " minutes ";
	private static final String MESSAGE_SECONDS = " seconds ";
	private static final String MESSAGE_HOUR = " hour ";
	private static final String MESSAGE_MINUTE = " minute ";
	private static final String MESSAGE_SECOND = " second ";
	private static final String MESSAGE_24_HOURS = "24 hours";
	private static final int SINGLE_LIMITER = 1;

	private LogicData _data;

	private LocalDateTime _startOfRange;
	private LocalDateTime _endOfRange;

	/**
	 * Default Constructor for creating a FindFree command object.
	 */
	public FindFree() {

	}

	/**
	 * Constructor for creating a FindFree command object with a start and end
	 * timing.
	 * 
	 * @param start
	 *            LocalDateTime of the starting timing.
	 * @param end
	 *            LocalDateTime of the ending timing.
	 */
	public FindFree(LocalDateTime start, LocalDateTime end) {
		_startOfRange = start;
		_endOfRange = end;
	}

	/**
	 * Execute method for Finding free timings.
	 * 
	 * @throws LogicException
	 *             Throws exception when the end is before start or end time has
	 *             already passed.
	 */
	public String execute() throws LogicException {
		_data = LogicData.getInstance();
		checkAndUpdateRange();
		_data.clearShowMoreTasks();
		return findFreeTimings();
	}

	/*
	 * Finds all matching timings with the given timings Returns the feedback to
	 * user.
	 */
	private String findFreeTimings() {
		Task timeRange = createTimeTask(_startOfRange, _endOfRange);
		ArrayList<Task> matches = _data.overlappingTasks(timeRange);
		Collections.sort(matches, comparator);
		return generateFreeTimings(matches);
	}

	/*
	 * Generates all possible timings given the matches. Returns the generated
	 * feedback.
	 */
	private String generateFreeTimings(ArrayList<Task> matches) {
		Deque<LocalDateTime> freeTimes = new ArrayDeque<LocalDateTime>();
		if (matches.isEmpty()) {
			return setEmptyFindFreeState(freeTimes);
		} else {
			generateStartSlot(matches, freeTimes);
			addFreeTimeSlots(matches, freeTimes);
			generateEndSlot(freeTimes);
			return setFindFreeState(freeTimes);
		}
	}

	/*
	 * Uses the given timings to set display if there are no tasks given the
	 * time range.
	 */
	private String setEmptyFindFreeState(Deque<LocalDateTime> freeTimes) {
		_data.clearDisplays();
		freeTimes.addFirst(_startOfRange);
		freeTimes.addFirst(_endOfRange);
		ArrayList<Task> forDisplay = generateDisplayList(freeTimes);
		_data.setDisplays(forDisplay);
		_data.setCurrState(LogicData.DisplayState.FIND_FREE);
		return formatFeedback(MESSAGE_FREE_TIME);
	}

	/*
	 * Uses the free timings gathered to generate the display for setting.
	 */
	private String setFindFreeState(Deque<LocalDateTime> freeTimes) {
		// assert to ensure that the number of timings are even
		assert (freeTimes.size() % 2 == 0);
		if (freeTimes.isEmpty()) {
			_data.clearDisplays();
			_data.setCurrState(LogicData.DisplayState.FIND_FREE);
			return formatFeedback(MESSAGE_NO_FREE_TIME);
		} else {
			ArrayList<Task> forDisplay = generateDisplayList(freeTimes);
			_data.clearDisplays();
			_data.setDisplays(forDisplay);
			_data.setCurrState(LogicData.DisplayState.FIND_FREE);
			return formatFeedback(MESSAGE_FREE_TIME);
		}
	}

	private void generateEndSlot(Deque<LocalDateTime> freeTimes) {
		if (freeTimes.peekFirst().isBefore(_endOfRange)) {
			freeTimes.addFirst(_endOfRange);
		} else {
			freeTimes.removeFirst();
		}
	}

	/*
	 * Goes through all matches and checks whether the current timeslot in the
	 * deque overlaps/continues/creates a new empty slot.
	 */
	private void addFreeTimeSlots(ArrayList<Task> matches, Deque<LocalDateTime> freeTimes) {
		while (!matches.isEmpty()) {
			LocalDateTime start = matches.get(0).getStartTime();
			LocalDateTime end = matches.get(0).getEndTime();
			if (start.isAfter(freeTimes.peekFirst())) {
				freeTimes.addFirst(start);
				freeTimes.addFirst(end);
			} else if (end.isAfter(freeTimes.peekFirst())) {
				freeTimes.removeFirst();
				freeTimes.addFirst(end);
			}
			matches.remove(0);
		}
	}

	private void generateStartSlot(ArrayList<Task> matches, Deque<LocalDateTime> freeTimes) {
		if (matches.get(0).getStartTime().isAfter(_startOfRange)) {
			freeTimes.addFirst(_startOfRange);
			freeTimes.addFirst(matches.get(0).getStartTime());
		}
		freeTimes.addFirst(matches.get(0).getEndTime());
		matches.remove(0);
	}

	/*
	 * Checker method to ensure that the time range given is valid. Update if
	 * start time is before current time.
	 */
	private void checkAndUpdateRange() throws LogicException {
		LocalDateTime now = LocalDateTime.now();
		if (!_startOfRange.isBefore(_endOfRange) || _endOfRange.isBefore(now)) {
			_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			throw new LogicException(MESSAGE_INVALID_TIME_RANGE);
		} else if (_startOfRange.isBefore(now)) {
			_startOfRange = LocalDateTime.of(now.getYear(), now.getMonthValue(), now.getDayOfMonth(),
					now.getHour(), now.getMinute());
		}
	}

	private String formatFeedback(String feedback) {
		return String.format(feedback, _startOfRange.getDayOfMonth(), _startOfRange.getMonthValue(),
				_startOfRange.getHour(), _startOfRange.getMinute(), _endOfRange.getDayOfMonth(),
				_endOfRange.getMonthValue(), _endOfRange.getHour(), _endOfRange.getMinute());
	}

	/*
	 * Creates the Task list for display given the different free timings given
	 * in the deque.
	 */
	private ArrayList<Task> generateDisplayList(Deque<LocalDateTime> freeTimes) {
		ArrayList<Task> forDisplay = new ArrayList<Task>();
		while (!freeTimes.isEmpty()) {
			LocalDateTime start = freeTimes.removeLast();
			LocalDateTime end = freeTimes.removeLast();
			if (!start.toLocalDate().equals(end.toLocalDate()) && 
					!end.toLocalTime().equals(LocalTime.of(0, 0))) {
				LocalDateTime split = LocalDateTime.of(start.toLocalDate().plusDays(1), LocalTime.of(0, 0));
				forDisplay.add(createTimeTask(start, split));
				freeTimes.addLast(end);
				freeTimes.addLast(split);
			} else {
				forDisplay.add(createTimeTask(start, end));
			}
		}
		return forDisplay;
	}

	/*
	 * Creates the Task object to match the start and end timing given, sets
	 * desc as the duration of timing for display.
	 */
	private Task createTimeTask(LocalDateTime start, LocalDateTime end) {
		Task temp = new Task();
		setDurationDesc(start, end, temp);
		temp.setStartTime(start);
		temp.setEndTime(end);
		temp.setTaskType(Task.Type.EVENT);
		return temp;
	}

	/*
	 * Sets the duration according to the difference in timing.
	 */
	private void setDurationDesc(LocalDateTime start, LocalDateTime end, Task temp) {
		if (start.toLocalTime().equals(end.toLocalTime()) && start.toLocalDate().isBefore(end.toLocalDate())) {
			temp.setDesc(MESSAGE_24_HOURS);
		} else {
			temp.setDesc(timeDiff(start.toLocalTime(), end.toLocalTime()));
		}
	}

	/*
	 * Calculates the difference in time from the start to end.
	 */
	private String timeDiff(LocalTime start, LocalTime end) {
		Duration diff = generateDurationDiff(start, end);
		long hourDiff = diff.toHours();
		long minuteDiff = diff.toMinutes() - 60 * hourDiff;
		long secondDiff = diff.getSeconds() - 60 * minuteDiff - 3600 * hourDiff;
		return generateFeedbackMessage(hourDiff, minuteDiff, secondDiff);
	}

	private String generateFeedbackMessage(long hourDiff, long minuteDiff, long secondDiff) {
		String duration = "";
		if (hourDiff > 0) {
			duration += addTimeMessage(hourDiff, MESSAGE_HOUR, MESSAGE_HOURS);
		}
		if (minuteDiff > 0) {
			duration += addTimeMessage(minuteDiff, MESSAGE_MINUTE, MESSAGE_MINUTES);
		}
		if (secondDiff > 0) {
			duration += addTimeMessage(secondDiff, MESSAGE_SECOND, MESSAGE_SECONDS);
		}
		return duration;
	}

	private String addTimeMessage(long hourDiff, String singular, String plural) {
		String duration = "";
		duration += hourDiff;
		if (hourDiff == SINGLE_LIMITER) {
			duration += singular;
		} else {
			duration += plural;
		}
		return duration;
	}

	private Duration generateDurationDiff(LocalTime start, LocalTime end) {
		Duration diff;
		if (end.equals(LocalTime.of(0, 0))) {
			diff = Duration.between(start, LocalTime.of(23, 59, 59));
			diff = diff.plusSeconds(1);
		} else {
			diff = Duration.between(start, end);
		}
		return diff;
	}

	/**
	 * Setter method for the start timing of FindFree.
	 * 
	 * @param start
	 *            LocalDateTime of the starting time.
	 */
	public void setStartOfRange(LocalDateTime start) {
		_startOfRange = start;
	}

	/**
	 * Setter method for the end timing of FindFree.
	 * 
	 * @param end
	 *            LocalDateTime of the ending time.
	 */
	public void setEndOfRange(LocalDateTime end) {
		_endOfRange = end;
	}

	/*
	 * Comparator for comparing of the matches to sort them according to their
	 * start times.
	 */
	static Comparator<Task> comparator = new Comparator<Task>() {
		public int compare(final Task o1, final Task o2) {
			return o1.getStartTime().compareTo(o2.getStartTime());
		}
	};

}
```
###### src\urgenda\command\Invalid.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * Invalid command class is the object returned when the command is not valid
 * for the current state.
 * 
 */
public class Invalid extends Command {

	private static final String MESSAGE_INVALID_COMMAND = "\"%1$s\" is not a valid command";
	private static final String MESSAGE_INVALID_FINDFREE = "Invalid command for available time";
	private static final String MESSAGE_INVALID_ARCHIVE = "Invalid command for archived task";

	private String _command;
	private LogicData.DisplayState _state;

	/**
	 * Default constructor for an empty invalid command.
	 */
	public Invalid() {

	}

	/**
	 * Constructor for invalid command with a given string input.
	 * 
	 * @param command
	 *            Invalid command given by the user.
	 */
	public Invalid(String command) {
		_command = command;
	}

	/**
	 * Constructor for invalid command when a command is done on the incorrect
	 * state Urgenda is in.
	 * 
	 * @param state
	 *            Invalid state that Urgenda is in.
	 */
	public Invalid(LogicData.DisplayState state) {
		_state = state;
	}

	/**
	 * Execute method for Invalid command.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.INVALID_COMMAND);
		return generateFeedbackMessage();
	}

	private String generateFeedbackMessage() {
		if (_state == LogicData.DisplayState.FIND_FREE) {
			return MESSAGE_INVALID_FINDFREE;
		} else if (_state == LogicData.DisplayState.ARCHIVE) {
			return MESSAGE_INVALID_ARCHIVE;
		} else if (_command.equals("")) {
			return null;
		} else {
			return String.format(MESSAGE_INVALID_COMMAND, _command);
		}
	}

	/**
	 * Setter method for setting of the invalid command string.
	 * 
	 * @param command
	 *            Invalid command given by the user.
	 */
	public void setCommand(String command) {
		_command = command;
	}

}
```
###### src\urgenda\command\Postpone.java
``` java
package urgenda.command;

import java.time.LocalDateTime;

import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.MultipleSlot;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * Postpone command for postponing of tasks by the given timing.
 *
 */
public class Postpone extends TaskCommand {

	private static UrgendaLogger logger = UrgendaLogger.getInstance();

	private static final String MESSAGE_NO_MATCH = "Invalid task number. No matches found to postpone";
	private static final String MESSAGE_NO_TIME = "Invalid time entered";
	private static final String MESSAGE_POSTPONE_FLOATING = "Task has no time to postpone";
	private static final String MESSAGE_POSTPONED_TASK = "\"%1$s\" postponed by ";
	private static final String MESSAGE_YEARS = " year(s) ";
	private static final String MESSAGE_MONTHS = " month(s) ";
	private static final String MESSAGE_DAYS = " day(s) ";
	private static final String MESSAGE_HOURS = " hour(s) ";
	private static final String MESSAGE_MINUTES = " minute(s) ";
	private static final String MESSAGE_SECONDS = " second(s) ";

	private Task _prevTask;
	private Task _newTask;
	private Integer _id;
	private LogicData _data;

	private int _year;
	private int _month;
	private int _day;
	private int _hour;
	private int _minute;
	private int _second;

	/**
	 * Default Constructor for postpone which generates a command object that
	 * postpones by 0.
	 */
	public Postpone() {
		_year = 0;
		_month = 0;
		_day = 0;
		_hour = 0;
		_minute = 0;
		_second = 0;
	}

	/**
	 * Constructor for assigning the timings for postponing based on the units
	 * of time.
	 * 
	 * @param year
	 *            Number of years to postpone.
	 * @param month
	 *            Number of months to postpone.
	 * @param day
	 *            Number of days to postpone.
	 * @param hour
	 *            Number of hours to postpone.
	 * @param minute
	 *            Number of minutes to postpone.
	 * @param second
	 *            Number of seconds to postpone.
	 */
	public Postpone(int year, int month, int day, int hour, int minute, int second) {
		_year = year;
		_month = month;
		_day = day;
		_hour = hour;
		_minute = minute;
		_second = second;
	}

	/**
	 * Execution method of the Postpone command to postpone the task by the
	 * given duration.
	 * 
	 * @throws LogicException
	 *             throws exception when the timing is invalid, task is invalid,
	 *             or task is a deadline type.
	 */
	public String execute() throws LogicException {
		_data = LogicData.getInstance();
		findTaskToPostpone();
		checkValidPostponeTask();
		createPostponedTask();
		replacePostponedTask();
		return generateFeedback();
	}

	/*
	 * Updates the state of Urgenda with the new postponed task.
	 */
	private void replacePostponedTask() {
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		_data.deleteTask(_prevTask);
		_data.addTask(_newTask);
		_data.setTaskPointer(_newTask);
		_data.clearShowMoreTasks();
	}

	/*
	 * Creates a new task based on the previous task and adds the new time.
	 */
	private void createPostponedTask() {
		_prevTask.setDateModified(LocalDateTime.now());
		_newTask = new Task(_prevTask);
		checkSlots();
		addTime(_newTask);
	}

	/*
	 * Checks if the task/postpone timing is valid.
	 */
	private void checkValidPostponeTask() throws LogicException {
		if (!isValidPostpone()) {
			_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			logger.getLogger().severe("Exception no postpone time thrown");
			throw new LogicException(MESSAGE_NO_TIME);
		} else if (_prevTask == null) {
			_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			logger.getLogger().severe("Exception(No postpone match) thrown");
			throw new LogicException(MESSAGE_NO_MATCH);
		} else if (_prevTask.getTaskType() == Task.Type.FLOATING) {
			_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			logger.getLogger().severe("Exception postpone of floating thrown");
			throw new LogicException(MESSAGE_POSTPONE_FLOATING);
		}
	}

	/*
	 * Finds the task to postpone based on the given index.
	 */
	private void findTaskToPostpone() {
		if (_id != null && _id.intValue() != -1) {
			_prevTask = _data.findMatchingPosition(_id.intValue());
		}
	}

	/*
	 * Checks if postpone timing is valid, if all attributes are empty.
	 */
	private boolean isValidPostpone() {
		if (_year == 0 && _month == 0 && _day == 0 && _hour == 0 && _minute == 0 && _second == 0) {
			return false;
		} else {
			return true;
		}
	}

	/*
	 * Creates a new slot if the previous task has a slot.
	 */
	private void checkSlots() {
		if (_prevTask.getSlot() != null) {
			_newTask.setSlot(new MultipleSlot(_prevTask.getSlot()));
		}

	}

	/*
	 * Appends the feedback string of the different durations.
	 */
	private String generateFeedback() {
		String feedback = String.format(MESSAGE_POSTPONED_TASK, _prevTask.getDesc());
		if (_year > 0) {
			feedback += _year + MESSAGE_YEARS;
		}
		if (_month > 0) {
			feedback += _month + MESSAGE_MONTHS;
		}
		if (_day > 0) {
			feedback += _day + MESSAGE_DAYS;
		}
		if (_hour > 0) {
			feedback += _hour + MESSAGE_HOURS;
		}
		if (_minute > 0) {
			feedback += _minute + MESSAGE_MINUTES;
		}
		if (_second > 0) {
			feedback += _second + MESSAGE_SECONDS;
		}
		return feedback;
	}

	/*
	 * Adds timing to the task based on the task type.
	 */
	private void addTime(Task task) {
		if (task.getTaskType() == Task.Type.EVENT) {
			LocalDateTime start = task.getStartTime();
			start = addTime(start);
			task.setStartTime(start);
		}
		LocalDateTime end = task.getEndTime();
		end = addTime(end);
		task.setEndTime(end);
	}

	private LocalDateTime addTime(LocalDateTime time) {
		time = time.plusYears(_year);
		time = time.plusMonths(_month);
		time = time.plusDays(_day);
		time = time.plusHours(_hour);
		time = time.plusMinutes(_minute);
		time = time.plusSeconds(_second);
		return time;
	}

	/**
	 * Undo method for postpone where the postponed task is replaced back with
	 * the original task.
	 */
	public String undo() {
		_prevTask.setDateModified(LocalDateTime.now());
		_newTask.setDateModified(LocalDateTime.now());
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		_data.deleteTask(_newTask);
		_data.addTask(_prevTask);
		_data.setTaskPointer(_prevTask);
		return generateFeedback();
	}

	/**
	 * Redo method for postpone where the postponed task is added back and
	 * replaces the original task.
	 */
	public String redo() {
		_prevTask.setDateModified(LocalDateTime.now());
		_newTask.setDateModified(LocalDateTime.now());
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		_data.deleteTask(_prevTask);
		_data.addTask(_newTask);
		_data.setTaskPointer(_newTask);
		return generateFeedback();
	}

	/**
	 * Setter for the Year duration.
	 * 
	 * @param year
	 *            Number of years to postpone.
	 */
	public void setYear(int year) {
		if (year >= 0) {
			_year = year;
		}
	}

	/**
	 * Setter for the month duration.
	 * 
	 * @param year
	 *            Number of months to postpone.
	 */
	public void setMonth(int month) {
		if (month >= 0) {
			_month = month;
		}
	}

	/**
	 * Setter for the day duration.
	 * 
	 * @param year
	 *            Number of days to postpone.
	 */
	public void setDay(int day) {
		if (day >= 0) {
			_day = day;
		}
	}

	/**
	 * Setter for the hour duration.
	 * 
	 * @param year
	 *            Number of hours to postpone.
	 */
	public void setHour(int hour) {
		if (hour >= 0) {
			_hour = hour;
		}
	}

	/**
	 * Setter for the minute duration.
	 * 
	 * @param year
	 *            Number of minutes to postpone.
	 */
	public void setMinute(int minute) {
		if (minute >= 0) {
			_minute = minute;
		}
	}

	/**
	 * Setter for the second duration.
	 * 
	 * @param year
	 *            Number of seconds to postpone.
	 */
	public void setSecond(int second) {
		if (second >= 0) {
			_second = second;
		}
	}

	/**
	 * Setter for the Id of the task to be postponed.
	 * 
	 * @param id
	 *            task position to be postponed.
	 */
	public void setId(int id) {
		_id = Integer.valueOf(id);
	}

}
```
###### src\urgenda\command\Prioritise.java
``` java
package urgenda.command;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;

import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * Prioritise command for marking a task as important in Urgenda.
 *
 */
public class Prioritise extends TaskCommand {

	private static UrgendaLogger logger = UrgendaLogger.getInstance();

	private static final String MESSAGE_IMPORTANT = " marked as important";
	private static final String MESSAGE_UNIMPORTANT = " unmarked from important";
	private static final String MESSAGE_MULTIPLE_FOUND = "Multiple tasks with description \"%1$s\" found";
	private static final String MESSAGE_NO_MATCH = "No matches found to prioritise";
	private static final String MESSAGE_NUM = "Priority of %1$s tasks have been changed:\n";
	private static final String MESSAGE_TASK_DESC = "\"%1$s\", ";
	private static final String COMMA_DELIMITER = ",";

	private String _desc;
	private ArrayList<Integer> _positions;
	private ArrayList<Task> _tasks;
	private LogicData _data;

	/**
	 * Execute method of Prioritise for marking the task as important.
	 */
	public String execute() throws LogicException {
		_data = LogicData.getInstance();
		findMatchingTask();
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		checkValidTask();
		return togglePriority();
	}

	/*
	 * Toggles the priority of the Tasks that matches.
	 */
	private String togglePriority() {
		String feedback = toggleTasks();
		updateDateModified(_tasks);
		_data.setTaskPointer(_tasks.get(0));
		return feedback;
	}

	/*
	 * Checks if there are any matches for the tasks found based on the input.
	 * Throws exception if there are no tasks.
	 */
	private void checkValidTask() throws LogicException {
		if (_tasks == null || _tasks.isEmpty()) {
			logger.getLogger().severe("Exception(Pri no match) thrown");
			throw new LogicException(MESSAGE_NO_MATCH);
		}
	}

	/*
	 * Finds all matching tasks based on the description or position.
	 */
	private void findMatchingTask() throws LogicException {
		if (_desc != null) {
			matchGivenDesc();
		} else if (_positions != null && _positions.size() != 0) {
			Collections.sort(_positions);
			_tasks = _data.findMatchingPosition(_positions);
		}
	}

	/*
	 * Finds all matching tasks based on the description. Throws exception if
	 * there are multiple matches for description found.
	 */
	private void matchGivenDesc() throws LogicException {
		ArrayList<Task> matches;
		matches = _data.findMatchingDesc(_desc);
		if (matches.size() == 1) {
			_tasks = matches;
		} else if (matches.size() > 1) {
			setExceptionState(matches);
			throw new LogicException(String.format(MESSAGE_MULTIPLE_FOUND, _desc));
		}
	}

	/*
	 * Sets up the exception state for the multiple matches found based on desc.
	 */
	private void setExceptionState(ArrayList<Task> matches) {
		_data.clearDisplays();
		_data.setDisplays(matches);
		_data.setCurrState(LogicData.DisplayState.MULTIPLE_PRIORITISE);
		logger.getLogger().severe("Exception(Multi-pri) thrown");
	}

	/*
	 * Toggles the importance of tasks. If multiple tasks were selected, unless
	 * all of them were marked as important, only unimportant ones will be
	 * selected to mark as important.
	 */
	private String toggleTasks() {
		if (_tasks.size() == 1) {
			return toggleSingleTask();
		} else if (!isAllImportant()) {
			filterImportantTasks();
		}
		return toggleMultipleTasks();
	}

	/*
	 * Toggles the importance status of multiple tasks.
	 */
	private String toggleMultipleTasks() {
		String feedback = String.format(MESSAGE_NUM, _tasks.size());
		for (Task task : _tasks) {
			feedback += String.format(MESSAGE_TASK_DESC, task.getDesc());
			task.toggleImportant();
		}
		feedback = formatFeedbackWithImportance(feedback);
		return feedback;
	}

	/*
	 * Toggles the importance status of a single task.
	 */
	private String toggleSingleTask() {
		String feedback = String.format(MESSAGE_TASK_DESC, _tasks.get(0).getDesc());
		_tasks.get(0).toggleImportant();
		return formatFeedbackWithImportance(feedback);
	}

	/*
	 * Formats the feedback based on the importance of the tasks.
	 */
	private String formatFeedbackWithImportance(String feedback) {
		feedback = feedback.substring(0, feedback.lastIndexOf(COMMA_DELIMITER));
		feedback += getTaskImportance(_tasks.get(0));
		return feedback;
	}

	/*
	 * Removes all important tasks from the list.
	 */
	private void filterImportantTasks() {
		ArrayList<Task> removeTasks = new ArrayList<Task>();
		for (Task task : _tasks) {
			if (task.isImportant()) {
				removeTasks.add(task);
			}
		}
		_tasks.removeAll(removeTasks);
	}

	/*
	 * Checks for the importance of all the tasks in _tasks.
	 */
	private boolean isAllImportant() {
		for (Task task : _tasks) {
			if (!task.isImportant()) {
				return false;
			}
		}
		return true;
	}

	/**
	 * Undo method for undoing the prioritising of tasks.
	 */
	public String undo() {
		return togglePriority();
	}

	/**
	 * Redo method for redoing the prioritising of tasks.
	 */
	public String redo() {
		return togglePriority();
	}

	/*
	 * Generates the importance feedback for the task.
	 */
	private String getTaskImportance(Task task) {
		String feedback;
		if (task.isImportant()) {
			feedback = MESSAGE_IMPORTANT;
		} else {
			feedback = MESSAGE_UNIMPORTANT;
		}
		return feedback;
	}

	private void updateDateModified(ArrayList<Task> tasks) {
		LocalDateTime now = LocalDateTime.now();
		for (Task task : tasks) {
			task.setDateModified(now);
		}
	}

	/**
	 * Setter method for setting of the task to change its priority.
	 * 
	 * @param desc
	 *            Description of task to change priority.
	 */
	public void setDesc(String desc) {
		_desc = desc;
	}

	/**
	 * Setter method for setting of indexes of tasks to change their priority.
	 * 
	 * @param positions
	 *            ArrayList of Integer representing the location of tasks to
	 *            change priority.
	 */
	public void setPositions(ArrayList<Integer> positions) {
		_positions = positions;
	}

}
```
###### src\urgenda\command\Redo.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * Redo command for the redo function of Urgenda.
 *
 */
public class Redo extends Command {

	private static final String MESSAGE_REDO = "Redo: ";

	/**
	 * Execute method for Redo which sets the state for redoing of command.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		return MESSAGE_REDO;
	}

}
```
###### src\urgenda\command\SetDirectory.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;
import urgenda.util.InvalidFolderException;
import urgenda.util.StorageException;

/**
 * SetDirectory Command for changing of saving directory in Urgenda.
 *
 */
public class SetDirectory extends Command {

	private static final String MESSAGE_CHANGED_DIRECTORY = "Your tasks will now be saved in \"%1$s\"";
	private static final String MESSAGE_INVALID_DIRECTORY = "Invalid file directory";

	private String _newPath;

	/**
	 * Constructor which has the new path for saving of Urgenda data files.
	 * 
	 * @param path
	 *            New path directory for saving.
	 */
	public SetDirectory(String path) {
		_newPath = path;
	}

	/**
	 * Execute method for changing of saving path directory.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		return changeUrgendaDirectory(data);
	}

	/*
	 * Changes the saving directory.
	 */
	private String changeUrgendaDirectory(LogicData data) {
		if (_newPath == null || _newPath.equals("")) {
			return MESSAGE_INVALID_DIRECTORY;
		}
		try {
			data.changeDirectory(_newPath);
		} catch (StorageException e) {
			data.reinitialiseStorage();
			return e.getMessage();
		} catch (InvalidFolderException e) {
			return e.getMessage();
		}
		return String.format(MESSAGE_CHANGED_DIRECTORY, _newPath.toUpperCase());
	}

}
```
###### src\urgenda\command\ShowDetails.java
``` java
package urgenda.command;

import java.util.ArrayList;
import java.util.Collections;

import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.Task;

/**
 * ShowDetails command is for showing more of the selected task(s) in Urgenda.
 *
 */
public class ShowDetails extends Command {

	private static final String MESSAGE_NO_SHOW_MATCH = "Invalid position(s) to showmore details";
	private static final String MESSAGE_SHOWING_MORE = "Showing more details for \"%1$s\"";
	private static final String MESSAGE_SHOWING_LESS = "Showing less details for \"%1$s\"";
	private static final String MESSAGE_MORE_TASKS = ", \"%1$s\"";
	private static final String MESSAGE_NUM = "Changed showing details for %1$s tasks";

	private ArrayList<Integer> _positions;
	private ArrayList<Task> _tasks;
	private LogicData _data;

	/**
	 * Execute method for ShowDetails which shows more details of the task(s)
	 * given.
	 */
	public String execute() throws LogicException {
		_data = LogicData.getInstance();
		// Does not change the previous state
		findMatches();
		return toggleShowDetails();
	}

	/*
	 * Toggles the showmore state of each task. Throws exception if there are no
	 * tasks.
	 */
	private String toggleShowDetails() throws LogicException {
		if (_tasks == null || _tasks.isEmpty()) {
			throw new LogicException(MESSAGE_NO_SHOW_MATCH);
		} else {
			_data.setTaskPointer(_tasks.get(0));
			return toggleTasks();
		}
	}

	/*
	 * Find matches for the the task(s) based on the positions given.
	 */
	private void findMatches() {
		if (_positions != null && _positions.size() != 0) {
			Collections.sort(_positions);
			_tasks = _data.findMatchingPosition(_positions);
		}
	}

	/*
	 * Toggles the showmore state of all task(s) given. If multiple tasks were
	 * selected, unless all of them were showing more, only tasks that are not
	 * showing more will be selected to showmore.
	 */
	private String toggleTasks() {
		if (_tasks.size() == 1) {
			_data.toggleShowMoreTasks(_tasks.get(0));
			return showMoreFeedback();
		} else if (!isAllShowMore()) {
			// remove tasks that are already showing more
			removeShowMoreTasks();
		}
		return toggleRemainingTasks();
	}

	private String toggleRemainingTasks() {
		for (Task task : _tasks) {
			_data.toggleShowMoreTasks(task);
		}
		return showMoreFeedback();
	}

	private void removeShowMoreTasks() {
		ArrayList<Task> removeTasks = new ArrayList<Task>();
		for (Task task : _tasks) {
			if (_data.isShowingMore(task)) {
				removeTasks.add(task);
			}
		}
		_tasks.removeAll(removeTasks);
	}

	private boolean isAllShowMore() {
		for (Task task : _tasks) {
			if (!_data.isShowingMore(task)) {
				return false;
			}
		}
		return true;
	}

	/*
	 * Generates the feedback for showing more based on the number of tasks.
	 */
	private String showMoreFeedback() {
		if (_tasks.size() == 1) {
			return checkShowMore(_tasks.get(0));
		} else {
			String feedback = String.format(MESSAGE_NUM, _tasks.size()) + "\n" + checkShowMore(_tasks.get(0));
			_tasks.remove(0);
			for (Task task : _tasks) {
				feedback += String.format(MESSAGE_MORE_TASKS, task.getDesc());
			}
			return feedback;
		}
	}

	private String checkShowMore(Task task) {
		if (_data.isShowingMore(task)) {
			return String.format(MESSAGE_SHOWING_MORE, task.getDesc());
		} else {
			return String.format(MESSAGE_SHOWING_LESS, task.getDesc());
		}
	}

	/**
	 * Setter method for adding positions to be selected for showmore.
	 * 
	 * @param positions
	 *            ArrayList of Integer positions representing the location of
	 *            tasks to showmore.
	 */
	public void setPosition(ArrayList<Integer> positions) {
		_positions = positions;
	}

}
```
###### src\urgenda\command\TaskCommand.java
``` java
package urgenda.command;

import java.time.LocalDateTime;

import urgenda.util.LogicException;
import urgenda.util.Task;

/**
 * TaskCommand class for commands dealing with tasks and are able to be
 * undone/redone. Consists of a checker method to ensure that tasks are valid.
 *
 */
public abstract class TaskCommand extends Command {

	private static final String ERROR_NO_DESC = "Task has no description";
	private static final String ERROR_MISSING_START_TIME = "Task has missing start time";
	private static final String ERROR_MISSING_END_TIME = "Task has missing end time";
	private static final String ERROR_EXTRA_START_TIME = "Task has extra start time";
	private static final String ERROR_EXTRA_END_TIME = "Task has extra end time";
	private static final String ERROR_END_BEFORE_START = "Task start time is after end time";
	private static final String ERROR_SAME_START_END = "Task has same start and end time";
	private static final String ERROR_INVALID_TASK_TYPE = "Invalid task entered";

	/**
	 * Undo abstract method for individual subcommands to implement their undo.
	 * 
	 * @return String feedback of the undo method.
	 */
	public abstract String undo();

	/**
	 * Redo abstract method for individual subcommands to implement their redo.
	 * 
	 * @return String feedback of the redo method.
	 */
	public abstract String redo();

	/**
	 * Method for checking if the given task is valid.
	 * 
	 * @param task
	 *            Task for checking.
	 * @throws LogicException
	 *             Throws exception if the task does not contain valid details.
	 */
	public void checkTaskValidity(Task task) throws LogicException {
		checkForEmptyDesc(task);
		checkTaskType(task);
	}

	/*
	 * Checks according to the task type.
	 */
	private void checkTaskType(Task task) throws LogicException {
		LocalDateTime start = task.getStartTime();
		LocalDateTime end = task.getEndTime();
		if (task.getTaskType() == Task.Type.DEADLINE) {
			checkDeadlineTime(start, end);
		} else if (task.getTaskType() == Task.Type.EVENT) {
			checkEventTime(start, end);
		} else if (task.getTaskType() == Task.Type.FLOATING) {
			checkFloatingTime(start, end);
		} else { // Invalid task type
			throw new LogicException(ERROR_INVALID_TASK_TYPE);
		}
	}

	/*
	 * Checks if details for a floating task is valid.
	 */
	private void checkFloatingTime(LocalDateTime start, LocalDateTime end) throws LogicException {
		if (start != null) {
			throw new LogicException(ERROR_EXTRA_START_TIME);
		}
		if (end != null) {
			throw new LogicException(ERROR_EXTRA_END_TIME);
		}
	}

	/*
	 * Checks if the details for an event task is valid.
	 */
	private void checkEventTime(LocalDateTime start, LocalDateTime end) throws LogicException {
		if (start == null) {
			throw new LogicException(ERROR_MISSING_START_TIME);
		} else if (end == null) {
			throw new LogicException(ERROR_MISSING_END_TIME);
		} else if (end.isBefore(start)) {
			throw new LogicException(ERROR_END_BEFORE_START);
		} else if (end.equals(start)) {
			throw new LogicException(ERROR_SAME_START_END);
		}
	}

	/*
	 * Checks if the details for a floating task is valid.
	 */
	private void checkDeadlineTime(LocalDateTime start, LocalDateTime end) throws LogicException {
		if (start != null) {
			throw new LogicException(ERROR_EXTRA_START_TIME);
		}
		if (end == null) {
			throw new LogicException(ERROR_MISSING_END_TIME);
		}
	}

	/*
	 * Checks if the description for the task is null or empty.
	 */
	private void checkForEmptyDesc(Task task) throws LogicException {
		if (task.getDesc() == null || task.getDesc().equals("")) {
			throw new LogicException(ERROR_NO_DESC);
		}
	}
}
```
###### src\urgenda\command\Undo.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * Undo command for the undo function of Urgenda.
 *
 */
public class Undo extends Command {

	private static final String MESSAGE_UNDO = "Undo: ";

	/**
	 * Execute method for Undo which sets the state for undoing of command.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		return MESSAGE_UNDO;
	}

}
```
###### src\urgenda\logic\Logic.java
``` java
package urgenda.logic;

import java.util.ArrayList;

import urgenda.command.AddTask;
import urgenda.command.BlockSlots;
import urgenda.command.Command;
import urgenda.command.Complete;
import urgenda.command.Demo;
import urgenda.command.Exit;
import urgenda.command.Home;
import urgenda.command.Invalid;
import urgenda.command.ShowDetails;
import urgenda.command.TaskCommand;
import urgenda.parser.CommandParser;
import urgenda.util.StateFeedback;
import urgenda.util.SuggestCommand;
import urgenda.util.SuggestFeedback;
import urgenda.util.UrgendaLogger;

/**
 * Logic class for the Logic component Urgenda. Acts as the facade for the
 * numerous functionality of the Logic Component.
 * 
 */
public class Logic {

	private static final String MESSAGE_WELCOME = "Welcome to Urgenda!\nType \"demo\" for a simple demo, "
			+ "type \"help\" for the help menu.";
	private static UrgendaLogger logger = UrgendaLogger.getInstance();
	private static Logic _logic;
	private LogicData _logicData;
	private LogicCommand _logicCommand;
	private LogicSuggester _logicSuggestion;

	// Default constructor for Logic
	private Logic() {
		_logicData = LogicData.getInstance();
		_logicCommand = new LogicCommand();
		_logicSuggestion = new LogicSuggester();
	}

	// Constructor for testing
	private Logic(boolean isTest) {
		_logicData = LogicData.getInstance(isTest);
		_logicCommand = new LogicCommand();
		_logicSuggestion = new LogicSuggester();
	}

	/**
	 * Singleton pattern constructor for logic where object is created if does
	 * not exist.
	 * 
	 * @return Logic object that is used currently or created.
	 */
	public static Logic getInstance() {
		if (_logic == null) {
			logger.getLogger().info("creating instance of logic");
			_logic = new Logic();
		}
		logger.getLogger().info("retrieving prev instance of logic");
		return _logic;
	}

	/**
	 * Alternate constructor for singleton pattern for stubbing of storage when
	 * testing.
	 * 
	 * @param isTest
	 *            boolean of checking if the current mode is in testing.
	 * @return Logic object that is used currently or created.
	 */
	public static Logic getInstance(boolean isTest) {
		if (_logic == null) {
			_logic = new Logic(isTest);
		}
		return _logic;
	}

	/**
	 * Executes the command given in string format, taking the relevant position
	 * if required.
	 * 
	 * @param command
	 *            input string by the user.
	 * @param index
	 *            current index pointed at by the user.
	 * @return StateFeedback which includes the current state of tasks as well
	 *         as feedback line.
	 */
	public StateFeedback executeCommand(String command, int index) {
		logger.getLogger().info("executing user input: " + command);
		// asserts that given index is non-negative OR -1(case when there is no
		// tasks)
		assert (index >= -1);
		Command currCmd = CommandParser.parseCommand(command, index);
		// asserts that parser returns a valid command object
		assert (currCmd != null);
		currCmd = checkAndFilterCommand(currCmd);
		return updateStateAndProcessCommand(currCmd);
	}

	/*
	 * Ensures that the state of Urgenda is updated and processes the given
	 * command accordingly.
	 */
	private StateFeedback updateStateAndProcessCommand(Command currCmd) {
		String feedback;
		_logicData.updateState();
		feedback = _logicCommand.processCommand(currCmd);
		_logicData.updateState();
		_logicData.checkPointer();
		StateFeedback state = _logicData.getState();
		state.setFeedback(feedback);
		_logicData.saveContents();
		return state;
	}

	/*
	 * Filters the given command to ensure that the command is valid for the
	 * current state of Urgenda.
	 * 
	 * FindFree only allows adding of new tasks as well as non task related
	 * commands. Archive prevents completed an already completed task. Demo only
	 * allows the home and exit commands.
	 */
	private Command checkAndFilterCommand(Command currCmd) {
		if (_logicData.getCurrState() == LogicData.DisplayState.FIND_FREE) {
			currCmd = filterFindFree(currCmd);
		} else if (_logicData.getCurrState() == LogicData.DisplayState.ARCHIVE) {
			currCmd = filterArchive(currCmd);
		} else if (_logicData.getCurrState() == LogicData.DisplayState.DEMO) {
			currCmd = filterDemo(currCmd);
		}
		return currCmd;
	}

	private Command filterDemo(Command currCmd) {
		if (currCmd instanceof Home || currCmd instanceof Exit) {
			// allows home or exiting in demo mode
		} else {
			currCmd = new Demo();
		}
		return currCmd;
	}

	private Command filterArchive(Command currCmd) {
		if (currCmd instanceof Complete) {
			currCmd = new Invalid(LogicData.DisplayState.ARCHIVE);
		}
		return currCmd;
	}

	private Command filterFindFree(Command currCmd) {
		if (currCmd instanceof TaskCommand || currCmd instanceof ShowDetails) {
			if (currCmd instanceof AddTask || currCmd instanceof BlockSlots) {
				// allows the addition of tasks
			} else {
				currCmd = new Invalid(LogicData.DisplayState.FIND_FREE);
			}
		}
		return currCmd;
	}

	/**
	 * Generates the help manual when requested by the user.
	 * 
	 * @return String containing the help manual.
	 */
	public ArrayList<String> displayHelp() {
		logger.getLogger().info("Help fn has been called");
		return _logicData.generateHelpManual();
	}

	/**
	 * Retrieves the demo text for Urgenda for demo mode.
	 * 
	 * @return ArrayList of text containing instructions for demo mode.
	 */
	public ArrayList<String> getDemoText() {
		return _logicData.generateDemoText();
	}

	/**
	 * Retrieves the corresponding selector index for demonstration purposes in
	 * demo mode.
	 * 
	 * @return ArrayList of indexes that is selected for each state in demo
	 *         modes.
	 */
	public ArrayList<Integer> getDemoSelectionIndexes() {
		return _logicData.generateDemoSelectionIndexes();
	}

	/**
	 * Initialization of Logic upon launch of the program.
	 * 
	 * @return StateFeedback containing the previously stored state.
	 */
	public StateFeedback retrieveStartupState() {
		logger.getLogger().info("Retrieving prev launched info");
		_logicData.clearOldArchive();
		_logicData.updateState();
		StateFeedback state = _logicData.getState();
		state.setFeedback(MESSAGE_WELCOME);
		return state;
	}

	/**
	 * Retrieval of current directory where the data is stored.
	 * 
	 * @return String of location of current directory.
	 */
	public String getCurrentSaveDirectory() {
		logger.getLogger().info("Retrieving current help directory");
		return _logicData.retrieveCurrentDirectory();
	}

	/**
	 * Enable suggestion of the command while user is typing.
	 * 
	 * @param currCmd
	 *            current string that the user is typing.
	 * @return SuggestFeedback including strings of suggestions to user.
	 */
	public SuggestFeedback getSuggestions(String currCmd) {
		SuggestCommand suggCmd = CommandParser.parseRuntimeInput(currCmd);
		return _logicSuggestion.processSuggestions(suggCmd);
	}

	/**
	 * Clears the content stored in storage after testing to revert the tasks
	 * inside.
	 */
	public void clearStorageTester() {
		_logicData.reinitialiseStorageTester();
	}

	/**
	 * Method for retrieving settings for novice view.
	 * 
	 * @return _storage.getNoviceSettings();
	 */
	public boolean getNoviceSettings() {
		return _logicData.getNoviceSettings();
	}

	/**
	 * Sets the novice or advanced view settings.
	 * 
	 * @param isNovice
	 *            boolean to show novice or advanced view
	 */
	public void setNoviceSettings(boolean isNovice) {
		_logicData.setNoviceSettings(isNovice);
	}
}
```
###### src\urgenda\logic\LogicCommand.java
``` java
package urgenda.logic;

import java.util.ArrayDeque;
import java.util.Deque;

import urgenda.command.Command;
import urgenda.command.Redo;
import urgenda.command.TaskCommand;
import urgenda.command.Undo;
import urgenda.util.LogicException;
import urgenda.util.UrgendaLogger;

/**
 * Logic Command class of the Logic component in Urgenda. Responsible of
 * accessing and storage of the different commands used by Urgenda.
 * 
 */
public class LogicCommand {

	private static UrgendaLogger logger = UrgendaLogger.getInstance();
	private static final String MESSAGE_EMPTY_UNDO = "Nothing to undo";
	private static final String MESSAGE_EMPTY_REDO = "Nothing to redo";

	private Deque<TaskCommand> _undos;
	private Deque<TaskCommand> _redos;

	/**
	 * Default constructor for LogicCommand.
	 */
	public LogicCommand() {
		_undos = new ArrayDeque<TaskCommand>();
		_redos = new ArrayDeque<TaskCommand>();
	}

	/**
	 * Processes the given command to execute changes on the tasks involved.
	 * 
	 * @param currCmd
	 *            Current command that requires to be carried out.
	 * @return Feedback message for user display on the processing of command.
	 */
	public String processCommand(Command currCmd) {
		logger.getLogger().warning("Exception can occur");
		String feedback;
		try {
			feedback = currCmd.execute();
			if (currCmd instanceof Undo) {
				feedback = undoCommand(feedback);
			} else if (currCmd instanceof Redo) {
				feedback = redoCommand(feedback);
			} else {
				addUndo(currCmd);
			}
		} catch (LogicException e) {
			logger.getLogger().severe("Exception occured" + e);
			return e.getMessage();
		}
		return feedback;
	}

	/**
	 * Adds the currCmd given to the undo stack if the command is a task command
	 * type which can be undone.
	 * 
	 * @param currCmd
	 *            Current command being executed by the program.
	 */
	public void addUndo(Command currCmd) {
		if (currCmd instanceof TaskCommand) {
			logger.getLogger().info("adding " + currCmd + " to undo stack");
			_undos.addFirst((TaskCommand) currCmd);
			_redos.clear();
		}
	}

	/**
	 * The undo command calls the undo method from the latest task command in
	 * the undo stack.
	 * 
	 * @param feedback
	 *            Current feedback string to the user.
	 * @return Updated feedback string with the specific task undone.
	 */
	private String undoCommand(String feedback) {
		if (!_undos.isEmpty()) {
			TaskCommand undoCommand = _undos.removeFirst();
			feedback += undoCommand.undo();
			_redos.addFirst(undoCommand);
			return feedback;
		} else {
			// replaces original feedback to undo empty message if there is
			// nothing to undo
			return MESSAGE_EMPTY_UNDO;
		}
	}

	/**
	 * The redo command calls the redo method from the latest task command in
	 * the redo stack.
	 * 
	 * @param feedback
	 *            Current feedback string to the user.
	 * @return Updated feedback string with the specific task done again.
	 */
	private String redoCommand(String feedback) {
		if (!_redos.isEmpty()) {
			TaskCommand redoCommand = _redos.removeFirst();
			feedback += redoCommand.redo();
			_undos.addFirst(redoCommand);
			return feedback;
		} else {
			// replaces original feedback to redo empty message if there is
			// nothing to redo
			return MESSAGE_EMPTY_REDO;
		}
	}
}
```
###### src\urgenda\logic\LogicSuggester.java
``` java
package urgenda.logic;

import java.util.ArrayList;

import urgenda.util.SuggestCommand;
import urgenda.util.SuggestCommand.Command;
import urgenda.util.SuggestFeedback;

/**
 * LogicSuggester is a class within the logic component that handles the suggestion provided
 * to the user when the user is typing commands as input.
 *
 */
public class LogicSuggester {

	private static final String ADD_EVENT = "[desc] [start time] to [end time] @[location] [optional]";
	private static final String ADD_EVENT_MESSAGE = "Adds a task spanning across a time period";
	private static final String ADD_DEADLINE = "[desc] by [deadline] @[location] [optional]";
	private static final String ADD_DEADLINE_MESSAGE = "Adds a task with a deadline";
	private static final String ADD_FLOATING = "[desc] [use at/from/on/by for timings] @[location] [optional]";
	private static final String ADD_FLOATING_MESSAGE = "Adds an untimed task";

	private static final String DEL_TASK = "[task no] | [task no]-[task no] | [desc]";
	private static final String DEL_MESSAGE = "Deletes selected task(s) by index or description";

	private static final String DONE_TASK = "[task no] | [task no]-[task no] | [desc]";
	private static final String DONE_MESSAGE = "Mark selected task(s) as done";

	private static final String EDIT_FLOATING = "[task no] [new desc] | [use at/from/on/by for timings] | "
			+ "[-r] [removes a timing] | @[location]";
	private static final String EDIT_FLOATING_MESSAGE = "Edits desc, date(s) and timing(s), "
			+ "and/or location of selected task";
	private static final String EDIT_EVENT = "[task no] [new desc] | [start time] to [end time] | "
			+ "@[location] [optional]";
	private static final String EDIT_EVENT_MESSAGE = "Edits task into an event";
	private static final String EDIT_DEADLINE = "[task no] [new desc] | by [deadline] | "
			+ "@[location] [optional]";
	private static final String EDIT_DEADLINE_MESSAGE = "Edits task into deadline task";

	private static final String SEARCH_TASK = "[desc] | [date/month/day/datetime/task no.] | [task type]";
	private static final String SEARCH_MESSAGE = "Searches for task(s) displayed that matches the given input";

	private static final String EXIT = "";
	private static final String EXIT_MESSAGE = "Saves and exits Urgenda";

	private static final String SHOWMORE = "[task no] | [task no]-[task no]";
	private static final String SHOWMORE_MESSAGE = "Toggle details of selected task(s)";

	private static final String ARCHIVE = "";
	private static final String ARCHIVE_MESSAGE = "Show all tasks marked as completed";

	private static final String UNDO = "";
	private static final String UNDO_MESSAGE = "Undo changes done by previous command";

	private static final String REDO = "";
	private static final String REDO_MESSAGE = "Redo changes done by previous undo";

	private static final String PRI = "[task no] | [task no]-[task no] | [desc]";
	private static final String PRI_MESSAGE = "Toggle the importance for selected task(s)";

	private static final String BLOCK = "[desc] at [start time] to [end time], "
			+ "[multiple] [start time] to [end time]";
	private static final String BLOCK_MESSAGE = "Blocks multiple timeslots for single task";

	private static final String CONFIRM = "[task no] [start time] to [end time]";
	private static final String CONFIRM_MESSAGE = "Confirms the inputted slot for the timing of task selected";

	private static final String FIND_FREE = "[start time] to [end time]";
	private static final String FIND_FREE_MESSAGE = "Finds all available timeslots within given time range";

	private static final String HOME = "";
	private static final String HOME_MESSAGE = "Displays default view of all tasks";

	private static final String POSTPONE = "[task no] [duration]";
	private static final String POSTPONE_MESSAGE = "Postpones the selected task by given duration";

	private static final String HELP = "";
	private static final String HELP_MESSAGE = "Displays the help manual for Urgenda";

	private static final String SAVETO = "[path directory]";
	private static final String SAVETO_MESSAGE = "Change the save directory of Urgenda";

	private static final String DEMO = "";
	private static final String DEMO_MESSAGE = "Gives a demonstration of using Urgenda";

	private static final String HIDE = "";
	private static final String HIDE_MESSAGE = "Minimise Urgenda";

	private static final String SUGGESTION_MESSAGE = "Matching command(s) to use";

	/**
	 * Method for processing the parsed suggestion into the required format for
	 * display to the user when the user is typing.
	 * 
	 * @param suggCmd
	 *            parsed suggestion of the current user input.
	 * @return SuggestFeedback object containing all the suggestions to user.
	 */
	public SuggestFeedback processSuggestions(SuggestCommand suggCmd) {
		boolean isCommand = false;
		String currCmd = suggCmd.getCurrCmd();
		return filterSuggestionType(suggCmd, isCommand, currCmd);
	}

	/*
	 * Method for separating of the different types of suggestion state such as
	 * suggested possible commands and also confirmed command type.
	 */
	private SuggestFeedback filterSuggestionType(SuggestCommand suggCmd, boolean isCommand, String currCmd) {
		ArrayList<String> suggestions;
		if (suggCmd.getConfirmedCommand() != null && currCmd != null &&
				!currCmd.isEmpty() && !currCmd.equals("")) {
			// confirmed command filter possible formats
			suggestions = filterCommand(suggCmd.getConfirmedCommand(), suggCmd.isDeadline(), suggCmd.isEvent());
			isCommand = true;
			return new SuggestFeedback(suggestions, currCmd, isCommand);
		} else if (suggCmd.getPossibleCommands() != null && !suggCmd.getPossibleCommands().isEmpty()) {
			// possible commands only give list of possible commands
			suggestions = suggCmd.getPossibleCommands();
			suggestions.add(SUGGESTION_MESSAGE);
			SuggestFeedback feedback = new SuggestFeedback(suggestions, isCommand);
			feedback.setIsSuggestion(true);
			return feedback;
		} else {
			// both empty means add
			suggestions = addCommand(suggCmd.isDeadline(), suggCmd.isEvent());
			return new SuggestFeedback(suggestions, isCommand);
		}
	}

	/*
	 * Filters the command based on the given command detected and generates the
	 * feedback.
	 */
	private ArrayList<String> filterCommand(Command confirmedCommand, boolean isDeadline, boolean isEvent) {
		switch (confirmedCommand) {
		case ADD :
			return addCommand(isDeadline, isEvent);
		case ARCHIVE :
			return archiveCommand();
		case BLOCK :
			return blockCommand();
		case CONFIRM :
			return confirmCommand();
		case DELETE :
			return deleteCommand();
		case DEMO :
			return demoCommand();
		case DONE :
			return doneCommand();
		case EDIT :
			return editCommand(isDeadline, isEvent);
		case EXIT :
			return exitCommand();
		case FIND_FREE :
			return findFreeCommand();
		case HELP :
			return helpCommand();
		case HIDE :
			return hideCommand();
		case HOME :
			return homeCommand();
		case POSTPONE :
			return postponeCommand();
		case PRIORITISE :
			return prioritiseCommand();
		case REDO :
			return redoCommand();
		case SAVETO :
			return saveCommand();
		case SEARCH :
			return searchCommand();
		case SHOWMORE :
			return showCommand();
		case UNDO :
			return undoCommand();
		}
		return null;
	}

	private ArrayList<String> hideCommand() {
		return generateMessage(HIDE, HIDE_MESSAGE);
	}

	private ArrayList<String> demoCommand() {
		return generateMessage(DEMO, DEMO_MESSAGE);
	}

	private ArrayList<String> undoCommand() {
		return generateMessage(UNDO, UNDO_MESSAGE);
	}

	private ArrayList<String> showCommand() {
		return generateMessage(SHOWMORE, SHOWMORE_MESSAGE);
	}

	private ArrayList<String> searchCommand() {
		return generateMessage(SEARCH_TASK, SEARCH_MESSAGE);
	}

	private ArrayList<String> saveCommand() {
		return generateMessage(SAVETO, SAVETO_MESSAGE);
	}

	private ArrayList<String> redoCommand() {
		return generateMessage(REDO, REDO_MESSAGE);
	}

	private ArrayList<String> prioritiseCommand() {
		return generateMessage(PRI, PRI_MESSAGE);
	}

	private ArrayList<String> postponeCommand() {
		return generateMessage(POSTPONE, POSTPONE_MESSAGE);
	}

	private ArrayList<String> homeCommand() {
		return generateMessage(HOME, HOME_MESSAGE);
	}

	private ArrayList<String> helpCommand() {
		return generateMessage(HELP, HELP_MESSAGE);
	}

	private ArrayList<String> findFreeCommand() {
		return generateMessage(FIND_FREE, FIND_FREE_MESSAGE);
	}

	private ArrayList<String> exitCommand() {
		return generateMessage(EXIT, EXIT_MESSAGE);
	}

	private ArrayList<String> archiveCommand() {
		return generateMessage(ARCHIVE, ARCHIVE_MESSAGE);
	}

	private ArrayList<String> confirmCommand() {
		return generateMessage(CONFIRM, CONFIRM_MESSAGE);
	}

	private ArrayList<String> blockCommand() {
		return generateMessage(BLOCK, BLOCK_MESSAGE);
	}

	private ArrayList<String> doneCommand() {
		return generateMessage(DONE_TASK, DONE_MESSAGE);
	}

	private ArrayList<String> deleteCommand() {
		return generateMessage(DEL_TASK, DEL_MESSAGE);
	}

	private ArrayList<String> generateMessage(String parameters, String message) {
		ArrayList<String> suggestions = new ArrayList<String>();
		suggestions.add(parameters);
		suggestions.add(message);
		return suggestions;
	}

	private ArrayList<String> editCommand(boolean isDeadline, boolean isEvent) {
		if (isDeadline) {
			return generateMessage(EDIT_DEADLINE, EDIT_DEADLINE_MESSAGE);
		} else if (isEvent) {
			return generateMessage(EDIT_EVENT, EDIT_EVENT_MESSAGE);
		} else {
			return generateMessage(EDIT_FLOATING, EDIT_FLOATING_MESSAGE);
		}
	}

	private ArrayList<String> addCommand(boolean isDeadline, boolean isEvent) {
		if (isDeadline) {
			return generateMessage(ADD_DEADLINE, ADD_DEADLINE_MESSAGE);
		} else if (isEvent) {
			return generateMessage(ADD_EVENT, ADD_EVENT_MESSAGE);
		} else {
			return generateMessage(ADD_FLOATING, ADD_FLOATING_MESSAGE);
		}
	}

}
```
###### src\urgenda\util\LogicException.java
``` java
package urgenda.util;

/**
 * LogicException is the Exception used in the Logic component in Urgenda for
 * exceptions that occur due to invalid tasks or commands on the current state
 * of Urgenda.
 * 
 */
public class LogicException extends Exception {

	/*
	 * System Generated serial number for LogicException.
	 */
	private static final long serialVersionUID = 1L;
	private String _message;

	/**
	 * Default constructor which contains the message for feedback to the user.
	 * 
	 * @param message
	 *            Error message generated by method.
	 */
	public LogicException(String message) {
		_message = message;
	}

	/**
	 * Retrieves the error message generated.
	 * 
	 * @return String of the error message.
	 */
	@Override
	public String getMessage() {
		return _message;
	}

}
```
###### src\urgenda\util\MultipleSlot.java
``` java
package urgenda.util;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

/**
 * MultipleSlot is an attribute for Tasks with multiple possible timings. Main
 * timing displayed is shown in start and end time for Task. Alternative timings
 * are placed as multiple slots to be confirmed.
 *
 */
public class MultipleSlot {

	private ArrayList<DateTimePair> _slots;

	/**
	 * Default constructor for MultipleSlot which creates the arraylist of
	 * datetimepair for storing.
	 */
	public MultipleSlot() {
		_slots = new ArrayList<DateTimePair>();
	}

	/**
	 * Constructor for replicating the given multiple slot.
	 * 
	 * @param original
	 *            Original multiple slot for replication.
	 */
	public MultipleSlot(MultipleSlot original) {
		_slots = new ArrayList<DateTimePair>(original.getSlots());
	}

	/**
	 * Adds a new time slot pair to the slot.
	 * 
	 * @param start
	 *            LocalDateTime of the start time.
	 * @param end
	 *            LocalDateTime of the end time.
	 */
	public void addTimeSlot(LocalDateTime start, LocalDateTime end) {
		_slots.add(new DateTimePair(start, end));
	}

	/**
	 * Getter method to retrieve the slots.
	 * 
	 * @return All the DateTimePair of the slot.
	 */
	public ArrayList<DateTimePair> getSlots() {
		return _slots;
	}

	/**
	 * Sorts the slots by the timing of the slots based on the comparator for
	 * start time followed by end time.
	 */
	public void sortSlots() {
		Collections.sort(_slots, comparator);
	}

	/*
	 * Comparator for sorting of datetimepair where the start time is compared
	 * followed by the end time.
	 */
	static Comparator<DateTimePair> comparator = new Comparator<DateTimePair>() {
		public int compare(final DateTimePair p1, final DateTimePair p2) {
			if (p1.getEarlierDateTime().equals(p2.getEarlierDateTime())) {
				return p1.getLaterDateTime().compareTo(p2.getLaterDateTime());
			} else {
				return p1.getEarlierDateTime().compareTo(p2.getEarlierDateTime());
			}
		}
	};

	/**
	 * Getter of the next slot present.
	 * 
	 * @return DateTimePair of next pair, else null if invalid.
	 */
	public DateTimePair getNextSlot() {
		if (_slots.isEmpty()) {
			return null;
		} else {
			return _slots.get(0);
		}
	}

	/**
	 * Removes the next slot present in the ArrayList of DateTimePair
	 */
	public void removeNextSlot() {
		if (!_slots.isEmpty()) {
			_slots.remove(0);
		}
	}

	/**
	 * Checks if the slots is empty.
	 * 
	 * @return boolean of whether the slot is empty.
	 */
	public boolean isEmpty() {
		return _slots.isEmpty();
	}

}
```
###### src\urgenda\util\SuggestCommand.java
``` java
package urgenda.util;

import java.util.ArrayList;

/**
 * SuggestCommand contains all the parsed details for suggestion to the user
 * input.
 * 
 */
public class SuggestCommand {

	/**
	 * Command type that parser parses based on the different commands in
	 * Urgenda.
	 */
	public enum Command {
		ADD, ARCHIVE, BLOCK, CONFIRM, DELETE, DEMO, DONE, EDIT, EXIT, FIND_FREE, 
		HELP, HIDE, HOME, POSTPONE, PRIORITISE, REDO, SAVETO, SEARCH, SHOWMORE, UNDO
	}

	private ArrayList<String> _possibleCommands;
	private Command _confirmedCommand;
	private String _currCmd;
	private boolean _isDeadline = false;
	private boolean _isEvent = false;

	/**
	 * Constructor of SuggestCommand that contains the command as well as
	 * possible commands if there are not confirmed commands.
	 * 
	 * @param confirmed
	 *            enum type of the detected command.
	 * @param possibleCommands
	 *            lists of possible command if no full command detected.
	 * @param currCmd
	 *            the current version of the command used.
	 */
	public SuggestCommand(Command confirmed, ArrayList<String> possibleCommands, String currCmd) {
		_confirmedCommand = confirmed;
		_possibleCommands = possibleCommands;
		_currCmd = currCmd;
	}

	/**
	 * Sets if the input given is a deadline.
	 * 
	 * @param isDeadline
	 *            boolean of whether the input is a deadline.
	 */
	public void setDeadline(boolean isDeadline) {
		_isDeadline = isDeadline;
	}

	/**
	 * Sets if the input given is an event.
	 * 
	 * @param isEvent
	 *            boolean of whether the input is an event.
	 */
	public void setEvent(boolean isEvent) {
		_isEvent = isEvent;
	}

	/**
	 * Retrieves the current confirmed command type.
	 * 
	 * @return Command enum of SuggestCommand.
	 */
	public Command getConfirmedCommand() {
		return _confirmedCommand;
	}

	/**
	 * Retrieves the possible commands.
	 * 
	 * @return ArrayList of strings that are possible commands for current
	 *         input.
	 */
	public ArrayList<String> getPossibleCommands() {
		return _possibleCommands;
	}

	/**
	 * Retrieves the current command input.
	 * 
	 * @return String of the current command input by user.
	 */
	public String getCurrCmd() {
		return _currCmd;
	}

	/**
	 * Gets if the suggestion has a deadline.
	 * 
	 * @return boolean of if it is a deadline.
	 */
	public boolean isDeadline() {
		return _isDeadline;
	}

	/**
	 * Gets if the suggestion is an event.
	 * 
	 * @return boolean of if it is an event.
	 */
	public boolean isEvent() {
		return _isEvent;
	}

}
```
