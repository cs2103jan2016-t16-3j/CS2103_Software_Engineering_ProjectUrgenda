# A0127764X
###### src\test\testParser\PtParser.java
``` java
package test.testParser;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.FixMethodOrder;
import org.junit.Test;

import urgenda.parser.CommandParser;
import urgenda.parser.PublicVariables;
import urgenda.parser.PublicVariables.COMMAND_TYPE;

import org.junit.runners.MethodSorters;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class PtParser {
	private static final String TASKTYPE_EVENT = "EVENT";
	private static final String TASKTYPE_DEADLINE = "DEADLINE";
	private static final String TASKTYPE_FLOATING = "FLOATING";
	
	@Test
	public void test001DeadlineTime24h() {
		String phrase = "add test001 by 03/03/2016 23:59";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-03-03T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test002DeadlineHourAm() {
		String phrase = "add test001 by 03/03/2016 2am";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-03-03T02:00";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	//TODO:Description not parsed correctly.
	//All others correct
	@Test
	public void test003DeadlineTimePm() {
		String phrase = "add test001 by 03/03/2016 2:11pm";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-03-03T14:11";
		CommandParser.parseCommand(phrase, 5);
//		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test004DeadlineTimePmDelimiter() {
		String phrase = "add test001 by 03/03/2016 7:11pm";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-03-03T19:11";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test005DeadlineTimePmDelimiter() {
		String phrase = "add test001 by 03/03/2016 7:11pm";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-03-03T19:11";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test006DeadlineDateNoYear() {
		String phrase = "add test001 by 03/03 7:11am";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-03-03T07:11";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test007DeadlineDateNoYear() {
		String phrase = "add test001 by 3/3 7:11am";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-03-03T07:11";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test008DeadlineDateLeapYear() {
		String phrase = "add test001 by 2/29 7:11am";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-02-29T07:11";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test009DeadlineDateYY() {
		String phrase = "add test001 by 3/23/16 7:11am";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-03-23T07:11";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}

	@Test
	public void test010DeadlineTimeSpeltAm() {
		String phrase = "add test001 by 3/23/16 nine am";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-03-23T09:00";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	
	@Test
	public void test011DeadlineTimeSpeltPm() {
		String phrase = "add test001 by 3/23/16 nine pm";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-03-23T21:00";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
 
	@Test
	public void test012DeadlineDateSpeltYear() {
		String phrase = "add test001 by 23 MaR 2016 23:59";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-03-23T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test013DeadlineDateSpeltNoYear() {
		String phrase = "add test001 by Jan 23 23:59";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-01-23T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test015DeadlineDay() {
		String phrase = "add test001 by 15/4 at 2359";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-04-15T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test016NoAddKeyWord() {
		String phrase = "test001 by 15/4 at 2359";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-04-15T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test017DeadlineSeparateDateTime() {
		String phrase = "15/4 test001 abcd by 23:59";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-04-15T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001 abcd", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test017DeadlineSeparateDateTime2() {
		String phrase = "3/25 test001 by 23:59";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String endTime = "2016-03-25T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test001", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(null, PublicVariables.taskStartTime);
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_DEADLINE, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test017EventDefault() {
		String phrase = "test from 03/25 22:59 to 03/25 23:59";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String startTime = "2016-03-25T22:59";
		String endTime = "2016-03-25T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(startTime, PublicVariables.taskStartTime.toString());
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_EVENT, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test018EventSingleDate() {
		String phrase = "test from 03/25 22:59 to 23:59";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String startTime = "2016-03-25T22:59";
		String endTime = "2016-03-25T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(startTime, PublicVariables.taskStartTime.toString());
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_EVENT, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test019EventSeparateDateTimeSingleDate() {
		String phrase = "03/25 test abcd from 22:59 to 23:59";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String startTime = "2016-03-25T22:59";
		String endTime = "2016-03-25T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test abcd", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(startTime, PublicVariables.taskStartTime.toString());
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_EVENT, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test020EventSeparateDateTimeSingleDate2() {
		String phrase = "test 13/4 abcd 22:59 - 23:59";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String startTime = "2016-04-13T22:59";
		String endTime = "2016-04-13T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test abcd", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(startTime, PublicVariables.taskStartTime.toString());
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_EVENT, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test021EventSeparateDateTimeSingleDate3() {
		String phrase = "test 13/4 for abcd 22:59 - 23:59";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String startTime = "2016-04-13T22:59";
		String endTime = "2016-04-13T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test for abcd", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(startTime, PublicVariables.taskStartTime.toString());
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_EVENT, PublicVariables.taskType.toString());
	}
	
	@Test
	public void test022EventSeparateDateTimeSingleDate4() {
		String phrase = "test on 3/30 for abcd 22:59 - 23:59";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String startTime = "2016-03-30T22:59";
		String endTime = "2016-03-30T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test for abcd", PublicVariables.taskDescription);
		assertEquals("",PublicVariables.taskLocation);
		assertEquals(startTime, PublicVariables.taskStartTime.toString());
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_EVENT, PublicVariables.taskType.toString());	
	}
	
	@Test
	public void test023InsertLocation() {
		String phrase = "test at headquarter 3/30 22:59 - 23:59";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String startTime = "2016-03-30T22:59";
		String endTime = "2016-03-30T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test", PublicVariables.taskDescription);
		assertEquals("headquarter", PublicVariables.taskLocation);
		assertEquals(startTime, PublicVariables.taskStartTime.toString());
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_EVENT, PublicVariables.taskType.toString());	
	}
	
	@Test
	public void test024InsertLocation2() {
		String phrase = "test 3/30 22:59 - 23:59 at headquarter";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String startTime = "2016-03-30T22:59";
		String endTime = "2016-03-30T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test", PublicVariables.taskDescription);
		assertEquals("headquarter", PublicVariables.taskLocation);
		assertEquals(startTime, PublicVariables.taskStartTime.toString());
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_EVENT, PublicVariables.taskType.toString());	
	}
	
	@Test
	public void test025InsertLocation3() {
		String phrase = "test @headquarter 3/30 22:59 - 23:59 ";
		ArrayList<String> testHashtags = new ArrayList<String>();
		String startTime = "2016-03-30T22:59";
		String endTime = "2016-03-30T23:59";
		CommandParser.parseCommand(phrase, 5);
		assertEquals("test", PublicVariables.taskDescription);
		assertEquals("headquarter", PublicVariables.taskLocation);
		assertEquals(startTime, PublicVariables.taskStartTime.toString());
		assertEquals(endTime, PublicVariables.taskEndTime.toString());
		assertEquals(testHashtags, PublicVariables.taskHashtags);
		assertEquals(TASKTYPE_EVENT, PublicVariables.taskType.toString());	
	}
	
	@Test
	public void test028DeleteFunctionByIndex() {
		String phrase = "delete 1";
		CommandParser.parseCommand(phrase, 5);
		Integer expectedIndex = 0;
		assertEquals(COMMAND_TYPE.DELETE, PublicVariables.commandType);
		assertEquals(expectedIndex, PublicVariables.positions.get(0));
		assertEquals("", PublicVariables.taskDescription);
	}
	
	@Test
	public void test029DeleteFunctionByPosition() {
		String phrase = "delete";
		CommandParser.parseCommand(phrase, 5);
		Integer expectedIndex = 5;
		assertEquals(COMMAND_TYPE.DELETE, PublicVariables.commandType);
		assertEquals(expectedIndex, PublicVariables.positions.get(0));
		assertEquals("", PublicVariables.taskDescription);
	}
	
	@Test
	public void test030DeleteFunctionByDesc() {
		String phrase = "delete abc";
		CommandParser.parseCommand(phrase, 5);
		assertEquals(COMMAND_TYPE.DELETE, PublicVariables.commandType);
		assertEquals(-10, PublicVariables.taskIndex);
		assertEquals("abc", PublicVariables.taskDescription);
	}
	
	@Test
	public void test031PriFunctionByIndex() {
		String phrase = "pri 1";
		CommandParser.parseCommand(phrase, 5);
		Integer expectedIndex = 0;
		assertEquals(COMMAND_TYPE.PRIORITISE, PublicVariables.commandType);
		assertEquals(expectedIndex, PublicVariables.positions.get(0));
		assertEquals("", PublicVariables.taskDescription);
	}
	
	@Test
	public void test032PriFunctionByPosition() {
		String phrase = "pri";
		CommandParser.parseCommand(phrase, 5);
		Integer expectedIndex = 5;
		assertEquals(COMMAND_TYPE.PRIORITISE, PublicVariables.commandType);
		assertEquals(expectedIndex, PublicVariables.positions.get(0));
		assertEquals("", PublicVariables.taskDescription);
	}
	
	@Test
	public void test033PriFunctionByDesc() {
		String phrase = "pri abc";
		CommandParser.parseCommand(phrase, 5);
		assertEquals(COMMAND_TYPE.PRIORITISE, PublicVariables.commandType);
		assertEquals(-10, PublicVariables.taskIndex);
		assertEquals("abc", PublicVariables.taskDescription);
	}
	
	@Test
	public void test034DoneFunctionByIndex() {
		String phrase = "done 1";
		CommandParser.parseCommand(phrase, 5);
		Integer expectedIndex = 0;
		assertEquals(COMMAND_TYPE.COMPLETE, PublicVariables.commandType);
		assertEquals(expectedIndex, PublicVariables.positions.get(0));
		assertEquals("", PublicVariables.taskDescription);
	}
	
	@Test
	public void test035DoneFunctionByPosition() {
		String phrase = "done";
		CommandParser.parseCommand(phrase, 5);
		Integer expectedIndex = 5;
		assertEquals(COMMAND_TYPE.COMPLETE, PublicVariables.commandType);
		assertEquals(expectedIndex, PublicVariables.positions.get(0));
		assertEquals("", PublicVariables.taskDescription);
	}
	
	@Test
	public void test036DoneFunctionByDesc() {
		String phrase = "done abc";
		CommandParser.parseCommand(phrase, 5);
		assertEquals(COMMAND_TYPE.COMPLETE, PublicVariables.commandType);
		assertEquals(-10, PublicVariables.taskIndex);
		assertEquals("abc", PublicVariables.taskDescription);
	}
	
	@Test
	public void test037ExitFunction() {
		String phrase = "exit";
		CommandParser.parseCommand(phrase, 5);
		assertEquals(COMMAND_TYPE.EXIT, PublicVariables.commandType);
	}
	
	@Test
	public void test038UndoFunction() {
		String phrase = "undo";
		CommandParser.parseCommand(phrase, 5);
		assertEquals(COMMAND_TYPE.UNDO, PublicVariables.commandType);
	}
	
	@Test
	public void test039RedoFunction() {
		String phrase = "redo";
		CommandParser.parseCommand(phrase, 5);
		assertEquals(COMMAND_TYPE.REDO, PublicVariables.commandType);
	}
	
	@Test
	public void test040ShowArchiveFunction() {
		String phrase = "archive";
		CommandParser.parseCommand(phrase, 5);
		assertEquals(COMMAND_TYPE.SHOW_ARCHIVE, PublicVariables.commandType);
	}
	
	@Test
	public void test041HomeFunction() {
		String phrase = "home";
		CommandParser.parseCommand(phrase, 5);
		assertEquals(COMMAND_TYPE.HOME, PublicVariables.commandType);
	}
	
	@Test
	public void test042HideFunction() {
		String phrase = "hide";
		CommandParser.parseCommand(phrase, 5);
		assertEquals(COMMAND_TYPE.HIDE, PublicVariables.commandType);
	}
	
	@Test
	public void test043HelpFunction() {
		String phrase = "help";
		CommandParser.parseCommand(phrase, 5);
		assertEquals(COMMAND_TYPE.HELP, PublicVariables.commandType);
	}
	
	@Test
	public void test044DemoFunction() {
		String phrase = "demo";
		CommandParser.parseCommand(phrase, 5);
		assertEquals(COMMAND_TYPE.DEMO, PublicVariables.commandType);
	}
	
	@Test
	public void test045SetDirectoryFunction() {
		String phrase = "saveto abcd";
		CommandParser.parseCommand(phrase, 5);
		assertEquals(COMMAND_TYPE.SET_DIRECTORY, PublicVariables.commandType);
	}
}
```
###### src\urgenda\parser\commandParser\AddCommandParser.java
``` java
package urgenda.parser.commandParser;

import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import urgenda.command.*;
import urgenda.parser.DateTimeParser;
import urgenda.parser.PublicFunctions;
import urgenda.parser.PublicVariables;
import urgenda.util.Task;
import urgenda.parser.TaskDetailsParser;

public class AddCommandParser {
	private static String _argsString;
	private static int _index;
	private static String descPlaceHolder;

	private static String emptyString = "";
	private static String doubleQuotes = "\"\"";
	private static char singleQuote = '\"';

	/**
	 * public constructor of AddCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public AddCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
		descPlaceHolder = null;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate AddTask object
	 * 
	 * @return AddTask object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			return new Invalid();
		} else {
			String reformattedString = checkSpecialDesc();
			ArrayList<String> reservedWords = getReservedWords();
			reformattedString = PublicFunctions.reformatArgsString(_argsString).trim();
			String reducedArgsString = DateTimeParser.searchTaskTimes(reformattedString);
			reducedArgsString = undoReserveWords(reservedWords, reducedArgsString);
			reducedArgsString = TaskDetailsParser.searchTaskLocation(reducedArgsString);
			TaskDetailsParser.searchTaskDescription(reducedArgsString);
			TaskDetailsParser.searchTaskType();
			return generateAddCommandAndReturn();
		}
	}

	private static Command generateAddCommandAndReturn() {
		Task newTask = new Task();
		if (hasSpecialDesc()) {
			newTask.setDesc(descPlaceHolder.substring(1, descPlaceHolder.length()));
		} else {
			if (hasValidDesc()) {
				newTask.setDesc(PublicVariables.taskDescription);
			}
		}
		if (hasValidLocation()) {
			newTask.setLocation(PublicVariables.taskLocation);
		}
		if (hasValidStartTime()) {
			newTask.setStartTime(PublicVariables.taskStartTime);
		}
		if (hasValidEndTime()) {
			newTask.setEndTime(PublicVariables.taskEndTime);
		}
		if (hasValidSlot()) {
			newTask.setSlot(PublicVariables.taskSlots);
		}

		switch (PublicVariables.taskType) {
		case EVENT:
			newTask.setTaskType(Task.Type.EVENT);
			break;
		case DEADLINE:
			newTask.setTaskType(Task.Type.DEADLINE);
			break;
		case FLOATING:
			newTask.setTaskType(Task.Type.FLOATING);
			break;
		default:
			return new Invalid();
		}
		return new AddTask(newTask);
	}

	private static boolean hasValidSlot() {
		return !PublicVariables.taskSlots.isEmpty();
	}

	private static boolean hasValidEndTime() {
		return PublicVariables.taskEndTime != null;
	}

	private static boolean hasValidStartTime() {
		return PublicVariables.taskStartTime != null;
	}

	private static boolean hasValidLocation() {
		return !PublicVariables.taskLocation.equals(emptyString);
	}

	private static boolean hasValidDesc() {
		return !PublicVariables.taskDescription.equals(emptyString);
	}

	private static boolean hasSpecialDesc() {
		return descPlaceHolder != null && !descPlaceHolder.equals(doubleQuotes);
	}

	private static String checkSpecialDesc() {
		int counter = 0;
		for (int i = 0; i < _argsString.length(); i++) {
			if (_argsString.charAt(i) == singleQuote) {
				counter++;
			}
		}
		if (counter != 2) {
			return _argsString;
		} else {
			int firstOccurence = _argsString.indexOf(singleQuote);
			int secondOccurence = _argsString.indexOf(singleQuote, firstOccurence + 1);
			descPlaceHolder = _argsString.substring(firstOccurence, secondOccurence);
			return _argsString.replace(descPlaceHolder, emptyString);
		}
	}

	private static ArrayList<String> getReservedWords() {
		String specialDescRegex = "([^\\d+\\s+/-:]+)(\\d+)";
		String leftDelimiter = "<";
		String rightDelimiter = ">";
		ArrayList<String> array = new ArrayList<String>();

		Matcher matcher = Pattern.compile(specialDescRegex).matcher(_argsString);
		while (matcher.find()) {
			_argsString = _argsString.replace(matcher.group(), leftDelimiter + matcher.group() + rightDelimiter);
			array.add(leftDelimiter + matcher.group() + rightDelimiter);
		}
		return array;
	}

	private static String undoReserveWords(ArrayList<String> array, String string) {
		for (String arrayString : array) {
			string = string.replace(arrayString, arrayString.substring(1, arrayString.length() - 1));
		}
		return string;
	}
}
```
###### src\urgenda\parser\commandParser\BlockSlotsCommandParser.java
``` java
package urgenda.parser.commandParser;

import java.util.ArrayList;

import urgenda.command.*;
import urgenda.parser.DateTimeParser;
import urgenda.parser.PublicFunctions;
import urgenda.parser.PublicVariables;
import urgenda.parser.TaskDetailsParser;
import urgenda.util.Task;

public class BlockSlotsCommandParser {
	private static String _argsString;
	private static int _index;
	private static String taskDetails;
	private static ArrayList<String> taskTimeStrings;

	private static String timeDelimiter = " at ";
	private static String groupDelimiter = ",";
	private static String emptyString = "";

	/**
	 * public constructor of BlockSlotsCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public BlockSlotsCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate BlockSlots object
	 * 
	 * @return BlockSlots object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			return new Invalid();
		} else {
			reformatArgsString();
			taskTimeStrings = new ArrayList<String>();
			Boolean isConcatSuccess = concatArgsString();
			if (isConcatSuccess) {
				String reducedArgsString = TaskDetailsParser.searchTaskLocation(taskDetails);
				TaskDetailsParser.searchTaskDescription(reducedArgsString);
				TaskDetailsParser.searchTaskType();
				DateTimeParser.searchTaskSlots(taskTimeStrings);
				return generateBlockCommandAndReturn();
			} else {
				return new Invalid();
			}
		}
	}

	private static void reformatArgsString() {
		_argsString = PublicFunctions.reformatArgsString(_argsString).trim();
	}

	private static Boolean concatArgsString() {
		String[] splitString = _argsString.split(timeDelimiter);
		if (splitString.length == 2) {
			try {
				taskDetails = splitString[0];
				String[] timeStrings = splitString[1].split(groupDelimiter);
				for (int i = 0; i < timeStrings.length; i++) {
					taskTimeStrings.add(timeStrings[i]);
				}
				return true;
			} catch (Exception e) {
				return false;
			}
		} else if (splitString.length == 3) {
			try {
				taskDetails = splitString[0] + timeDelimiter + splitString[1];
				String[] timeStrings = splitString[2].split(groupDelimiter);
				for (int i = 0; i < timeStrings.length; i++) {
					taskTimeStrings.add(timeStrings[i]);
				}
				return true;
			} catch (Exception e) {
				return false;
			}
		} else {
			return false;
		}

	}

	private static Command generateBlockCommandAndReturn() {
		Task newTask = new Task();
		if (hasValidDesc()) {
			newTask.setDesc(PublicVariables.taskDescription);
		}
		if (hasValidLocation()) {
			newTask.setLocation(PublicVariables.taskLocation);
		}
		if (hasValidStartTime()) {
			newTask.setStartTime(PublicVariables.taskStartTime);
		}
		if (hasValidEndTime()) {
			newTask.setEndTime(PublicVariables.taskEndTime);
		}
		if (hasValidSlot()) {
			newTask.setSlot(PublicVariables.taskSlots);
		} else {
			return new Invalid();
		}

		switch (PublicVariables.taskType) {
		case EVENT:
			newTask.setTaskType(Task.Type.EVENT);
			break;
		case DEADLINE:
			newTask.setTaskType(Task.Type.DEADLINE);
			break;
		case FLOATING:
			newTask.setTaskType(Task.Type.FLOATING);
			break;
		default:
			return new Invalid();
		}

		BlockSlots blockCommand = new BlockSlots(newTask);
		return blockCommand;
	}

	private static boolean hasValidSlot() {
		return PublicVariables.taskSlots != null;
	}

	private static boolean hasValidEndTime() {
		return PublicVariables.taskEndTime != null;
	}

	private static boolean hasValidStartTime() {
		return PublicVariables.taskStartTime != null;
	}

	private static boolean hasValidLocation() {
		return !PublicVariables.taskLocation.equals(emptyString);
	}

	private static boolean hasValidDesc() {
		return !PublicVariables.taskDescription.equals(emptyString);
	}
}
```
###### src\urgenda\parser\commandParser\CompleteCommandParser.java
``` java
package urgenda.parser.commandParser;

import java.util.ArrayList;

import urgenda.command.*;
import urgenda.parser.PublicVariables;
import urgenda.parser.TaskDetailsParser;

public class CompleteCommandParser {
	private static String _argsString;
	private static int _passedInIndex;

	/**
	 * public constructor of CompleteCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public CompleteCommandParser(String argsString, int index) {
		_argsString = argsString;
		_passedInIndex = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Complete object
	 * 
	 * @return Complete object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			PublicVariables.positions.add(_passedInIndex);
		} else {
			String reducedArgsString = TaskDetailsParser.searchTaskIndexRange(_argsString);
			if (reducedArgsString != null) {
				PublicVariables.positions = new ArrayList<Integer>();
				TaskDetailsParser.searchTaskDescription(_argsString);
			}
		}

		Complete completeCommand = new Complete();
		if (!PublicVariables.positions.isEmpty()) {
			completeCommand.setPositions(PublicVariables.positions);
		} else {
			completeCommand.setDesc(PublicVariables.taskDescription);
		}

		return completeCommand;
	}
}
```
###### src\urgenda\parser\commandParser\ConfirmCommandParser.java
``` java
package urgenda.parser.commandParser;

import java.time.LocalDateTime;
import java.util.Date;
import java.util.List;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;

import urgenda.command.Command;
import urgenda.command.Confirm;
import urgenda.command.Invalid;
import urgenda.parser.DateTimeParser;
import urgenda.parser.PublicFunctions;

public class ConfirmCommandParser {
	private static String _argsString;
	private static int _index;

	/**
	 * public constructor of ConfirmCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public ConfirmCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Confirm object
	 * 
	 * @return Confirm object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			return new Invalid();
		} else {
			_argsString = PublicFunctions.reformatArgsString(_argsString).trim();
			Confirm confirmCommand = new Confirm();
			String firstWord = PublicFunctions.getFirstWord(_argsString);
			try {
				tryParsePassedInIndex(confirmCommand, firstWord);
			} catch (Exception e) {
				confirmCommand.setId(_index);
			}
			if (_argsString != null) {
				PrettyTimeParser parser = new PrettyTimeParser();
				List<Date> dateTimes = parser.parse(_argsString);
				if (dateTimes.size() == 2) {
					return setTimeAndReturn(confirmCommand, dateTimes);
				} else {
					return new Invalid();
				}
			} else {
				return new Invalid();
			}

		}
	}

	private static Command setTimeAndReturn(Confirm confirmCommand, List<Date> dateTimes) {
		LocalDateTime time1 = DateTimeParser.getLocalDateTimeFromDate(dateTimes.get(0));
		LocalDateTime time2 = DateTimeParser.getLocalDateTimeFromDate(dateTimes.get(1));
		confirmCommand.setTimeSlot(PublicFunctions.minTime(time1, time2), PublicFunctions.maxTime(time1, time2));
		return confirmCommand;
	}

	private static void tryParsePassedInIndex(Confirm confirmCommand, String firstWord) {
		int index = Integer.parseInt(firstWord);
		confirmCommand.setId(index - 1);
		_argsString = PublicFunctions.removeFirstWord(_argsString);
	}
}
```
###### src\urgenda\parser\commandParser\DeleteCommandParser.java
``` java
package urgenda.parser.commandParser;

import java.util.ArrayList;

import urgenda.command.*;
import urgenda.parser.PublicVariables;
import urgenda.parser.TaskDetailsParser;

public class DeleteCommandParser {
	private static String _argsString;
	private static int _passedInIndex;

	/**
	 * public constructor of DeleteCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public DeleteCommandParser(String argsString, int index) {
		_argsString = argsString;
		_passedInIndex = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Delete object
	 * 
	 * @return Delete object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			PublicVariables.positions.add(_passedInIndex);
		} else {
			String reducedArgsString = TaskDetailsParser.searchTaskIndexRange(_argsString);
			if (reducedArgsString != null) {
				PublicVariables.positions = new ArrayList<Integer>();
				TaskDetailsParser.searchTaskDescription(_argsString);
			}
		}

		DeleteTask deleteCommand = new DeleteTask();
		if (!PublicVariables.positions.isEmpty()) {
			deleteCommand.setPositions(PublicVariables.positions);
		} else {
			deleteCommand.setDesc(PublicVariables.taskDescription);
		}

		return deleteCommand;
	}
}
```
###### src\urgenda\parser\commandParser\DemoCommandParser.java
``` java
package urgenda.parser.commandParser;

import urgenda.command.Command;
import urgenda.command.Demo;
import urgenda.command.Invalid;

public class DemoCommandParser {
	private static String _argsString;
	private static int _index;

	/**
	 * public constructor of DemoCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public DemoCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Demo object
	 * 
	 * @return Demo object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			return new Demo();
		} else {
			return new Invalid();
		}

	}
}
```
###### src\urgenda\parser\commandParser\ExitCommandParser.java
``` java
package urgenda.parser.commandParser;

import urgenda.command.*;

public class ExitCommandParser {
	private static String _argsString;
	private static int _index;

	/**
	 * public constructor of ExitCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public ExitCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Exit object
	 * 
	 * @return Exit object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			Exit exitCommand = new Exit();
			return exitCommand;
		} else {
			return new Invalid();
		}
	}
}
```
###### src\urgenda\parser\commandParser\FindFreeCommandParser.java
``` java
package urgenda.parser.commandParser;

import urgenda.command.Command;
import urgenda.command.FindFree;
import urgenda.command.Invalid;
import urgenda.parser.DateTimeParser;
import urgenda.parser.PublicFunctions;
import urgenda.parser.PublicVariables;

public class FindFreeCommandParser {
	private static String _argsString;
	private static int _index;

	/**
	 * public constructor of FindFreeCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public FindFreeCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate FindFree object
	 * 
	 * @return FindFree object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			return new Invalid();
		} else {
			_argsString = PublicFunctions.reformatArgsString(_argsString).trim();
			DateTimeParser.searchTaskTimes(_argsString);
			if (hasValidStartAndEndTime()) {
				FindFree findFreeCommand = new FindFree(PublicVariables.taskStartTime, PublicVariables.taskEndTime);
				return findFreeCommand;
			} else {
				return new Invalid();
			}
		}
	}

	private static boolean hasValidStartAndEndTime() {
		return PublicVariables.taskStartTime != null && PublicVariables.taskEndTime != null;
	}
}
```
###### src\urgenda\parser\commandParser\HelpCommandParser.java
``` java
package urgenda.parser.commandParser;

import urgenda.command.Command;
import urgenda.command.Help;
import urgenda.command.Invalid;

public class HelpCommandParser {
	private static String _argsString;
	private static int _index;

	/**
	 * public constructor of HelpCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public HelpCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Help object
	 * 
	 * @return Help object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString != null) {
			return new Invalid();
		} else {
			return new Help();
		}
	}
}
```
###### src\urgenda\parser\commandParser\HideCommandParser.java
``` java
package urgenda.parser.commandParser;

import urgenda.command.Command;
import urgenda.command.Hide;
import urgenda.command.Invalid;

public class HideCommandParser {
	private static String _argsString;
	private static int _index;

	/**
	 * public constructor of HideCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public HideCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Hide object
	 * 
	 * @return Hide object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			return new Hide();
		} else {
			return new Invalid();
		}
	}
}
```
###### src\urgenda\parser\commandParser\HomeCommandParser.java
``` java
package urgenda.parser.commandParser;

import urgenda.command.Command;
import urgenda.command.Home;
import urgenda.command.Invalid;

public class HomeCommandParser {
	private static String _argsString;
	private static int _index;

	/**
	 * public constructor of HomeCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public HomeCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Home object
	 * 
	 * @return Home object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString != null) {
			return new Invalid();
		} else {
			return new Home();
		}
	}
}
```
###### src\urgenda\parser\commandParser\InvalidCommandParser.java
``` java
package urgenda.parser.commandParser;

import urgenda.command.*;

public class InvalidCommandParser {
	private String _argsString;
	private int _index;

	/**
	 * public constructor of InvalidCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public InvalidCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that returns an Invalid object
	 * 
	 * @return Invalid object
	 */
	public static Command generateAndReturn() {
		return new Invalid();
	}
}
```
###### src\urgenda\parser\commandParser\NewEditCommandParser.java
``` java
package urgenda.parser.commandParser;

import java.time.LocalDateTime;
import java.util.Date;
import java.util.List;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;
import org.ocpsoft.prettytime.nlp.parse.DateGroup;

import urgenda.command.*;
import urgenda.parser.DateTimeParser;
import urgenda.parser.PublicFunctions;
import urgenda.util.Task;

public class NewEditCommandParser {
	private static String _argsString;
	private static int _index;

	private static enum TIME_TYPE {
		START_TIME, END_TIME
	}

	private static String startFlagRegex = "(-s)|(-s:)|(from)";
	private static String endFlagRegex = "(-e)|(-e:)|(to)|(by)";
	private static String removeFlagRegex = "((-r)|(-rm))";
	private static String locationRegex = "(@)";
	private static String combinedRegex = "((\\A|\\D)(" + startFlagRegex + "|" + endFlagRegex + ")(\\Z|\\D))|"
			+ locationRegex;

	private static LocalDateTime startTime;
	private static LocalDateTime endTime;
	private static LocalDateTime unknownTime;
	private static String descString;
	private static String location;
	private static Integer index;
	private static int numberOfRemoveFlag = 0;

	/**
	 * public constructor of NewEditCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public NewEditCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Edit object
	 * 
	 * @return Edit object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			return new Invalid();
		} else {
			reinitializeVariables();

			_argsString = PublicFunctions.reformatArgsString(_argsString).trim();
			String reducedString = searchIndex();
			reducedString = countRmFlag(reducedString);
			searchDetails(reducedString);

			Edit editCommand = new Edit();
			Task newTask = new Task();
			if (startTime != null) {
				newTask.setStartTime(startTime);
			}
			if (endTime != null) {
				newTask.setEndTime(endTime);
			}
			if (descString != null) {
				newTask.setDesc(descString);
			}
			if (location != null) {
				newTask.setLocation(location);
			}
			if (unknownTime != null) {
				editCommand.setUnknown(unknownTime);
			}
			if (index != null) {
				editCommand.setId(index);
			} else {
				editCommand.setId(_index);
			}
			editCommand.setNewTask(newTask);

			switch (numberOfRemoveFlag) {
			case 0:
				return editCommand;
			case 1:
				editCommand.setIsRemovedOnce();
				return editCommand;
			case 2:
				editCommand.setIsRemovedOnce();
				editCommand.setIsRemovedTwice();
				return editCommand;
			case 3:
				return new Invalid();
			}
		}
		return new Invalid();
	}

	private static String countRmFlag(String reducedString) {
		String removeFlagRegex2 = "-r";
		String removeFlagRegex1 = "-rm";
		String temp = reducedString;
		String combinedRegex = "(" + removeFlagRegex2 + "|" + removeFlagRegex1 + ")";
		int count = 0;

		if (reducedString != null) {
			int index = reducedString.indexOf(removeFlagRegex1);
			while (index != -1) {
				count++;
				if (reducedString.length() - 1 >= index + 3) {
					reducedString = reducedString.substring(0, index) + reducedString.substring(index + 3);
				} else {
					reducedString = reducedString.substring(0, index);
				}
				index = reducedString.indexOf(removeFlagRegex1);
			}

			index = reducedString.indexOf(removeFlagRegex2);
			while (index != -1) {
				count++;
				if (reducedString.length() - 1 >= index + 2) {
					reducedString = reducedString.substring(0, index) + reducedString.substring(index + 2);
				} else {
					reducedString = reducedString.substring(0, index);
				}
				index = reducedString.indexOf(removeFlagRegex2);
			}
			numberOfRemoveFlag = count;
			return reducedString.trim();
		} else {
			return null;
		}
	}

	private static String searchIndex() {
		String firstWord = PublicFunctions.getFirstWord(_argsString);
		try {
			index = Integer.parseInt(firstWord) - 1;
			return PublicFunctions.removeFirstWord(_argsString);
		} catch (Exception e) {
			return _argsString;
		}
	}

	private static void searchDetails(String argsString) {
		if (argsString != null) {
			String temp = argsString;
			String[] stringArray = temp.trim().split(combinedRegex);

			if (stringArray.length == 0) {
				parseTimeWithoutKeyWord(temp);
			} else {
				parseDetailsWithKeyWords(temp, stringArray);
			}
		}
	}

	private static void parseDetailsWithKeyWords(String temp, String[] stringArray) {
		for (int i = 0; i < stringArray.length; i++) {
			parseSeparatedDetailStrings(temp, stringArray, i);
		}
	}

	private static void parseSeparatedDetailStrings(String temp, String[] stringArray, int i) {
		int position = temp.indexOf(stringArray[i].trim());
		String preceedingWord = PublicFunctions.getPreceedingWord(position, temp);

		if (isAfterStartFlag(preceedingWord)) {
			startTime = parseStartTime(stringArray[i].trim());
		} else if (isAfterEndFlag(preceedingWord)) {
			endTime = parseEndTime(stringArray[i].trim());
		} else if (isAfterLocationFlag(preceedingWord)) {
			location = stringArray[i].trim();
		} else {
			parseDetailsWithoutPreceedingKeyWord(stringArray, i);
		}
	}

	private static void parseDetailsWithoutPreceedingKeyWord(String[] stringArray, int i) {
		String removeFlagWithBoundsRegex = "(\\A|\\D)((-rm)|(-r))(\\Z|\\D)";
		String removeFlagRegex = "((-rm)|(-r))";
		String emptyString = "";

		String argsStringWithoutFlags = stringArray[i].replaceAll(removeFlagWithBoundsRegex, emptyString).trim();
		unknownTime = parseUnknownTime(argsStringWithoutFlags);
		if (isFirstGroupOrParseUnknownFail(i)) {
			String[] array = stringArray[i].split(removeFlagWithBoundsRegex);
			if (array.length == 2) {
				unknownTime = parseUnknownTime(array[1].trim());
				if (unknownTime != null) {
					descString = array[0];
				} else {
					descString = stringArray[i].trim();
				}
			} else {
				descString = stringArray[i].replaceAll(removeFlagRegex, emptyString).trim();
			}
		}
	}

	private static boolean isAfterLocationFlag(String preceedingWord) {
		String locationKeyWord = "@";
		return preceedingWord.equals(locationKeyWord);
	}

	private static boolean isAfterEndFlag(String preceedingWord) {
		String endFlag1 = "-e";
		String endFlag2 = "-e:";
		String endFlag3 = "to";
		String endFlag4 = "by";
		return preceedingWord.equals(endFlag1) || preceedingWord.equals(endFlag2) || preceedingWord.equals(endFlag3)
				|| preceedingWord.equals(endFlag4);
	}

	private static boolean isAfterStartFlag(String preceedingWord) {
		String startFlag1 = "-s";
		String startFlag2 = "-s:";
		String startFlag3 = "from";
		return preceedingWord.equals(startFlag1) || preceedingWord.equals(startFlag2)
				|| preceedingWord.equals(startFlag3);
	}

	private static boolean isFirstGroupOrParseUnknownFail(int i) {
		return i == 0 && unknownTime == null;
	}

	private static void parseTimeWithoutKeyWord(String temp) {
		unknownTime = parseUnknownTime(temp);
	}

	private static LocalDateTime parseStartTime(String argsString) {
		return parseTime(argsString, TIME_TYPE.START_TIME);
	}

	private static LocalDateTime parseEndTime(String argsString) {
		return parseTime(argsString, TIME_TYPE.END_TIME);
	}

	private static LocalDateTime parseTime(String argsString, TIME_TYPE timeType) {
		List<DateGroup> dateGroups = new PrettyTimeParser().parseSyntax(argsString);
		if (isValidArgsStringForTimeParse(argsString, dateGroups)) {
			Date firstParseDate = dateGroups.get(0).getDates().get(0);
			LocalDateTime localDateTime = PublicFunctions.getLocalDateTimeFromDate(firstParseDate);
			if (isCompleteDate(argsString, dateGroups)) {
				return localDateTime;
			} else {
				if (timeType == TIME_TYPE.START_TIME) {
					return DateTimeParser.adjustedDateEvent(localDateTime);
				} else {
					return DateTimeParser.adjustedDateDeadline(localDateTime);
				}
			}
		}
		return null;
	}

	private static boolean isCompleteDate(String argsString, List<DateGroup> dateGroups) {
		List<DateGroup> dateGroups2 = new PrettyTimeParser().parseSyntax(argsString);
		Date firstParseDate = dateGroups.get(0).getDates().get(0);
		Date secondParseDate = dateGroups2.get(0).getDates().get(0);
		return firstParseDate.equals(secondParseDate);
	}

	private static LocalDateTime parseUnknownTime(String argsString) {
		List<DateGroup> dateGroups = new PrettyTimeParser().parseSyntax(argsString);
		if (dateGroups.size() == 1) {
			String parsedString = dateGroups.get(0).getText();
			if (dateGroups.get(0).getDates().size() == 1 && parsedString.trim().equals(argsString)) {
				Date parseDate = dateGroups.get(0).getDates().get(0);
				LocalDateTime localDateTime = PublicFunctions.getLocalDateTimeFromDate(parseDate);
				return localDateTime;
			}
		}
		return null;
	}

	private static boolean isValidArgsStringForTimeParse(String argsString, List<DateGroup> dateGroups) {
		if (dateGroups.size() == 1) {
			String parsedString = dateGroups.get(0).getText();
			if (dateGroups.get(0).getDates().size() == 1 && parsedString.trim().equals(argsString)) {
				return true;
			}
		}
		return false;
	}

	private static void reinitializeVariables() {
		startTime = null;
		endTime = null;
		unknownTime = null;
		descString = null;
		location = null;
		index = null;
		numberOfRemoveFlag = 0;
	}
}
```
###### src\urgenda\parser\commandParser\PostponeCommandParser.java
``` java
package urgenda.parser.commandParser;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import urgenda.command.*;

public class PostponeCommandParser {
	private static String _argsString;
	private static int _index;

	private static String secondRegex = "((\\d+)( )?((second(s)?)|s|(sec(s)?)))";
	private static String minuteRegex = "((\\d+)( )?((minute(s)?)|(min(s)?)|m))";
	private static String hourRegex = "((\\d+)( )?((hour(s)?)|(hr(s)?)|h))";
	private static String dayRegex = "((\\d+)( )?((day(s)?)|d))";
	private static String monthRegex = "((\\d+)( )?((month(s)?)|(mth(s)?)))";
	private static String yearRegex = "((\\d+)( )?((year(s)?)|(yr(s)?)|y))";
	private static String nonDigitRegex = "\\D+";

	private static String emptyString = "";
	private static String timeDelimiter = "by";

	private static String secondString;
	private static String minuteString;
	private static String hourString;
	private static String dayString;
	private static String monthString;
	private static String yearString;
	private static String reducedArgsString;

	private static Integer second;
	private static Integer minute;
	private static Integer hour;
	private static Integer day;
	private static Integer month;
	private static Integer year;

	/**
	 * public constructor of PostponeCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public PostponeCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Postpone object
	 * 
	 * @return Postpone object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			return new Invalid();
		} else {
			reinitializeVariables();

			reducedArgsString = _argsString;
			Matcher matcher = Pattern.compile(monthRegex).matcher(reducedArgsString);
			if (matcher.find()) {
				monthString = matcher.group();
				reducedArgsString = reducedArgsString.replace(matcher.group(), emptyString);
			}
			matcher = Pattern.compile(secondRegex).matcher(reducedArgsString);
			if (matcher.find()) {
				secondString = matcher.group();
				reducedArgsString = _argsString.replace(matcher.group(), emptyString);
			}
			matcher = Pattern.compile(minuteRegex).matcher(reducedArgsString);
			if (matcher.find()) {
				minuteString = matcher.group();
				reducedArgsString = reducedArgsString.replace(matcher.group(), emptyString);
			}
			matcher = Pattern.compile(hourRegex).matcher(reducedArgsString);
			if (matcher.find()) {
				hourString = matcher.group();
				reducedArgsString = reducedArgsString.replace(matcher.group(), emptyString);
			}
			matcher = Pattern.compile(dayRegex).matcher(reducedArgsString);
			if (matcher.find()) {
				dayString = matcher.group();
				reducedArgsString = reducedArgsString.replace(matcher.group(), emptyString);
			}
			matcher = Pattern.compile(yearRegex).matcher(reducedArgsString);
			if (matcher.find()) {
				yearString = matcher.group();
				reducedArgsString = reducedArgsString.replace(matcher.group(), emptyString);
			}

			Postpone postponeCommand = new Postpone();
			reducedArgsString = reducedArgsString.replace(timeDelimiter, emptyString).trim();
			if (reducedArgsString.equals(emptyString)) {
				postponeCommand.setId(_index);
			} else {
				try {
					int index = Integer.parseInt(reducedArgsString.trim());
					postponeCommand.setId(index - 1);
				} catch (Exception e) {
					return new Invalid();
				}
			}

			try {
				if (secondString != null) {
					postponeCommand.setSecond(getIntPart(secondString));
				}
				if (minuteString != null) {
					postponeCommand.setMinute(getIntPart(minuteString));
				}
				if (hourString != null) {
					postponeCommand.setHour(getIntPart(hourString));
				}
				if (dayString != null) {
					postponeCommand.setDay(getIntPart(dayString));
				}
				if (monthString != null) {
					postponeCommand.setMonth(getIntPart(monthString));
				}
				if (yearString != null) {
					postponeCommand.setYear(getIntPart(yearString));
				}
				return postponeCommand;
			} catch (Exception e) {
				return new Invalid();
			}
		}
	}

	private static int getIntPart(String string) {
		string = string.replaceAll(nonDigitRegex, emptyString);
		return Integer.parseInt(string);
	}

	private static void reinitializeVariables() {
		second = null;
		minute = null;
		hour = null;
		day = null;
		month = null;
		year = null;
		secondString = null;
		minuteString = null;
		hourString = null;
		dayString = null;
		monthString = null;
		yearString = null;
		reducedArgsString = null;
	}
}
```
###### src\urgenda\parser\commandParser\PrioritiseCommandParser.java
``` java
package urgenda.parser.commandParser;

import java.util.ArrayList;

import urgenda.command.*;
import urgenda.parser.PublicVariables;
import urgenda.parser.TaskDetailsParser;

public class PrioritiseCommandParser {
	private static String _argsString;
	private static int _passedInIndex;

	/**
	 * public constructor of PrioritiseCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public PrioritiseCommandParser(String argsString, int index) {
		_argsString = argsString;
		_passedInIndex = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Prioritise object
	 * 
	 * @return Prioritise object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			PublicVariables.positions.add(_passedInIndex);
		} else {
			String reducedArgsString = TaskDetailsParser.searchTaskIndexRange(_argsString);
			if (reducedArgsString != null) {
				PublicVariables.positions = new ArrayList<Integer>();
				TaskDetailsParser.searchTaskDescription(_argsString);
			}
		}

		Prioritise priCommand = new Prioritise();
		if (!PublicVariables.positions.isEmpty()) {
			priCommand.setPositions(PublicVariables.positions);
		} else {
			priCommand.setDesc(PublicVariables.taskDescription);
		}

		return priCommand;
	}
}
```
###### src\urgenda\parser\commandParser\RedoCommandParser.java
``` java
package urgenda.parser.commandParser;

import urgenda.command.*;

public class RedoCommandParser {
	private static String _argsString;
	private static int _index;

	/**
	 * public constructor of RedoCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public RedoCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Redo object
	 * 
	 * @return Redo object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			Redo redoCommand = new Redo();
			return redoCommand;
		} else {
			return new Invalid();
		}
	}
}
```
###### src\urgenda\parser\commandParser\SearchCommandParser.java
``` java
package urgenda.parser.commandParser;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Month;

import urgenda.command.*;
import urgenda.parser.DateTimeParser;
import urgenda.parser.PublicFunctions;
import urgenda.parser.PublicVariables;
import urgenda.parser.TaskDetailsParser;

public class SearchCommandParser {
	private static String _argsString;
	private static int _index;

	/**
	 * public constructor of SearchCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public SearchCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Search object
	 * 
	 * @return Search object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			return new Invalid();
		} else {
			try {
				return tryParseTaskID();
			} catch (Exception e) {
				return parseSearchCriteria();
			}
		}
	}

	private static Command parseSearchCriteria() {
		_argsString = PublicFunctions.reformatArgsString(_argsString).trim();
		Search searchCommand = new Search();
		Month testMonth = DateTimeParser.tryParseMonth(_argsString);
		LocalDateTime testTime = DateTimeParser.tryParseTime(_argsString);
		LocalDate testDate = DateTimeParser.tryParseDate(_argsString);
		if (testMonth != null) {
			searchCommand.setSearchMonth(testMonth);
		} else if (testTime != null) {
			searchCommand.setSearchDateTime(testTime);
		} else if (testDate != null) {
			searchCommand.setSearchDate(testDate);
		} else {
			TaskDetailsParser.searchTaskDescription(_argsString);
			searchCommand.setSearchInput(PublicVariables.taskDescription);
		}
		return searchCommand;
	}

	private static Command tryParseTaskID() {
		int searchID = Integer.parseInt(_argsString.trim());
		Search searchCommand = new Search();
		searchCommand.setSearchId(searchID - 1);
		return searchCommand;
	}
}
```
###### src\urgenda\parser\commandParser\SetDirectoryCommandParser.java
``` java
package urgenda.parser.commandParser;

import urgenda.command.Command;
import urgenda.command.Invalid;
import urgenda.command.SetDirectory;

public class SetDirectoryCommandParser {
	private static String _argsString;
	private static int _index;

	/**
	 * public constructor of SetDirectoryCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public SetDirectoryCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	public static Command generateAndReturn() {
		if (_argsString != null) {
			SetDirectory setDirectoryCommand = new SetDirectory(_argsString);
			return setDirectoryCommand;
		} else {
			return new Invalid();
		}

	}
}
```
###### src\urgenda\parser\commandParser\ShowArchiveCommandParser.java
``` java
package urgenda.parser.commandParser;

import urgenda.command.*;

public class ShowArchiveCommandParser {
	private static String _argsString;
	private static int _index;

	/**
	 * public constructor of ShowArchiveCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public ShowArchiveCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate ShowArchive object
	 * 
	 * @return ShowArchive object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			ShowArchive showArchiveCommand = new ShowArchive();
			return showArchiveCommand;
		} else {
			return new Invalid();
		}
	}
}
```
###### src\urgenda\parser\commandParser\ShowDetailsCommandParser.java
``` java
package urgenda.parser.commandParser;

import urgenda.command.*;
import urgenda.parser.PublicVariables;
import urgenda.parser.TaskDetailsParser;

public class ShowDetailsCommandParser {
	private static String _argsString;
	private static int _passedInIndex;

	/**
	 * public constructor of ShowDetailsCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public ShowDetailsCommandParser(String argsString, int index) {
		_argsString = argsString;
		_passedInIndex = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate ShowDetails object
	 * 
	 * @return ShowDetails object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			PublicVariables.positions.add(_passedInIndex);
		} else {
			String reducedArgsString = TaskDetailsParser.searchTaskIndexRange(_argsString);
			if (reducedArgsString != null) {
				return new Invalid();
			}
		}

		ShowDetails showDetailsCommand = new ShowDetails();
		if (!PublicVariables.positions.isEmpty()) {
			showDetailsCommand.setPosition(PublicVariables.positions);
		} else {
			return new Invalid();
		}

		return showDetailsCommand;
	}
}
```
###### src\urgenda\parser\commandParser\UndoCommandParser.java
``` java
package urgenda.parser.commandParser;

import urgenda.command.*;

public class UndoCommandParser {
	private static String _argsString;
	private static int _index;

	/**
	 * public constructor of UndoCommandParser
	 * 
	 * @param argsString
	 *            argument string to be parsed
	 * @param index
	 *            location of currently highlighted task
	 */
	public UndoCommandParser(String argsString, int index) {
		_argsString = argsString;
		_index = index;
	}

	/**
	 * function that parses the passed in argument string to generate an return
	 * an appropriate Undo object
	 * 
	 * @return Undo object with parsed details stored in its attributes
	 */
	public static Command generateAndReturn() {
		if (_argsString == null) {
			Undo undoCommand = new Undo();
			return undoCommand;
		} else {
			return new Invalid();
		}
	}
}
```
###### src\urgenda\parser\CommandParser.java
``` java
package urgenda.parser;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import urgenda.command.*;
import urgenda.parser.PublicVariables.*;
import urgenda.parser.commandParser.AddCommandParser;
import urgenda.parser.commandParser.BlockSlotsCommandParser;
import urgenda.parser.commandParser.CompleteCommandParser;
import urgenda.parser.commandParser.ConfirmCommandParser;
import urgenda.parser.commandParser.DeleteCommandParser;
import urgenda.parser.commandParser.DemoCommandParser;
import urgenda.parser.commandParser.ExitCommandParser;
import urgenda.parser.commandParser.FindFreeCommandParser;
import urgenda.parser.commandParser.HelpCommandParser;
import urgenda.parser.commandParser.HideCommandParser;
import urgenda.parser.commandParser.HomeCommandParser;
import urgenda.parser.commandParser.InvalidCommandParser;
import urgenda.parser.commandParser.NewEditCommandParser;
import urgenda.parser.commandParser.PostponeCommandParser;
import urgenda.parser.commandParser.PrioritiseCommandParser;
import urgenda.parser.commandParser.RedoCommandParser;
import urgenda.parser.commandParser.SearchCommandParser;
import urgenda.parser.commandParser.SetDirectoryCommandParser;
import urgenda.parser.commandParser.ShowArchiveCommandParser;
import urgenda.parser.commandParser.ShowDetailsCommandParser;
import urgenda.parser.commandParser.UndoCommandParser;
import urgenda.util.*;

public class CommandParser {
	private static String _argsString;

	private static String deadlineKeyWordRegex = "\\s+by(\\s+|\\Z)";
	private static String reservedWordsRegex = "([^\\d+\\s+/-:]+)(\\d+)";

	/**
	 * This is the function to parse the commands given by logic when user hits
	 * enter
	 * 
	 * @param commandString
	 *            The command string being parsed
	 * @param index
	 *            The passed in index of the currently selected task, can be
	 *            used as parameter for certain commands
	 * @return the appropriate command objects with all the parsed attributes
	 */
	public static Command parseCommand(String commandString, int index) {
		PublicFunctions.reinitializePublicVariables();

		PublicVariables.commandType = CommandTypeParser.getCommandType(commandString);
		String argsString = CommandTypeParser.getArgsString(commandString);
		Command testReturn = generateAndReturnCommandObjects(PublicVariables.commandType, argsString, index);

		if (testReturn instanceof Invalid) {
			PublicFunctions.reinitializePublicVariables();
			return generateAddCommandAndReturn(commandString, index);
		} else {
			return testReturn;
		}
	}

	/**
	 * This is the function to parse the commands as they were being typed into
	 * the command line in order to give feedback and suggestions to the user
	 * 
	 * @param commandString
	 *            the command currently present on the command line when a
	 *            keystroke is registered
	 * @return the SuggestCommand object that contains relevant information,
	 *         such as suggested keywords, direction of input
	 */
	public static SuggestCommand parseRuntimeInput(String commandString) {
		if (isCommandStringValid(commandString)) {
			PublicFunctions.reinitializePublicVariables();
			commandString = formatCommandString(commandString);
			COMMAND_TYPE commandType = CommandTypeParser.getCommandType(commandString);
			return generateSuggestCommandAndReturn(commandString, commandType);
		} else {
			return new SuggestCommand(null, null, null);
		}
	}

	private static SuggestCommand generateSuggestCommandAndReturn(String commandString, COMMAND_TYPE commandType) {
		if (isInvalidCommandType(commandType)) {
			return handleReturnOfInvalidCommandType(commandString);
		} else {
			return handleReturnOfValidCommandType(commandString, commandType);
		}
	}

	private static SuggestCommand handleReturnOfInvalidCommandType(String commandString) {
		int numberOfWords = PublicFunctions.getNumberOfWords(commandString);
		if (numberOfWords == 1) {
			return handleReturnOfOneWordString(commandString);
		} else {
			return handleReturnOfMultipleWordString(commandString);
		}
	}

	private static SuggestCommand handleReturnOfValidCommandType(String commandString, COMMAND_TYPE commandType) {
		SuggestCommand.Command command = convertCommandType(commandType);
		SuggestCommand suggestCommand;
		if (command != null) {
			suggestCommand = new SuggestCommand(command, null, PublicFunctions.getFirstWord(commandString));
		} else {
			suggestCommand = new SuggestCommand(null, null, null);
		}
		return checkEventOrDeadlineAndReturn(commandString, suggestCommand);
	}

	private static SuggestCommand handleReturnOfOneWordString(String commandString) {
		SuggestCommand suggestCommand;
		String firstWord = PublicFunctions.getFirstWord(commandString).trim();
		ArrayList<String> possibleCommands = getPossibleCommands(firstWord);
		if (!possibleCommands.isEmpty()) {
			suggestCommand = new SuggestCommand(null, possibleCommands, null);
		} else {
			suggestCommand = new SuggestCommand(null, null, null);
		}
		return checkEventOrDeadlineAndReturn(commandString, suggestCommand);
	}

	private static SuggestCommand handleReturnOfMultipleWordString(String commandString) {
		SuggestCommand suggestCommand = new SuggestCommand(null, null, null);
		return checkEventOrDeadlineAndReturn(commandString, suggestCommand);
	}

	private static SuggestCommand.Command convertCommandType(COMMAND_TYPE commandType) {
		SuggestCommand.Command command = null;
		switch (commandType) {
		case ADD:
			command = SuggestCommand.Command.ADD;
			break;
		case COMPLETE:
			command = SuggestCommand.Command.DONE;
			break;
		case DELETE:
			command = SuggestCommand.Command.DELETE;
			break;
		case EDIT:
			command = SuggestCommand.Command.EDIT;
			break;
		case EXIT:
			command = SuggestCommand.Command.EXIT;
			break;
		case PRIORITISE:
			command = SuggestCommand.Command.PRIORITISE;
			break;
		case REDO:
			command = SuggestCommand.Command.REDO;
			break;
		case SEARCH:
			command = SuggestCommand.Command.SEARCH;
			break;
		case SHOW_ARCHIVE:
			command = SuggestCommand.Command.ARCHIVE;
			break;
		case SHOW_DETAILS:
			command = SuggestCommand.Command.SHOWMORE;
			break;
		case BLOCK:
			command = SuggestCommand.Command.BLOCK;
			break;
		case FIND_FREE:
			command = SuggestCommand.Command.FIND_FREE;
			break;
		case HOME:
			command = SuggestCommand.Command.HOME;
			break;
		case UNDO:
			command = SuggestCommand.Command.UNDO;
			break;
		case POSTPONE:
			command = SuggestCommand.Command.POSTPONE;
			break;
		case CONFIRM:
			command = SuggestCommand.Command.CONFIRM;
			break;
		case SET_DIRECTORY:
			command = SuggestCommand.Command.SAVETO;
			break;
		case HELP:
			command = SuggestCommand.Command.HELP;
			break;
		case DEMO:
			command = SuggestCommand.Command.DEMO;
			break;
		case HIDE:
			command = SuggestCommand.Command.HIDE;
			break;
		default:
			break;
		}
		return command;
	}

	private static ArrayList<String> getPossibleCommands(String commandString) {
		ArrayList<String> returnedArray = new ArrayList<String>();

		Set<Set<String>> commandSet = new HashSet<Set<String>>();
		commandSet.add(PublicVariables.addKeyWords);
		commandSet.add(PublicVariables.deleteKeyWords);
		commandSet.add(PublicVariables.doneKeyWords);
		commandSet.add(PublicVariables.updateKeyWords);
		commandSet.add(PublicVariables.exitKeyWords);
		commandSet.add(PublicVariables.prioritiseKeyWords);
		commandSet.add(PublicVariables.redoKeywords);
		commandSet.add(PublicVariables.undoKeywords);
		commandSet.add(PublicVariables.searchKeyWords);
		commandSet.add(PublicVariables.undoKeywords);
		commandSet.add(PublicVariables.helpKeyWords);
		commandSet.add(PublicVariables.homeKeyWords);
		commandSet.add(PublicVariables.blockKeyWords);
		commandSet.add(PublicVariables.confirmKeyWords);
		commandSet.add(PublicVariables.postponeKeyWords);
		commandSet.add(PublicVariables.setDirectoryKeyWords);
		commandSet.add(PublicVariables.showDetailsKeyWords);
		commandSet.add(PublicVariables.archiveKeyWords);
		commandSet.add(PublicVariables.findFreeKeyWords);
		commandSet.add(PublicVariables.hideKeyWords);
		commandSet.add(PublicVariables.demoKeyWords);

		for (Set<String> setString : commandSet) {
			for (String string : setString) {
				if (string.length() > commandString.length() && commandString.length() != 0) {
					if (string.substring(0, commandString.length()).equals(commandString)) {
						returnedArray.add(string);
					}
				}
			}
		}

		return returnedArray;
	}

	private static Command generateAndReturnCommandObjects(COMMAND_TYPE commandType, String argsString, int index) {
		switch (commandType) {
		case ADD:
			AddCommandParser addCommand = new AddCommandParser(argsString, index);
			return addCommand.generateAndReturn();
		case COMPLETE:
			CompleteCommandParser completeCommand = new CompleteCommandParser(argsString, index);
			return completeCommand.generateAndReturn();
		case DELETE:
			DeleteCommandParser deleteCommand = new DeleteCommandParser(argsString, index);
			return deleteCommand.generateAndReturn();
		case EDIT:
			NewEditCommandParser editCommand = new NewEditCommandParser(argsString, index);
			return editCommand.generateAndReturn();
		case EXIT:
			ExitCommandParser exitCommand = new ExitCommandParser(argsString, index);
			return exitCommand.generateAndReturn();
		case INVALID:
			InvalidCommandParser invalidCommand = new InvalidCommandParser(argsString, index);
			return invalidCommand.generateAndReturn();
		case PRIORITISE:
			PrioritiseCommandParser priCommand = new PrioritiseCommandParser(argsString, index);
			return priCommand.generateAndReturn();
		case REDO:
			RedoCommandParser redoCommand = new RedoCommandParser(argsString, index);
			return redoCommand.generateAndReturn();
		case SEARCH:
			SearchCommandParser searchCommand = new SearchCommandParser(argsString, index);
			return searchCommand.generateAndReturn();
		case SHOW_ARCHIVE:
			ShowArchiveCommandParser showArchiveCommand = new ShowArchiveCommandParser(argsString, index);
			return showArchiveCommand.generateAndReturn();
		case SHOW_DETAILS:
			ShowDetailsCommandParser showDetailsCommand = new ShowDetailsCommandParser(argsString, index);
			return showDetailsCommand.generateAndReturn();
		case BLOCK:
			BlockSlotsCommandParser blockCommand = new BlockSlotsCommandParser(argsString, index);
			return blockCommand.generateAndReturn();
		case FIND_FREE:
			FindFreeCommandParser findFreeCommand = new FindFreeCommandParser(argsString, index);
			return findFreeCommand.generateAndReturn();
		case HOME:
			HomeCommandParser homeCommand = new HomeCommandParser(argsString, index);
			return homeCommand.generateAndReturn();
		case UNDO:
			UndoCommandParser undoCommand = new UndoCommandParser(argsString, index);
			return undoCommand.generateAndReturn();
		case POSTPONE:
			PostponeCommandParser postponeCommand = new PostponeCommandParser(argsString, index);
			return postponeCommand.generateAndReturn();
		case CONFIRM:
			ConfirmCommandParser confirmCommand = new ConfirmCommandParser(argsString, index);
			return confirmCommand.generateAndReturn();
		case SET_DIRECTORY:
			SetDirectoryCommandParser setDirectoryCommand = new SetDirectoryCommandParser(argsString, index);
			return setDirectoryCommand.generateAndReturn();
		case HELP:
			HelpCommandParser helpCommand = new HelpCommandParser(argsString, index);
			return helpCommand.generateAndReturn();
		case DEMO:
			DemoCommandParser demoCommand = new DemoCommandParser(argsString, index);
			return demoCommand.generateAndReturn();
		case HIDE:
			HideCommandParser hideCommand = new HideCommandParser(argsString, index);
			return hideCommand.generateAndReturn();
		default:
			return null;
		}
	}

	private static boolean isDeadline(String string) {
		String lastWord = PublicFunctions.getLastWord(string);
		if (isLastWordDeadlineKeyWord(lastWord)) {
			return true;
		} else {
			return handleDeadlineCheckForNonKeyWordLastWord(string);
		}
	}

	private static boolean isEvent(String string) {
		String lastWord = PublicFunctions.getLastWord(string);
		if (isLastWordEventKeyWord(lastWord)) {
			return true;
		} else {
			return handleEventCheckForNonKeyWordLastWord(string);
		}
	}

	private static boolean handleDeadlineCheckForNonKeyWordLastWord(String string) {
		Matcher matcher = Pattern.compile(deadlineKeyWordRegex).matcher(string);
		if (matcher.find()) {
			return true;
		} else {
			return false;
		}
	}

	private static Boolean handleEventCheckForNonKeyWordLastWord(String string) {
		COMMAND_TYPE commandType = CommandTypeParser.getCommandType(string);
		if (commandType != COMMAND_TYPE.INVALID) {
			string = PublicFunctions.removeFirstWord(string);
			try {
				String firstWord = PublicFunctions.getFirstWord(string);
				Integer.parseInt(firstWord);
				string = PublicFunctions.removeFirstWord(string);
			} catch (Exception e) {

			}
		}
		
		if (string != null && !string.equals("")) {
			DateTimeParser.searchTaskTimes(string);
			if (PublicVariables.taskStartTime != null) {
				return true;
			} else {
				if (string.charAt(string.length() - 1) == ' ') {
					return false;
				} else {
					String secondLastWord = PublicFunctions.getSecondLastWord(string);
					if (PublicVariables.startTimeWords.contains(secondLastWord)
							|| PublicVariables.periodWords.contains(secondLastWord)) {
						return true;
					} else {
						return false;
					}
				}
			}
		} else {
			return false;
		}
	}

	private static Command generateAddCommandAndReturn(String commandString, int index) {
		PublicVariables.commandType = COMMAND_TYPE.ADD;
		AddCommandParser addCommand = new AddCommandParser(commandString, index);
		return addCommand.generateAndReturn();
	}

	private static ArrayList<String> getReservedWords() {
		ArrayList<String> array = new ArrayList<String>();
		Matcher matcher = Pattern.compile(reservedWordsRegex).matcher(_argsString);
		while (matcher.find()) {
			_argsString = _argsString.replace(matcher.group(), "<" + matcher.group() + ">");
			array.add("<" + matcher.group() + ">");
		}

		return array;
	}

	private static String formatCommandString(String commandString) {
		commandString = commandString.toLowerCase();
		commandString = PublicFunctions.reformatArgsString(commandString);
		commandString = reserveSpecialWords(commandString);
		return commandString;
	}

	private static String reserveSpecialWords(String commandString) {
		_argsString = commandString;
		getReservedWords();
		commandString = _argsString;
		return commandString;
	}

	private static Boolean isCommandStringValid(String commandString) {
		return (commandString.length() > 0 && !commandString.trim().equals(""));
	}

	private static Boolean isLastWordEventKeyWord(String lastWord) {
		return (PublicVariables.startTimeWords.contains(lastWord) || PublicVariables.periodWords.contains(lastWord));
	}

	private static Boolean isLastWordDeadlineKeyWord(String lastWord) {
		return PublicVariables.endTimeWords.contains(lastWord);
	}

	private static Boolean isInvalidCommandType(COMMAND_TYPE commandType) {
		return commandType == COMMAND_TYPE.INVALID;
	}

	private static SuggestCommand checkEventOrDeadlineAndReturn(String commandString, SuggestCommand suggestCommand) {
		if (commandString != null) {
			boolean isDeadline = isDeadline(commandString);
			boolean isEvent = isEvent(commandString);
			suggestCommand.setDeadline(isDeadline);
			suggestCommand.setEvent(isEvent);
		}
		return suggestCommand;
	}
}
```
###### src\urgenda\parser\CommandTypeParser.java
``` java
package urgenda.parser;

import urgenda.parser.PublicVariables.*;

public class CommandTypeParser {

	/**
	 * This function parses the command string to determine the type of command
	 * being input
	 * 
	 * @param commandString
	 *            The user's input command string
	 * @return The enum for the type of command of the input
	 */
	public static COMMAND_TYPE getCommandType(String commandString) {
		String lowerCaseFirstWord = PublicFunctions.getFirstWord(commandString).toLowerCase();

		if (PublicVariables.deleteKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.DELETE;
		} else if (PublicVariables.addKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.ADD;
		} else if (PublicVariables.doneKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.COMPLETE;
		} else if (PublicVariables.updateKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.EDIT;
		} else if (PublicVariables.searchKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.SEARCH;
		} else if (PublicVariables.showDetailsKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.SHOW_DETAILS;
		} else if (PublicVariables.blockKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.BLOCK;
		} else if (PublicVariables.undoKeywords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.UNDO;
		} else if (PublicVariables.findFreeKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.FIND_FREE;
		} else if (PublicVariables.redoKeywords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.REDO;
		} else if (PublicVariables.archiveKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.SHOW_ARCHIVE;
		} else if (PublicVariables.prioritiseKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.PRIORITISE;
		} else if (PublicVariables.homeKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.HOME;
		} else if (PublicVariables.postponeKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.POSTPONE;
		} else if (PublicVariables.confirmKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.CONFIRM;
		} else if (PublicVariables.setDirectoryKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.SET_DIRECTORY;
		} else if (PublicVariables.exitKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.EXIT;
		} else if (PublicVariables.helpKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.HELP;
		} else if (PublicVariables.demoKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.DEMO;
		} else if (PublicVariables.hideKeyWords.contains(lowerCaseFirstWord)) {
			return COMMAND_TYPE.HIDE;
		} else {
			return COMMAND_TYPE.INVALID;
		}
	}

	/**
	 * Removes the first word (command word) from user's input and return the
	 * rest of the string (arguments) to be parsed
	 * 
	 * @param commandString
	 *            user's input
	 * @return the argument string with command word removed
	 */
	public static String getArgsString(String commandString) {
		return PublicFunctions.removeFirstWord(commandString);
	}
}
```
###### src\urgenda\parser\DateTimeParser.java
``` java
package urgenda.parser;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Month;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.ocpsoft.prettytime.nlp.PrettyTimeParser;
import org.ocpsoft.prettytime.nlp.parse.DateGroup;

import urgenda.util.MultipleSlot;

public class DateTimeParser {
	private static ArrayList<Date> dateWithoutTime;
	private static List<DateGroup> dateGroups;
	private static String _argsString;

	private static String whiteSpace = " ";

	/**
	 * This function searches for the time string present in the input,
	 * determine its type (start time or end time) and set the appropriate
	 * global variables in PublicVariables. After that, it removes the parsed
	 * time string from the input
	 * 
	 * @param argsString
	 *            The input string
	 * @return The input string with time strings removed from it
	 */
	public static String searchTaskTimes(String argsString) {
		_argsString = argsString;
		dateGroups = new PrettyTimeParser().parseSyntax(_argsString);
		dateWithoutTime = searchDatesWithoutTime();
		int numberOfDateGroup = dateGroups.size();

		switch (numberOfDateGroup) {
		case 0:
			return argsString;
		case 1:
			return handlel1DateGroup();
		case 2:
			return handle2DateGroups();
		default:
			dateGroups = reselectDateGroups();
			return handle2DateGroups();
		}
	}

	/**
	 * Generates an arraylist of dates within the _argsString (class variable to
	 * stored the passed in argument string) A date is added if it was parsed
	 * from a time string that only indicates the date (eg. Monday, 11/3/2016)
	 * 
	 * @return ArrayList of dates
	 */
	private static ArrayList<Date> searchDatesWithoutTime() {
		PrettyTimeParser prettyParser = new PrettyTimeParser();
		List<DateGroup> secondParse = prettyParser.parseSyntax(_argsString);
		ArrayList<Date> dateWithoutTime = new ArrayList<Date>();
		for (int i = 0; i < dateGroups.size(); i++) {
			for (int j = 0; j < dateGroups.get(i).getDates().size(); j++) {
				if (!dateGroups.get(i).getDates().get(j).equals(secondParse.get(i).getDates().get(j))) {
					dateWithoutTime.add(dateGroups.get(i).getDates().get(j));
				}
			}
		}

		return dateWithoutTime;
	}

	private static List<DateGroup> reselectDateGroups() {
		int startIndex = dateGroups.size() - 2;
		int endIndex = dateGroups.size() - 1;
		return dateGroups.subList(startIndex, endIndex);
	}

	// need refractoring after done
	private static String handlel1DateGroup() {
		int numberOfDates = dateGroups.get(0).getDates().size();
		int parsePosition = dateGroups.get(0).getPosition();
		String dateString = dateGroups.get(0).getText();
		String preceedingWord = PublicFunctions.getPreceedingWord(parsePosition, _argsString);
		switch (numberOfDates) {
		case 1:
			return handle1DateIn1DateGroup(dateString, preceedingWord);
		case 2:
			return handle2DatesIn1DateGroup(dateString, preceedingWord);
		case 3:
			return handle3DatesIn1DateGroup(dateString, preceedingWord);
		default:
			return _argsString;
		}
	}

	private static String handle3DatesIn1DateGroup(String dateString, String preceedingWord) {
		Date time1 = dateGroups.get(0).getDates().get(0);
		Date time2 = dateGroups.get(0).getDates().get(1);
		Date time3 = dateGroups.get(0).getDates().get(2);

		Date minDate;
		Date maxDate;
		if (time1.equals(time2) || (time1.equals(time3))) {
			minDate = getMin(time1, time3);
			maxDate = getMax(time1, time3);
		} else if (time2.equals(time3)) {
			minDate = getMin(time1, time2);
			maxDate = getMax(time1, time2);
		} else {
			minDate = getMin(time3, time2);
			maxDate = getMax(time3, time2);
		}

		LocalDateTime minDateTime = getLocalDateTimeFromDate(minDate);
		LocalDateTime maxDateTime = getLocalDateTimeFromDate(maxDate);
		if (isDateOnly(minDate)) {
			minDateTime = adjustedDateEvent(minDateTime);
		}
		if (isDateOnly(maxDate)) {
			maxDateTime = adjustedDateEvent(maxDateTime);
		}

		setTaskStartTime(minDateTime);
		setTaskEndTime(maxDateTime);

		if (isStartKeyWords(preceedingWord)) {
			return PublicFunctions.reselectString(_argsString, preceedingWord + whiteSpace + dateString);
		} else {
			return PublicFunctions.reselectString(_argsString, dateString);
		}
	}

	private static boolean isStartKeyWords(String preceedingWord) {
		return PublicVariables.startTimeWords.contains(preceedingWord)
				|| PublicVariables.periodWords.contains(preceedingWord);
	}

	private static String handle2DatesIn1DateGroup(String dateString, String preceedingWord) {
		Date timeInDate;
		timeInDate = dateGroups.get(0).getDates().get(0);
		LocalDateTime dateTime1 = getLocalDateTimeFromDate(timeInDate);
		if (isDateOnly(timeInDate)) {
			dateTime1 = adjustedDateEvent(dateTime1);
		}

		timeInDate = dateGroups.get(0).getDates().get(1);
		LocalDateTime dateTime2 = getLocalDateTimeFromDate(timeInDate);
		if (isDateOnly(timeInDate)) {
			dateTime2 = adjustedDateEvent(dateTime2);
		}

		setTaskStartTime(dateTime1);
		setTaskEndTime(dateTime2);

		if (isStartKeyWords(preceedingWord)) {
			return PublicFunctions.reselectString(_argsString, preceedingWord + whiteSpace + dateString);
		} else {
			return PublicFunctions.reselectString(_argsString, dateString);
		}
	}

	private static String handle1DateIn1DateGroup(String dateString, String preceedingWord) {
		Date timeInDate;
		timeInDate = dateGroups.get(0).getDates().get(0);
		LocalDateTime dateTime = getLocalDateTimeFromDate(timeInDate);

		if (PublicVariables.startTimeWords.contains(preceedingWord)) {
			if (isDateOnly(timeInDate)) {
				dateTime = adjustedDateEvent(dateTime);
			}
			setTaskStartTime(dateTime);
			setTaskEndTime(dateTime.plusHours(1));
			return PublicFunctions.reselectString(_argsString, preceedingWord + whiteSpace + dateString);
		} else if (PublicVariables.endTimeWords.contains(preceedingWord)) {
			if (isDateOnly(timeInDate)) {
				dateTime = adjustedDateDeadline(dateTime);
			}
			setTaskEndTime(dateTime);
			return PublicFunctions.reselectString(_argsString, preceedingWord + whiteSpace + dateString);
		} else {
			if (isDateOnly(timeInDate)) {
				dateTime = adjustedDateEvent(dateTime);
			}
			setTaskStartTime(dateTime);
			setTaskEndTime(dateTime.plusHours(1));
			return PublicFunctions.reselectString(_argsString, dateString);
		}
	}

	private static String handle2DateGroups() {
		int numberOfDatesInGroup1 = dateGroups.get(0).getDates().size();
		int numberOfDatesInGroup2 = dateGroups.get(1).getDates().size();

		if (numberOfDatesInGroup1 == 1 && numberOfDatesInGroup2 == 2) {
			return handleOneDateTwoDates();
		} else if (numberOfDatesInGroup1 == 2 && numberOfDatesInGroup2 == 1) {
			return handleTwoDatesOneDate();
		} else if (numberOfDatesInGroup1 == 1 && numberOfDatesInGroup2 == 1) {
			return handleOneDateOneDate();
		} else {
			return _argsString;
		}
	}

	private static String handleOneDateOneDate() {
		Date group1Date = dateGroups.get(0).getDates().get(0);
		Date group2Date = dateGroups.get(1).getDates().get(0);

		if (is1TimeOnly1DateOnly(group1Date, group2Date)) {
			return handle1DateOnly1TimeOnly();
		} else if (isBothDateOnly(group1Date, group2Date)) {
			return _argsString;
		} else {
			return handleBothTimeOnly();
		}
	}

	private static String handleBothTimeOnly() {
		int parsePositionGroup1 = dateGroups.get(0).getPosition();
		String dateStringGroup1 = dateGroups.get(0).getText();
		String preceedingWordGroup1 = PublicFunctions.getPreceedingWord(parsePositionGroup1, _argsString);

		int parsePositionGroup2 = dateGroups.get(1).getPosition();
		String dateStringGroup2 = dateGroups.get(1).getText();
		String preceedingWordGroup2 = PublicFunctions.getPreceedingWord(parsePositionGroup2, _argsString);

		Date group1Date = dateGroups.get(0).getDates().get(0);
		Date group2Date = dateGroups.get(1).getDates().get(0);
		LocalDateTime group1LocalDate = getLocalDateTimeFromDate(group1Date);
		LocalDateTime group2LocalDate = getLocalDateTimeFromDate(group2Date);
		setTaskStartTime(group1LocalDate);
		setTaskEndTime(group2LocalDate);

		String reducedArgsString;

		if (PublicVariables.startTimeWords.contains(preceedingWordGroup1)) {
			reducedArgsString = PublicFunctions.reselectString(_argsString,
					preceedingWordGroup1 + whiteSpace + dateStringGroup1);
		} else {
			reducedArgsString = PublicFunctions.reselectString(_argsString, dateStringGroup2);
		}

		if (PublicVariables.endTimeWords.contains(preceedingWordGroup2)) {
			reducedArgsString = PublicFunctions.reselectString(reducedArgsString,
					preceedingWordGroup2 + whiteSpace + dateStringGroup2);
		} else {
			reducedArgsString = PublicFunctions.reselectString(reducedArgsString, dateStringGroup2);
		}

		return reducedArgsString;
	}

	private static boolean isBothDateOnly(Date group1Date, Date group2Date) {
		return isDateOnly(group2Date) && isDateOnly(group1Date);
	}

	private static boolean is1TimeOnly1DateOnly(Date group1Date, Date group2Date) {
		return (isDateOnly(group1Date) && isTimeOnly(group2Date)) || (isDateOnly(group2Date) && isTimeOnly(group1Date));
	}

	private static String handle1DateOnly1TimeOnly() {
		int parsePositionGroup1 = dateGroups.get(0).getPosition();
		String dateStringGroup1 = dateGroups.get(0).getText();
		String preceedingWordGroup1 = PublicFunctions.getPreceedingWord(parsePositionGroup1, _argsString);

		int parsePositionGroup2 = dateGroups.get(1).getPosition();
		String dateStringGroup2 = dateGroups.get(1).getText();
		String preceedingWordGroup2 = PublicFunctions.getPreceedingWord(parsePositionGroup2, _argsString);

		Date group1Date = dateGroups.get(0).getDates().get(0);
		Date group2Date = dateGroups.get(1).getDates().get(0);
		LocalDateTime group1LocalDate = getLocalDateTimeFromDate(group1Date);
		LocalDateTime group2LocalDate = getLocalDateTimeFromDate(group2Date);
		LocalDate dateComponent;
		LocalTime timeComponent;
		LocalDateTime taskDateTime;

		if (isDateOnly(group1Date) && isTimeOnly(group2Date)) {
			dateComponent = group1LocalDate.toLocalDate();
			timeComponent = group2LocalDate.toLocalTime();
			taskDateTime = LocalDateTime.of(dateComponent, timeComponent);
		} else {
			dateComponent = group2LocalDate.toLocalDate();
			timeComponent = group1LocalDate.toLocalTime();
			taskDateTime = LocalDateTime.of(dateComponent, timeComponent);
		}

		if (PublicVariables.endTimeWords.contains(preceedingWordGroup1)) {
			setTaskEndTime(taskDateTime);

			if (PublicVariables.startTimeWords.contains(preceedingWordGroup2)) {
				String reducedArgsString = PublicFunctions.reselectString(_argsString,
						preceedingWordGroup2 + whiteSpace + dateStringGroup2);
				reducedArgsString = PublicFunctions.reselectString(reducedArgsString,
						preceedingWordGroup1 + whiteSpace + dateStringGroup1);

				return reducedArgsString;
			} else {
				String reducedArgsString = PublicFunctions.reselectString(_argsString, dateStringGroup2);
				reducedArgsString = PublicFunctions.reselectString(reducedArgsString,
						preceedingWordGroup1 + whiteSpace + dateStringGroup1);

				return reducedArgsString;
			}
		} else if (PublicVariables.endTimeWords.contains(preceedingWordGroup2)) {
			setTaskEndTime(taskDateTime);

			if (PublicVariables.startTimeWords.contains(preceedingWordGroup1)) {
				String reducedArgsString = PublicFunctions.reselectString(_argsString,
						preceedingWordGroup1 + whiteSpace + dateStringGroup1);
				reducedArgsString = PublicFunctions.reselectString(reducedArgsString,
						preceedingWordGroup2 + whiteSpace + dateStringGroup2);

				return reducedArgsString;
			} else {
				String reducedArgsString = PublicFunctions.reselectString(_argsString, dateStringGroup1);
				reducedArgsString = PublicFunctions.reselectString(reducedArgsString,
						preceedingWordGroup2 + whiteSpace + dateStringGroup2);

				return reducedArgsString;
			}
		} else {
			setTaskStartTime(taskDateTime);
			setTaskEndTime(taskDateTime.plusHours(1));

			String reducedArgsString;

			if (PublicVariables.startTimeWords.contains(preceedingWordGroup1)) {
				reducedArgsString = PublicFunctions.reselectString(_argsString,
						preceedingWordGroup1 + whiteSpace + dateStringGroup1);
			} else {
				reducedArgsString = PublicFunctions.reselectString(_argsString, dateStringGroup1);
			}

			if (PublicVariables.startTimeWords.contains(preceedingWordGroup2)) {
				reducedArgsString = PublicFunctions.reselectString(reducedArgsString,
						preceedingWordGroup2 + whiteSpace + dateStringGroup2);
			} else {
				reducedArgsString = PublicFunctions.reselectString(reducedArgsString, dateStringGroup2);
			}

			return reducedArgsString;
		}
	}

	private static String handleTwoDatesOneDate() {
		int parsePositionGroup1 = dateGroups.get(0).getPosition();
		String dateStringGroup1 = dateGroups.get(0).getText();
		String preceedingWordGroup1 = PublicFunctions.getPreceedingWord(parsePositionGroup1, _argsString);

		int parsePositionGroup2 = dateGroups.get(1).getPosition();
		String dateStringGroup2 = dateGroups.get(1).getText();
		String preceedingWordGroup2 = PublicFunctions.getPreceedingWord(parsePositionGroup2, _argsString);

		Date group2Date = dateGroups.get(1).getDates().get(0);
		Date group1Date1 = dateGroups.get(0).getDates().get(0);
		Date group1Date2 = dateGroups.get(0).getDates().get(1);
		LocalDateTime group2LocalDate = getLocalDateTimeFromDate(group2Date);
		LocalDateTime group1LocalDate1 = getLocalDateTimeFromDate(group1Date1);
		LocalDateTime group1LocalDate2 = getLocalDateTimeFromDate(group1Date2);

		if (isDateOnly(group2Date) && isTimeOnly(group1Date1) && isTimeOnly(group1Date2)) {
			LocalDate commonDate = group2LocalDate.toLocalDate();
			LocalTime startTime = group1LocalDate1.toLocalTime();
			LocalTime endTime = group1LocalDate2.toLocalTime();

			setTaskStartTime(LocalDateTime.of(commonDate, startTime));
			setTaskEndTime(LocalDateTime.of(commonDate, endTime));

			String returnedString;
			if (PublicVariables.startTimeWords.contains(preceedingWordGroup2)) {
				returnedString = PublicFunctions.reselectString(_argsString,
						preceedingWordGroup2 + whiteSpace + dateStringGroup2);
			} else {
				returnedString = PublicFunctions.reselectString(_argsString, dateStringGroup2);
			}

			if (isStartKeyWords(preceedingWordGroup1)) {
				returnedString = PublicFunctions.reselectString(returnedString,
						preceedingWordGroup1 + whiteSpace + dateStringGroup1);
			} else {
				returnedString = PublicFunctions.reselectString(returnedString, dateStringGroup1);
			}

			return returnedString;
		} else {
			setTaskStartTime(group1LocalDate1);
			setTaskEndTime(group1LocalDate2);

			if (PublicVariables.startTimeWords.contains(preceedingWordGroup1)) {
				return PublicFunctions.reselectString(_argsString,
						preceedingWordGroup1 + whiteSpace + dateStringGroup1);
			} else {
				return PublicFunctions.reselectString(_argsString, dateStringGroup1);
			}
		}
	}

	private static String handleOneDateTwoDates() {
		int parsePositionGroup1 = dateGroups.get(0).getPosition();
		String dateStringGroup1 = dateGroups.get(0).getText();
		String preceedingWordGroup1 = PublicFunctions.getPreceedingWord(parsePositionGroup1, _argsString);

		int parsePositionGroup2 = dateGroups.get(1).getPosition();
		String dateStringGroup2 = dateGroups.get(1).getText();
		String preceedingWordGroup2 = PublicFunctions.getPreceedingWord(parsePositionGroup2, _argsString);

		Date group1Date = dateGroups.get(0).getDates().get(0);
		Date group2Date1 = dateGroups.get(1).getDates().get(0);
		Date group2Date2 = dateGroups.get(1).getDates().get(1);
		LocalDateTime group1LocalDate = getLocalDateTimeFromDate(group1Date);
		LocalDateTime group2LocalDate1 = getLocalDateTimeFromDate(group2Date1);
		LocalDateTime group2LocalDate2 = getLocalDateTimeFromDate(group2Date2);

		if (isDateOnly(group1Date) && isTimeOnly(group2Date1) && isTimeOnly(group2Date2)) {
			LocalDate commonDate = group1LocalDate.toLocalDate();
			LocalTime startTime = group2LocalDate1.toLocalTime();
			LocalTime endTime = group2LocalDate2.toLocalTime();

			setTaskStartTime(LocalDateTime.of(commonDate, startTime));
			setTaskEndTime(LocalDateTime.of(commonDate, endTime));

			String returnedString;

			if (PublicVariables.startTimeWords.contains(preceedingWordGroup1)) {
				returnedString = PublicFunctions.reselectString(_argsString,
						preceedingWordGroup1 + whiteSpace + dateStringGroup1);
			} else {
				returnedString = PublicFunctions.reselectString(_argsString, dateStringGroup1);
			}

			if (isStartKeyWords(preceedingWordGroup2)) {
				returnedString = PublicFunctions.reselectString(returnedString,
						preceedingWordGroup2 + whiteSpace + dateStringGroup2);
			} else {
				returnedString = PublicFunctions.reselectString(returnedString, dateStringGroup2);
			}
			return returnedString;
		} else {
			setTaskStartTime(group2LocalDate1);
			setTaskEndTime(group2LocalDate2);

			if (PublicVariables.startTimeWords.contains(preceedingWordGroup2)) {
				return PublicFunctions.reselectString(_argsString,
						preceedingWordGroup2 + whiteSpace + dateStringGroup2);
			} else {
				return PublicFunctions.reselectString(_argsString, dateStringGroup2);
			}
		}
	}

	/**
	 * Convert a date of type Jave.util.Date to java.time.LocalDateTime
	 * 
	 * @param date
	 *            the date of type Jave.util.Date
	 * @return the date of type java.time.LocalDateTime
	 */
	public static LocalDateTime getLocalDateTimeFromDate(Date date) {
		return PublicFunctions.getLocalDateTimeFromDate(date);
	}

	private static Date getMin(Date date1, Date date2) {
		if (date1.compareTo(date2) < 0) {
			return date1;
		} else {
			return date2;
		}
	}

	private static Date getMax(Date date1, Date date2) {
		if (date1.compareTo(date2) < 0) {
			return date2;
		} else {
			return date1;
		}
	}

	private static boolean isDateOnly(Date date) {
		Boolean returnedValue = false;
		for (int i = 0; i < dateWithoutTime.size(); i++) {
			if (date.compareTo(dateWithoutTime.get(i)) == 0) {
				returnedValue = true;
			}
		}
		return returnedValue;
	}

	private static boolean isTimeOnly(Date date) {
		LocalDateTime localDate = getLocalDateTimeFromDate(date);
		if (localDate.getDayOfYear() == LocalDateTime.now().getDayOfYear()) {
			return true;
		} else {
			return false;
		}
	}

	private static void setTaskStartTime(LocalDateTime startTime) {
		PublicVariables.taskStartTime = startTime;
	}

	private static void setTaskEndTime(LocalDateTime endTime) {
		PublicVariables.taskEndTime = endTime;
	}

	/**
	 * Try parse an input to see if it contains any time string of only dates
	 * (eg. Monday, 11/4)
	 * 
	 * @param argsString
	 *            the input to be parsed
	 * @return the first successful parse of such time string is returned as a
	 *         java.time.LocalDate
	 */
	public static LocalDate tryParseDate(String argsString) {
		List<DateGroup> dateGroups = new PrettyTimeParser().parseSyntax(argsString);
		if (dateGroups.size() == 1) {
			String parsedString = dateGroups.get(0).getText();
			if (dateGroups.get(0).getDates().size() == 1 && parsedString.trim().equals(argsString)) {
				List<DateGroup> dateGroups2 = new PrettyTimeParser().parseSyntax(argsString);
				Date firstParseDate = dateGroups.get(0).getDates().get(0);
				Date secondParseDate = dateGroups2.get(0).getDates().get(0);
				if (!firstParseDate.equals(secondParseDate)) {
					LocalDateTime localDateTime = getLocalDateTimeFromDate(firstParseDate);
					return localDateTime.toLocalDate();
				}
			}
		}
		return null;
	}

	/**
	 * Try parse an input to see if it contains any time string of complete time
	 * (eg. 11/4 8am, next monday 9:30)
	 * 
	 * @param argsString
	 *            the input to be parsed
	 * @return the first successful parse of such time string is returned as a
	 *         java.time.LocalDateTime
	 */
	public static LocalDateTime tryParseTime(String argsString) {
		List<DateGroup> dateGroups = new PrettyTimeParser().parseSyntax(argsString);
		if (dateGroups.size() == 1) {
			String parsedString = dateGroups.get(0).getText();
			if (dateGroups.get(0).getDates().size() == 1 && parsedString.trim().equals(argsString)) {
				List<DateGroup> dateGroups2 = new PrettyTimeParser().parseSyntax(argsString);
				Date firstParseDate = dateGroups.get(0).getDates().get(0);
				Date secondParseDate = dateGroups2.get(0).getDates().get(0);
				if (firstParseDate.equals(secondParseDate)) {
					LocalDateTime localDateTime = getLocalDateTimeFromDate(firstParseDate);
					return localDateTime;
				}
			}
		}
		return null;
	}

	/**
	 * Try parse an input to see if it contains any time string of month (eg.
	 * mar, august)
	 * 
	 * @param argsString
	 *            the input to be parsed
	 * @return the first successful parse of such time string is returned as a
	 *         java.time.Month
	 */
	public static Month tryParseMonth(String argsString) {
		if (PublicVariables.janWords.contains(argsString)) {
			return Month.JANUARY;
		} else if (PublicVariables.febWords.contains(argsString)) {
			return Month.FEBRUARY;
		} else if (PublicVariables.marWords.contains(argsString)) {
			return Month.MARCH;
		} else if (PublicVariables.aprWords.contains(argsString)) {
			return Month.APRIL;
		} else if (PublicVariables.mayWords.contains(argsString)) {
			return Month.MAY;
		} else if (PublicVariables.junWords.contains(argsString)) {
			return Month.JUNE;
		} else if (PublicVariables.julWords.contains(argsString)) {
			return Month.JULY;
		} else if (PublicVariables.augWords.contains(argsString)) {
			return Month.AUGUST;
		} else if (PublicVariables.sepWords.contains(argsString)) {
			return Month.SEPTEMBER;
		} else if (PublicVariables.octWords.contains(argsString)) {
			return Month.OCTOBER;
		} else if (PublicVariables.novWords.contains(argsString)) {
			return Month.NOVEMBER;
		} else if (PublicVariables.decWords.contains(argsString)) {
			return Month.DECEMBER;
		}
		return null;
	}

	/**
	 * function that searches and set reserved slots for a task from an array
	 * list of time string
	 * 
	 * @param taskTimeStrings
	 *            the arraylist that contains time string as elements to be
	 *            parsed
	 */
	public static void searchTaskSlots(ArrayList<String> taskTimeStrings) {
		PublicVariables.taskSlots = new MultipleSlot();
		try {
			for (String taskTime : taskTimeStrings) {
				dateGroups = new PrettyTimeParser().parseSyntax(taskTime);
				if (dateGroups.size() == 1 && dateGroups.get(0).getDates().size() == 2) {
					LocalDateTime start = getLocalDateTimeFromDate(dateGroups.get(0).getDates().get(0));
					LocalDateTime end = getLocalDateTimeFromDate(dateGroups.get(0).getDates().get(1));
					PublicVariables.taskSlots.addTimeSlot(start, end);
				}
			}
		} catch (Exception e) {

		}

		if (PublicVariables.taskSlots.isEmpty()) {
			PublicVariables.taskSlots = null;
		}
	}

	/**
	 * Function that rounds up the deadline time obtained from pretty time
	 * parser to a more presentable form
	 * 
	 * @param date
	 *            the date to be rounded up
	 * @return the rounded up date
	 */
	public static LocalDateTime adjustedDateDeadline(LocalDateTime date) {
		date = date.withHour(23);
		date = date.withMinute(59);
		date = date.withSecond(0);
		date = date.withNano(0);
		return date;
	}

	/**
	 * Function that rounds up the event time obtained from pretty time parser
	 * to a more presentable form
	 * 
	 * @param date
	 *            the date to be rounded up
	 * @return the rounded up date
	 */
	public static LocalDateTime adjustedDateEvent(LocalDateTime date) {
		try {
			date = date.withHour(date.getHour() + 1);
		} catch (Exception e) {
			date = date.withDayOfMonth(date.getDayOfMonth() + 1);
			date = date.withHour((date.getHour() + 1) % 24);
		}

		date = date.withMinute(0);
		date = date.withSecond(0);
		date = date.withNano(0);
		return date;
	}
}
```
###### src\urgenda\parser\PublicFunctions.java
``` java
package urgenda.parser;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import urgenda.parser.PublicVariables.*;
import urgenda.util.MultipleSlot;

public class PublicFunctions {
	private static String whiteSpaceRegex = "\\s+";
	private static String emptyString = "";
	private static String singleSpace = " ";
	private static int dummyIndex = -10;

	/**
	 * get the first word of the passed in string
	 * 
	 * @param commandString
	 *            the passed in string
	 * @return the passed in string's first word
	 */
	public static String getFirstWord(String commandString) {
		return commandString.split(whiteSpaceRegex)[0].toLowerCase();
	}

	/**
	 * Removes the first word from passed in string and return the rest of the
	 * string
	 * 
	 * @param commandString
	 *            passed in string
	 * @return passed in string without first word
	 */
	public static String removeFirstWord(String commandString) {
		try {
			String removedFirstWord = commandString.split(whiteSpaceRegex, 2)[1];
			Matcher matcher = Pattern.compile(whiteSpaceRegex).matcher(removedFirstWord);
			while (matcher.find()) {
				removedFirstWord = removedFirstWord.replace(matcher.group(), singleSpace);
			}
			return removedFirstWord.trim().toLowerCase();
		} catch (Exception e) {
			return null;
		}
	}

	/**
	 * Function to reinitialize the global variables stored in PublicVariables
	 * for every new parse
	 */
	public static void reinitializePublicVariables() {
		PublicVariables.commandType = COMMAND_TYPE.INVALID;
		PublicVariables.taskIndex = dummyIndex;
		PublicVariables.positions = new ArrayList<Integer>();
		PublicVariables.taskDescription = emptyString;
		PublicVariables.taskLocation = emptyString;
		PublicVariables.taskStartTime = null;
		PublicVariables.taskEndTime = null;
		PublicVariables.taskHashtags = new ArrayList<String>();
		PublicVariables.taskSlots = new MultipleSlot();
		PublicVariables.taskType = TASK_TYPE.INVALID;
		PublicVariables.taskDateTime = new ArrayList<LocalDateTime>();
		PublicVariables.taskTimeType = new ArrayList<String>();
	}

	/**
	 * Function to get the preceeding word from a certain index in a passed in
	 * string
	 * 
	 * @param position
	 *            the index
	 * @param argsString
	 *            the passed in string
	 * @return the word right in front of the index position in the passed in
	 *         string
	 */
	public static String getPreceedingWord(int position, String argsString) {
		if (position == 0 || position == -1) {
			return emptyString;
		} else {
			argsString = argsString.substring(0, position);
			String[] splittedString = argsString.split(whiteSpaceRegex);
			return splittedString[splittedString.length - 1];
		}
	}

	/**
	 * function that removes a substring from the passed in string and
	 * reformatted the string to contain only single whitespace
	 * 
	 * @param argsString
	 *            the passed in string
	 * @param removedString
	 *            the sub string to be removed
	 * @return the reformatted string with the substring removed
	 */
	public static String reselectString(String argsString, String removedString) {
		String temp = argsString;
		Matcher matcher = Pattern.compile(removedString).matcher(temp);
		while (matcher.find()) {
			temp = temp.replace(matcher.group(), emptyString);
		}
		matcher = Pattern.compile(whiteSpaceRegex).matcher(temp);
		while (matcher.find()) {
			temp = temp.replace(matcher.group(), singleSpace);
		}
		return temp.trim();
	}

	/**
	 * function that performs a reformatting of the passed in string to switch
	 * any MMDDYYYY format substring to DDMMYYY this is needed as pretty time
	 * parse use the MMDDYYYY format, while the Singapore culture use DDMMYYYY
	 * 
	 * @param argsString
	 *            passed in string
	 * @return formatted string with DDMMYYYY format
	 */
	public static String reformatArgsString(String argsString) {
		String reverseDateRegexWithoutYear = "(((\\A|\\D)([1-9]|0[1-9]|[12][0-9]|3[01])([-/.])([1-9]|0[1-9]|1[012])(\\D|\\Z)))";
		String reverseDateRegexWithYear = "(((\\A|\\D)([1-9]|0[1-9]|[12][0-9]|3[01])([-/.])([1-9]|0[1-9]|1[012])(([-/.])((19)|(20))?\\d\\d)(\\D|\\Z)))";
		String reverseDateRegex = "(" + reverseDateRegexWithYear + "|" + reverseDateRegexWithoutYear + ")";
		Matcher matcher = Pattern.compile(reverseDateRegex).matcher(argsString);
		while (matcher.find()) {
			argsString = argsString.replace(matcher.group(),
					singleSpace + reverseDateMonth(matcher.group()) + singleSpace);
		}
		return argsString;
	}

	private static String reverseDateMonth(String string) {
		String dateMonthDelimiterRegex = "([-/.])";
		String nonDigitRegex = "\\D+";
		String standardDateMonthDelimiter = "/";

		String[] stringArray = string.split(dateMonthDelimiterRegex);
		if (stringArray.length == 2) {
			return stringArray[1].replaceAll(nonDigitRegex, emptyString) + standardDateMonthDelimiter
					+ stringArray[0].replaceAll(nonDigitRegex, emptyString);
		} else if (stringArray.length == 3) {
			return stringArray[1] + standardDateMonthDelimiter + stringArray[0].replaceAll(nonDigitRegex, emptyString)
					+ standardDateMonthDelimiter + stringArray[2].replaceAll(nonDigitRegex, emptyString);
		} else {
			return string;
		}
	}

	/**
	 * Convert a date of type Jave.util.Date to java.time.LocalDateTime
	 * 
	 * @param date
	 *            the date of type Jave.util.Date
	 * @return the date of type java.time.LocalDateTime
	 */
	public static LocalDateTime getLocalDateTimeFromDate(Date date) {
		return LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
	}

	public static LocalDateTime minTime(LocalDateTime time1, LocalDateTime time2) {
		if (time1.isAfter(time2)) {
			return time2;
		} else {
			return time1;
		}
	}

	public static LocalDateTime maxTime(LocalDateTime time1, LocalDateTime time2) {
		if (time1.isAfter(time2)) {
			return time1;
		} else {
			return time2;
		}
	}

	/**
	 * Function that get the number of words separated by white space within a
	 * string
	 * 
	 * @param string
	 *            the passed in string
	 * @return the number of words in the passed in string
	 */
	public static int getNumberOfWords(String string) {
		if (string == null) {
			return 0;
		} else {
			String[] array = string.split(whiteSpaceRegex);
			return array.length;
		}
	}

	/**
	 * function that returns the last word of the passed in string
	 * 
	 * @param string
	 *            the passed in string
	 * @return the last word of the passed in string
	 */
	public static String getLastWord(String string) {
		if (string == null) {
			return null;
		} else {
			String[] array = string.split(whiteSpaceRegex);
			return array[array.length - 1].trim();
		}
	}

	/**
	 * function that returns the second last word of the passed in string
	 * 
	 * @param string
	 *            the passed in string
	 * @return second last word of the passed in string
	 */
	public static String getSecondLastWord(String string) {
		if (string == null) {
			return null;
		} else {
			String[] array = string.split(whiteSpaceRegex);
			if (array.length >= 2) {
				return array[array.length - 2].trim();
			} else {
				return null;
			}
		}
	}
}
```
###### src\urgenda\parser\PublicVariables.java
``` java
package urgenda.parser;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import urgenda.util.MultipleSlot;

public class PublicVariables {
	public static enum COMMAND_TYPE {
		ADD, DELETE, COMPLETE, EDIT, HELP, SEARCH, SHOW_DETAILS, BLOCK, DEMO, HIDE, FIND_FREE, HOME, UNDO, REDO, SHOW_ARCHIVE, CONFIRM, SET_DIRECTORY, PRIORITISE, POSTPONE, INVALID, EXIT
	}

	public static enum TASK_TYPE {
		EVENT, DEADLINE, FLOATING, INVALID
	}

	public static int currentYear = LocalDate.now().getYear();
	public static int currentMonth = LocalDate.now().getMonthValue();
	public static int currentDayOfMonth = LocalDate.now().getDayOfMonth();

	public static final String MESSAGE_INVALID_COMMAND = "\"%1$s\" is not a valid command";

	public static final Set<String> deleteKeyWords = new HashSet<String>(
			Arrays.asList(new String[] { "delete", "del", "erase", "remove" }));
	public static final Set<String> addKeyWords = new HashSet<String>(Arrays.asList(new String[] { "add", "create" }));
	public static final Set<String> doneKeyWords = new HashSet<String>(
			Arrays.asList(new String[] { "done", "complete", "completed", "mark", "finish", "fin" }));
	public static final Set<String> updateKeyWords = new HashSet<String>(
			Arrays.asList(new String[] { "edit", "change", "update", "mod" }));
	public static final Set<String> searchKeyWords = new HashSet<String>(
			Arrays.asList(new String[] { "find", "show", "view", "list", "search" }));
	public static final Set<String> showDetailsKeyWords = new HashSet<String>(
			Arrays.asList(new String[] { "showmore" }));
	public static final Set<String> homeKeyWords = new HashSet<String>(Arrays.asList(new String[] { "home" }));
	public static final Set<String> blockKeyWords = new HashSet<String>(
			Arrays.asList(new String[] { "block", "res", "reserve", "alloc", "allocate", "rsv" }));
	public static final Set<String> findFreeKeyWords = new HashSet<String>(
			Arrays.asList(new String[] { "findfree", "free", "checkfree" }));
	public static final Set<String> undoKeywords = new HashSet<String>(Arrays.asList(new String[] { "undo" }));
	public static final Set<String> redoKeywords = new HashSet<String>(Arrays.asList(new String[] { "redo" }));
	public static final Set<String> helpKeyWords = new HashSet<String>(Arrays.asList(new String[] { "help" }));
	public static final Set<String> archiveKeyWords = new HashSet<String>(Arrays.asList(new String[] { "archive" }));
	public static final Set<String> prioritiseKeyWords = new HashSet<String>(
			Arrays.asList(new String[] { "urgent", "important", "pri", "impt" }));
	public static final Set<String> postponeKeyWords = new HashSet<String>(
			Arrays.asList(new String[] { "postpone", "delay", "move" }));
	public static final Set<String> confirmKeyWords = new HashSet<String>(
			Arrays.asList(new String[] { "confirm", "cfm" }));
	public static final Set<String> setDirectoryKeyWords = new HashSet<String>(
			Arrays.asList(new String[] { "saveto", "cd" }));
	public static final Set<String> exitKeyWords = new HashSet<String>(Arrays.asList(new String[] { "exit", "quit" }));
	public static final Set<String> demoKeyWords = new HashSet<String>(Arrays.asList(new String[] { "demo" }));
	public static final Set<String> hideKeyWords = new HashSet<String>(Arrays.asList(new String[] { "hide" }));

	public static final Set<String> janWords = new HashSet<String>(Arrays.asList(new String[] { "jan", "january" }));
	public static final Set<String> febWords = new HashSet<String>(Arrays.asList(new String[] { "feb", "february" }));
	public static final Set<String> marWords = new HashSet<String>(Arrays.asList(new String[] { "mar", "march" }));
	public static final Set<String> aprWords = new HashSet<String>(Arrays.asList(new String[] { "apr", "april" }));
	public static final Set<String> mayWords = new HashSet<String>(Arrays.asList(new String[] { "may" }));
	public static final Set<String> junWords = new HashSet<String>(Arrays.asList(new String[] { "jun", "june" }));
	public static final Set<String> julWords = new HashSet<String>(Arrays.asList(new String[] { "jul", "july" }));
	public static final Set<String> augWords = new HashSet<String>(Arrays.asList(new String[] { "aug", "august" }));
	public static final Set<String> sepWords = new HashSet<String>(
			Arrays.asList(new String[] { "sep", "sept", "september" }));
	public static final Set<String> octWords = new HashSet<String>(Arrays.asList(new String[] { "oct", "october" }));
	public static final Set<String> novWords = new HashSet<String>(Arrays.asList(new String[] { "nov", "november" }));
	public static final Set<String> decWords = new HashSet<String>(Arrays.asList(new String[] { "dec", "december" }));

	public static final Set<String> startTimeWords = new HashSet<String>(
			Arrays.asList(new String[] { "on", "at", "from", "of", "starting" }));
	public static final Set<String> endTimeWords = new HashSet<String>(
			Arrays.asList(new String[] { "by", "latest", "before" }));
	public static final Set<String> periodWords = new HashSet<String>(
			Arrays.asList(new String[] { "between", "within", "spanning" }));

	public static int taskIndex;
	public static ArrayList<Integer> positions;
	public static String taskDescription;
	public static String taskLocation;
	public static LocalDateTime taskStartTime;
	public static LocalDateTime taskEndTime;
	public static ArrayList<String> taskHashtags;
	public static MultipleSlot taskSlots;

	public static TASK_TYPE taskType;
	public static COMMAND_TYPE commandType;

	public static ArrayList<LocalDateTime> taskDateTime;
	public static ArrayList<String> taskTimeType;

}
```
###### src\urgenda\parser\TaskDetailsParser.java
``` java
package urgenda.parser;

import urgenda.parser.PublicVariables.TASK_TYPE;

public class TaskDetailsParser {
	private static String locationKeyWord1 = "@";
	private static String locationKeyWord2 = "at";
	private static String emptyString = "";
	private static String whiteSpace = " ";
	private static String rangeRegex = "((\\d+)( )?-( )?(\\d+))";
	private static String numberRegex = "(\\d+)";
	private static String indexDelimiterRegex = ",";
	private static String indexRangeDelimiterRegex = "-";

	/**
	 * function that search for a location in the passed in string and update
	 * the global variable taskLocation in PublicVariables after that the
	 * substring that contains the location is removed from the passed in
	 * string, and the passed in string in returned
	 * 
	 * @param argsString
	 *            passed in string
	 * @return passed in string with location string removed
	 */
	public static String searchTaskLocation(String argsString) {
		try {
			return tryParseLocationByFirstKeyWord(argsString);
		} catch (Exception e) {
			return tryParseLocationBySecondKeyWord(argsString);
		}
	}

	/**
	 * function that search for a description in the passed in string and update
	 * the global variable taskDescription in PublicVariables
	 * 
	 * @param argsString
	 *            passed in string
	 */
	public static void searchTaskDescription(String argsString) {
		if (isEmptyDesc(argsString)) {
			PublicVariables.taskDescription = emptyString;
		} else {
			PublicVariables.taskDescription = argsString.trim();
		}
	}

	/**
	 * function that determines the task type from the global variables
	 * taskStartTime and taskEndTime in PublicVariable the global variable
	 * taskType is set accordingly
	 */
	public static void searchTaskType() {
		if (noTaskStartTime() && noTaskEndTime()) {
			PublicVariables.taskType = TASK_TYPE.FLOATING;
		} else if (!noTaskStartTime() && !noTaskEndTime()) {
			PublicVariables.taskType = TASK_TYPE.EVENT;
		} else if (noTaskStartTime() && !noTaskEndTime()) {
			PublicVariables.taskType = TASK_TYPE.DEADLINE;
		} else {
			PublicVariables.taskType = TASK_TYPE.INVALID;
		}
	}

	/**
	 * function that searches for task index in the parsed in string and update
	 * the global variable taskIndex
	 * 
	 * @param argsString
	 *            passed in string
	 * @return the passed in string with the parsed index removed
	 */
	public static String searchTaskIndex(String argsString) {
		try {
			String firstWord = PublicFunctions.getFirstWord(argsString);
			String restOfString = PublicFunctions.removeFirstWord(argsString);
			PublicVariables.taskIndex = Integer.parseInt(firstWord) - 1;
			return restOfString;
		} catch (Exception e) {
			return argsString;
		}
	}

	/**
	 * function that searches for task indexes in the parsed in string and
	 * update the global variable positions
	 * 
	 * @param argsString
	 *            passed in string
	 * @return passed in string with the parsed index removed
	 */
	public static String searchTaskIndexRange(String argsString) {
		String[] indexRanges = argsString.split(indexDelimiterRegex);

		for (int i = 0; i < indexRanges.length; i++) {
			try {
				if (isIndexRange(indexRanges, i)) {
					parseIndexRange(indexRanges, i);
				} else if (isSingleIndex(indexRanges, i)) {
					parseSingleIndex(indexRanges, i);
				} else {
					return argsString;
				}
			} catch (Exception e) {
				return argsString;
			}
		}
		return null;
	}

	private static void parseSingleIndex(String[] indexRanges, int i) {
		int Index = Integer.parseInt(indexRanges[i].trim()) - 1;
		if (isNotRepeatedIndex(Index)) {
			PublicVariables.positions.add(Index);
		}
	}

	private static void parseIndexRange(String[] indexRanges, int i) {
		int index1 = Integer.parseInt(indexRanges[i].split(indexRangeDelimiterRegex)[0].trim());
		int index2 = Integer.parseInt(indexRanges[i].split(indexRangeDelimiterRegex)[1].trim());
		for (int j = Integer.min(index1, index2); j <= Integer.max(index1, index2); j++) {
			if (isNotRepeatedIndex(j - 1)) {
				PublicVariables.positions.add(j - 1);
			}
		}
	}

	private static boolean isSingleIndex(String[] indexRanges, int i) {
		return indexRanges[i].trim().matches(numberRegex);
	}

	private static boolean isIndexRange(String[] indexRanges, int i) {
		return indexRanges[i].trim().matches(rangeRegex);
	}

	private static String tryParseLocationByFirstKeyWord(String argsString) {
		String temp = argsString.trim();
		temp = temp.split(locationKeyWord1)[1];
		PublicVariables.taskLocation = temp.trim();
		return argsString.replace(locationKeyWord1 + temp.trim(), emptyString).trim();
	}

	private static String tryParseLocationBySecondKeyWord(String argsString) {
		String temp = argsString.trim();
		try {
			if (temp.substring(0, 3).equals(locationKeyWord2 + whiteSpace)) {
				PublicVariables.taskLocation = temp.substring(3);
				return argsString.replace(locationKeyWord2 + whiteSpace + temp.substring(3), emptyString);
			} else {
				temp = temp.split(whiteSpace + locationKeyWord2 + whiteSpace)[1];
				PublicVariables.taskLocation = temp.trim();
				return argsString.replace(whiteSpace + locationKeyWord2 + whiteSpace + temp.trim(), emptyString);
			}
		} catch (Exception ex) {
			return argsString.trim();
		}
	}

	private static Boolean isEmptyDesc(String argsString) {
		return argsString == null || argsString.equals(emptyString);
	}

	private static Boolean noTaskStartTime() {
		return PublicVariables.taskStartTime == null;
	}

	private static Boolean noTaskEndTime() {
		return PublicVariables.taskEndTime == null;
	}

	private static Boolean isNotRepeatedIndex(int index) {
		return !PublicVariables.positions.contains(index);
	}
}
```
