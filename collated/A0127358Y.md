# A0127358Y
###### src\test\testCommand\AddTaskTest.java
``` java
package test.testCommand;

import static org.junit.Assert.*;

import java.time.LocalDateTime;
import java.time.Month;
import java.util.ArrayList;

import org.junit.Test;

import urgenda.command.AddTask;
import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.Task;

public class AddTaskTest {

	// test execute of addTask
	@Test
	public void testExecute() throws LogicException {
		LogicData _data = LogicData.getInstance(true);
		_data.clearTasks();
		LocalDateTime notime = null;
		ArrayList<Task> expectedTasks = new ArrayList<Task>();
		Task newInput = new Task(4, "Do survey", "floating", "", true, false, false, notime, notime,
				LocalDateTime.now(), notime, null);
		expectedTasks.add(newInput);
		AddTask tester = new AddTask(newInput);
		// test normal add
		assertEquals("\"Do survey\" added", tester.execute());

		AddTask tester2 = new AddTask();
		String feedback;
		try {
			feedback = tester2.execute();
		} catch (Exception e) {
			feedback = e.getMessage();
		}
		// test invalid task
		assertEquals("Error: Task has no description", feedback);

		Task newInput2 = new Task(5, "lunch w boss", "event", "", true, false, false,
				LocalDateTime.of(2016, Month.MARCH, 30, 00, 00),
				LocalDateTime.of(2016, Month.MARCH, 30, 23, 59), LocalDateTime.now(), notime, null);
		expectedTasks.add(newInput2);
		AddTask tester3 = new AddTask(newInput2);
		// test warning
		assertEquals("\"lunch w boss\" on 30/3 00:00 - 30/3 23:59 added"
				+ "\nWarning: Event added has already passed", tester3.execute());
		checkArrayList(expectedTasks, _data.getTaskList());
		_data.clearTasks();

	}

	private void checkArrayList(ArrayList<Task> expectedTasks, ArrayList<Task> actualTasks) {
		for (int i = 0; i < actualTasks.size(); i++) {
			Task exTask = expectedTasks.get(i);
			Task actlTask = actualTasks.get(i);
			assertEquals(exTask.getDesc(), actlTask.getDesc());
			assertEquals(exTask.getLocation(), actlTask.getLocation());
			assertEquals(exTask.isCompleted(), actlTask.isCompleted());
			assertEquals(exTask.isImportant(), actlTask.isImportant());
			assertEquals(exTask.isOverdue(), actlTask.isOverdue());
			assertEquals(exTask.getStartTime(), actlTask.getStartTime());
			assertEquals(exTask.getEndTime(), actlTask.getEndTime());
			assertEquals(exTask.getTaskType(), actlTask.getTaskType());
		}
	}

	// test undo of addtask
	@Test
	public void testUndo() throws LogicException {
		LogicData _data = LogicData.getInstance(true);
		ArrayList<Task> _tasks = new ArrayList<Task>();
		LocalDateTime notime = null;
		Task obj = new Task(1, "Buy milk", "floating", "", false, false, false, notime, notime,
				LocalDateTime.now(), notime, null);
		_tasks.add(obj);
		_data.setDisplays(_tasks);
		AddTask tester = new AddTask(obj);
		tester.execute();
		assertEquals("\"Buy milk\" removed", tester.undo());
		_data.clearTasks();
	}

	// test redo of addTask
	@Test
	public void testRedo() throws LogicException {
		LogicData _data = LogicData.getInstance(true);
		ArrayList<Task> _tasks = new ArrayList<Task>();
		LocalDateTime notime = null;
		Task obj = new Task(1, "Buy milk", "floating", "", false, false, false, notime, notime,
				LocalDateTime.now(), notime, null);
		_tasks.add(obj);
		_data.setDisplays(_tasks);
		AddTask tester = new AddTask(obj);
		tester.execute();
		tester.undo();
		assertEquals("\"Buy milk\" added", tester.redo());
		_data.clearTasks();
	}

}
```
###### src\test\testCommand\DeleteTaskTest.java
``` java
package test.testCommand;

import static org.junit.Assert.*;

import java.time.LocalDateTime;
import java.time.Month;
import java.util.ArrayList;

import org.junit.Test;

import urgenda.command.DeleteTask;
import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.Task;

public class DeleteTaskTest {

	// this method is for testing whether correct feedback msg is returned for
	// deleting of tasks.
	@Test
	public void testExecute() throws LogicException {
		LogicData _data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());

		DeleteTask test = new DeleteTask();
		test.setDesc("Mop Floor");
		assertEquals("\"Mop floor\" removed", test.execute()); // test deleting
																// by desc

		DeleteTask test2 = new DeleteTask();
		ArrayList<Integer> range = new ArrayList<Integer>();
		range.add(0); // boundary value
		range.add(_data.getDisplays().size() - 1); // boundary value
		test2.setPositions(range);
		// test delete by position
		assertEquals("2 tasks have been removed: \"Buy milk\", \"Travel to Sweden\"", test2.execute());

		DeleteTask test3 = new DeleteTask();
		range.clear();
		range.add(10);
		test3.setPositions(range);
		String feedback;
		try {
			feedback = test3.execute();
		} catch (Exception e) {
			feedback = e.getMessage();
		}
		assertEquals("No matches found to delete", feedback); // test no match
		_data.clearTasks();
	}

	private LogicData setUpTestDisplayList() {
		LogicData _data = LogicData.getInstance(true);
		LocalDateTime notime = null;
		Task obj = new Task(1, "Buy milk", "floating", "", false, false, false, notime, notime,
				LocalDateTime.now(), notime, null);
		Task obj2 = new Task(2, "Submit ie2150 draft", "deadline", "", true, false, true, notime,
				LocalDateTime.of(2016, Month.FEBRUARY, 24, 23, 59), LocalDateTime.now(), notime, null);
		Task obj3 = new Task(3, "Submit ie2100 hw3", "deadline", "", false, false, false, notime,
				LocalDateTime.of(2016, Month.AUGUST, 4, 23, 59), LocalDateTime.now(), notime, null);
		Task obj4 = new Task(4, "Dental Appointment", "event", " ", true, false, false,
				LocalDateTime.now().minusHours(3), LocalDateTime.now().plusHours(1), LocalDateTime.now(),
				notime, null);
		Task obj5 = new Task(5, "Travel to Sweden", "event", " ", false, false, false,
				LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59), LocalDateTime.now(), notime, null);
		Task obj6 = new Task(1, "Mop floor", "floating", "", true, false, false, notime, notime,
				LocalDateTime.now(), notime, null);

		_data.clearTasks();
		_data.addTask(obj);
		_data.addTask(obj2);
		_data.addTask(obj3);
		_data.addTask(obj4);
		_data.addTask(obj5);
		_data.addTask(obj6);
		return _data;
	}

	@Test
	public void testUndo() throws LogicException {
		LogicData _data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		DeleteTask test = new DeleteTask();
		test.setDesc("Mop Floor");
		test.execute();
		assertEquals("\"Mop floor\" added", test.undo()); // test undo
		_data.clearTasks();
	}

	@Test
	public void testRedo() throws LogicException {
		LogicData _data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		DeleteTask test = new DeleteTask();
		test.setDesc("Mop Floor");
		test.execute();
		test.undo();
		assertEquals("\"Mop floor\" removed", test.redo()); // test redo
		_data.clearTasks();
	}

}
```
###### src\test\testCommand\EditTest.java
``` java
package test.testCommand;

import static org.junit.Assert.assertEquals;

import java.time.LocalDateTime;
import java.time.Month;

import org.junit.Test;

import urgenda.command.Edit;
import urgenda.logic.LogicData;
import urgenda.util.Task;

public class EditTest {

	// This method is for testing Edit.execute();
	@Test
	public void testExecute() throws Exception {
		LogicData _data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());

		Task testTask = new Task(1, "Buy milk and eggs", "FLOATING", "", false, false, false, null, null,
				LocalDateTime.now(), null, null);
		Edit tester = new Edit();
		tester.setId(0);
		tester.setNewTask(testTask);
		assertEquals("\"Buy milk\" has been edited to \"Buy milk and eggs\"", tester.execute());
		checkTask(testTask, _data.getTaskList().get(0));

		_data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		Task testTask2 = new Task(2, null, "EVENT", "", false, false, false,
				LocalDateTime.of(2016, Month.APRIL, 5, 10, 00),
				LocalDateTime.of(2016, Month.APRIL, 5, 12, 00), LocalDateTime.now(), null, null);
		Task exTask = new Task(2, "Buy milk", "EVENT", "", false, false, false,
				LocalDateTime.of(2016, Month.APRIL, 5, 10, 00),
				LocalDateTime.of(2016, Month.APRIL, 5, 12, 00), LocalDateTime.now(), null, null);
		Edit tester2 = new Edit();
		tester2.setNewTask(testTask2);
		tester2.setId(0);
		assertEquals(
				"\"Buy milk\" has been edited to \"Buy milk\" on 5/4 10:00 - 5/4 12:00 Warning: Event added has already passed",
				tester2.execute());
		checkTask(exTask, _data.getTaskList().get(0));
		_data.clearTasks();

	}

	private LogicData setUpTestDisplayList() {
		LogicData _data = LogicData.getInstance(true);
		LocalDateTime notime = null;
		Task obj = new Task(1, "Buy milk", "FLOATING", "", false, false, false, notime, notime,
				LocalDateTime.now(), notime, null);

		_data.clearTasks();
		_data.addTask(obj);
		return _data;
	}

	private void checkTask(Task exTask, Task actlTask) {
		assertEquals(exTask.getDesc(), actlTask.getDesc());
		assertEquals(exTask.getLocation(), actlTask.getLocation());
		assertEquals(exTask.isCompleted(), actlTask.isCompleted());
		assertEquals(exTask.isImportant(), actlTask.isImportant());
		assertEquals(exTask.isOverdue(), actlTask.isOverdue());
		assertEquals(exTask.getStartTime(), actlTask.getStartTime());
		assertEquals(exTask.getEndTime(), actlTask.getEndTime());
		assertEquals(exTask.getTaskType(), actlTask.getTaskType());
	}

	// This method is for testing undo of edit.
	@Test
	public void testUndo() throws Exception {
		LogicData _data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		Task testTask = new Task(1, "Buy milk and eggs", "FLOATING", "", false, false, false, null, null,
				LocalDateTime.now(), null, null);
		Task exTask = new Task(1, "Buy milk", "FLOATING", "", false, false, false, null, null,
				LocalDateTime.now(), null, null);
		Edit tester = new Edit();
		tester.setId(0);
		tester.setNewTask(testTask);
		tester.execute();
		assertEquals("\"Buy milk and eggs\" has been reverted to \"Buy milk\"", tester.undo());
		checkTask(exTask, _data.getTaskList().get(0));
		_data.clearTasks();
	}

	// This method is for testing redo of edit.
	@Test
	public void testRedo() throws Exception {
		LogicData _data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());

		Task testTask = new Task(1, "Buy milk and eggs", "FLOATING", "", false, false, false, null, null,
				LocalDateTime.now(), null, null);
		Task exTask = new Task(1, "Buy milk and eggs", "FLOATING", "", false, false, false, null, null,
				LocalDateTime.now(), null, null);
		Edit tester = new Edit();
		tester.setId(0);
		tester.setNewTask(testTask);
		tester.execute();
		tester.undo();
		assertEquals("\"Buy milk\" has been edited to \"Buy milk and eggs\"", tester.redo());
		checkTask(exTask, _data.getTaskList().get(0));
		_data.clearTasks();
	}

}
```
###### src\test\testCommand\PrioritiseTest.java
``` java
package test.testCommand;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.time.LocalDateTime;
import java.time.Month;
import java.util.ArrayList;

import org.junit.Test;

import urgenda.command.Prioritise;
import urgenda.logic.LogicData;
import urgenda.util.Task;

public class PrioritiseTest {

	// this method is to test Prioritise by specifying task desc
	@Test
	public void testExecuteDesc() throws Exception {
		LogicData _data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());

		Prioritise tester = new Prioritise();
		tester.setDesc("Sweden");
		// test pri by desc
		assertEquals("\"Travel to Sweden\" marked as important", tester.execute());
		assertTrue(_data.getTaskList().get(4).isImportant());

		Prioritise tester2 = new Prioritise();
		tester2.setDesc("mum");
		String feedback;
		try {
			feedback = tester2.execute();
		} catch (Exception e) {
			feedback = e.getMessage();
		}
		// test pri by desc no match
		assertEquals("No matches found to prioritise", feedback);

		Prioritise tester3 = new Prioritise();
		tester3.setDesc("Submit");
		try {
			feedback = tester3.execute();
		} catch (Exception e) {
			feedback = e.getMessage();
		}
		// test pri by desc multi matches
		assertEquals("Multiple tasks with description \"Submit\" found", feedback);
		_data.clearTasks();
	}

	private LogicData setUpTestDisplayList() {
		LogicData _data = LogicData.getInstance(true);
		LocalDateTime notime = null;
		Task obj = new Task(1, "Buy milk", "floating", "", false, false, false, notime, notime,
				LocalDateTime.now(), notime, null);
		Task obj2 = new Task(2, "Submit ie2150 draft", "deadline", "", true, false, true, notime,
				LocalDateTime.of(2016, Month.FEBRUARY, 24, 23, 59), LocalDateTime.now(), notime, null);
		Task obj3 = new Task(3, "Submit ie2100 hw3", "deadline", "", false, false, false, notime,
				LocalDateTime.of(2016, Month.AUGUST, 4, 23, 59), LocalDateTime.now(), notime, null);
		Task obj4 = new Task(4, "Dental Appointment", "event", " ", true, false, false,
				LocalDateTime.now().minusHours(3), LocalDateTime.now().plusHours(1), LocalDateTime.now(),
				notime, null);
		Task obj5 = new Task(5, "Travel to Sweden", "event", " ", false, false, false,
				LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59), LocalDateTime.now(), notime, null);
		Task obj6 = new Task(6, "Mop floor", "floating", "", true, false, false, notime, notime,
				LocalDateTime.now(), notime, null);

		_data.clearTasks();
		_data.addTask(obj);
		_data.addTask(obj2);
		_data.addTask(obj3);
		_data.addTask(obj4);
		_data.addTask(obj5);
		_data.addTask(obj6);
		return _data;
	}

	// this method is to test Prioritise by specifying task positions.
	@Test
	public void testExecutePositions() throws Exception {
		LogicData _data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());

		Prioritise tester = new Prioritise();
		ArrayList<Integer> range = new ArrayList<Integer>();
		range.add(0); // test min acceptable boundary
		range.add(3);
		range.add(_data.getDisplays().size() - 1); // test max acceptable
													// boundary
		tester.setPositions(range);
		assertEquals(
				"Priority of 3 tasks have been changed:\n"
						+ "\"Buy milk\", \"Dental Appointment\", \"Mop floor\" marked as important",
				tester.execute()); // test pri by positions
		assertTrue(_data.getTaskList().get(0).isImportant());
		assertTrue(_data.getTaskList().get(3).isImportant());
		assertTrue(_data.getTaskList().get(5).isImportant());

		range.clear();
		range.add(-6);
		Prioritise tester2 = new Prioritise();
		tester2.setPositions(range);
		String feedback;
		try {
			feedback = tester2.execute();
		} catch (Exception e) {
			feedback = e.getMessage();
		}
		assertEquals("No matches found to prioritise", feedback);

		range.clear();
		range.add(0);
		range.add(4);
		Prioritise tester3 = new Prioritise();
		tester3.setPositions(range);
		assertEquals("Priority of 1 tasks have been changed:\n" + "\"Travel to Sweden\" marked as important",
				tester3.execute()); // test pri range consisting of pri and
									// unpri task
		assertTrue(_data.getTaskList().get(0).isImportant());
		assertTrue(_data.getTaskList().get(4).isImportant());

		range.clear();
		Prioritise tester4 = new Prioritise();
		tester4.setPositions(range);
		try {
			feedback = tester4.execute();
		} catch (Exception e) {
			feedback = e.getMessage();
		}
		assertEquals("No matches found to prioritise", feedback);
		_data.clearTasks();
	}

	// This method is to test undo of Prioritise.
	@Test
	public void testUndo() throws Exception {
		LogicData _data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());

		Prioritise tester = new Prioritise();
		tester.setDesc("Sweden");
		tester.execute();
		assertEquals("\"Travel to Sweden\" unmarked from important", tester.undo());
		assertFalse(_data.getTaskList().get(4).isImportant());

		ArrayList<Integer> range = new ArrayList<Integer>();
		range.clear();
		range.add(0);
		range.add(1);
		Prioritise tester2 = new Prioritise();
		tester2.setPositions(range);
		tester2.execute();
		assertEquals("Priority of 2 tasks have been changed:\n"
				+ "\"Buy milk\", \"Submit ie2150 draft\" unmarked from important", tester2.undo());
		assertFalse(_data.getTaskList().get(0).isImportant());
		assertFalse(_data.getTaskList().get(1).isImportant());
	}

	// This method is to test redo of prioritise.
	@Test
	public void testRedo() throws Exception {
		LogicData _data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		Prioritise tester = new Prioritise();
		tester.setDesc("Sweden");
		tester.execute();
		tester.undo();
		assertEquals("\"Travel to Sweden\" marked as important", tester.redo());
		assertTrue(_data.getTaskList().get(4).isImportant());
		_data.clearTasks();
	}

}
```
###### src\test\testCommand\SearchTest.java
``` java
package test.testCommand;

import static org.junit.Assert.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Month;
import java.util.ArrayList;

import org.junit.Test;

import urgenda.command.Search;
import urgenda.logic.LogicData;
import urgenda.util.Task;

public class SearchTest {

	// This method is for testing execution of Search. Testing whether correct
	// feedback is return and correct search matches set as display.
	@Test
	public void testExecute() {
		LogicData _data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		Search tester = new Search();
		tester.setSearchInput("Sweden");
		// test search by desc
		assertEquals("Showing: all task(s) found containing \"Sweden\"", tester.execute());
		ArrayList<Task> expectedTasks = new ArrayList<Task>();
		Task match = new Task(5, "Travel to Sweden", "event", " ", false, false, false,
				LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59), LocalDateTime.now(), null, null);
		expectedTasks.add(match);
		checkArrayList(expectedTasks, _data.getDisplays());

		_data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		Search tester2 = new Search();
		tester2.setSearchDate(LocalDate.of(2016, Month.FEBRUARY, 24));
		// test search by date
		assertEquals("These are all the task(s) falling on \"2016-02-24\"", tester2.execute());
		expectedTasks.clear();
		match = new Task(2, "Submit ie2150 draft", "deadline", "", true, false, true, null,
				LocalDateTime.of(2016, Month.FEBRUARY, 24, 23, 59), LocalDateTime.now(), null, null);
		expectedTasks.add(match);
		checkArrayList(expectedTasks, _data.getDisplays());

		_data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		Search tester3 = new Search();
		tester3.setSearchDateTime(LocalDateTime.of(2016, Month.JULY, 26, 00, 00));
		// test search by datetime
		assertEquals("These are all the task(s) falling on \"2016-07-26, 00:00\"", tester3.execute());
		expectedTasks.clear();
		match = new Task(5, "Travel to Sweden", "event", " ", false, false, false,
				LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59), LocalDateTime.now(), null, null);
		expectedTasks.add(match);
		checkArrayList(expectedTasks, _data.getDisplays());

		_data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		Search tester4 = new Search();
		tester4.setSearchMonth(Month.AUGUST);
		// test search by month
		assertEquals("These are all the task(s) falling on \"AUGUST\"", tester4.execute());
		expectedTasks.clear();
		match = new Task(3, "Submit ie2100 hw3", "deadline", "", false, false, false, null,
				LocalDateTime.of(2016, Month.AUGUST, 4, 23, 59), LocalDateTime.now(), null, null);
		expectedTasks.add(match);
		match = new Task(5, "Travel to Sweden", "event", " ", false, false, false,
				LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59), LocalDateTime.now(), null, null);
		expectedTasks.add(match);
		checkArrayList(expectedTasks, _data.getDisplays());

		_data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		Search tester5 = new Search();
		tester5.setSearchId(0);
		assertEquals("Search Result: Showing detailed info of task no. 1", tester5.execute());

		_data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		Search tester6 = new Search();
		tester6.setSearchInput("floating");
		// test search tasktype
		assertEquals("Showing: all task(s) found of type \"floating\"", tester6.execute());
		expectedTasks.clear();
		match = new Task(1, "Buy milk", "floating", "", false, false, false, null, null, LocalDateTime.now(),
				null, null);
		expectedTasks.add(match);
		match = new Task(1, "Mop floor", "floating", "", true, false, false, null, null, LocalDateTime.now(),
				null, null);
		expectedTasks.add(match);
		checkArrayList(expectedTasks, _data.getDisplays());

		Search tester7 = new Search();
		tester7.setSearchInput("milk");
		// test progressive search
		assertEquals(
				"PROGRESSIVE SEARCH: all task(s) found containing \"milk\" based on the current view. Enter home to show all tasks",
				tester7.execute());
		expectedTasks.remove(1);
		checkArrayList(expectedTasks, _data.getDisplays());

		_data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		Search tester8 = new Search();
		tester8.setSearchInput("hello");
		// test no match found
		assertEquals("There is no match found for \"hello\"", tester8.execute());

		_data = setUpTestDisplayList();
		_data.setDisplays(_data.getTaskList());
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		Search tester9 = new Search("Buy egg");
		// test near match
		assertEquals("No exact match found for \"Buy egg\". Showing: 1 near match(es)", tester9.execute());
		expectedTasks.clear();
		match = new Task(1, "Buy milk", "floating", "", false, false, false, null, null, LocalDateTime.now(),
				null, null);
		expectedTasks.add(match);
		checkArrayList(expectedTasks, _data.getDisplays());
		_data.clearTasks();
	}

	private LogicData setUpTestDisplayList() {
		LogicData _data = LogicData.getInstance(true);
		LocalDateTime notime = null;
		Task obj = new Task(1, "Buy milk", "floating", "", false, false, false, notime, notime,
				LocalDateTime.now(), notime, null);
		Task obj2 = new Task(2, "Submit ie2150 draft", "deadline", "", true, false, true, notime,
				LocalDateTime.of(2016, Month.FEBRUARY, 24, 23, 59), LocalDateTime.now(), notime, null);
		Task obj3 = new Task(3, "Submit ie2100 hw3", "deadline", "", false, false, false, notime,
				LocalDateTime.of(2016, Month.AUGUST, 4, 23, 59), LocalDateTime.now(), notime, null);
		Task obj4 = new Task(4, "Dental Appointment", "event", " ", true, false, false,
				LocalDateTime.now().minusHours(3), LocalDateTime.now().plusHours(1), LocalDateTime.now(),
				notime, null);
		Task obj5 = new Task(5, "Travel to Sweden", "event", " ", false, false, false,
				LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59), LocalDateTime.now(), notime, null);
		Task obj6 = new Task(1, "Mop floor", "floating", "", true, false, false, notime, notime,
				LocalDateTime.now(), notime, null);

		_data.clearTasks();
		_data.addTask(obj);
		_data.addTask(obj2);
		_data.addTask(obj3);
		_data.addTask(obj4);
		_data.addTask(obj5);
		_data.addTask(obj6);
		return _data;
	}

	private void checkArrayList(ArrayList<Task> expectedTasks, ArrayList<Task> actualTasks) {
		for (int i = 0; i < actualTasks.size(); i++) {
			Task exTask = expectedTasks.get(i);
			Task actlTask = actualTasks.get(i);
			assertEquals(exTask.getDesc(), actlTask.getDesc());
			assertEquals(exTask.getLocation(), actlTask.getLocation());
			assertEquals(exTask.isCompleted(), actlTask.isCompleted());
			assertEquals(exTask.isImportant(), actlTask.isImportant());
			assertEquals(exTask.isOverdue(), actlTask.isOverdue());
			assertEquals(exTask.getStartTime(), actlTask.getStartTime());
			assertEquals(exTask.getEndTime(), actlTask.getEndTime());
			assertEquals(exTask.getTaskType(), actlTask.getTaskType());
		}
	}
}
```
###### src\test\testLogic\LogicCommandTest.java
``` java
package test.testLogic;

import static org.junit.Assert.*;

import org.junit.Test;

import urgenda.command.Home;
import urgenda.command.Prioritise;
import urgenda.logic.LogicCommand;

public class LogicCommandTest {

	/*
	 * This method is a simple test for testing if processCommand in
	 * LogicCommand executes properly and correct feedback is returned.
	 */
	@Test
	public void testProcessCommand() {
		LogicCommand test = new LogicCommand();
		Home cmd = new Home();
		assertEquals("Showing all tasks", test.processCommand(cmd));
		Prioritise cmd2 = new Prioritise();
		assertEquals("No matches found to prioritise", test.processCommand(cmd2));
	}

}
```
###### src\test\testLogic\LogicDataTest.java
``` java
package test.testLogic;

import static org.junit.Assert.*;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Month;
import java.util.ArrayList;

import org.junit.Test;

import urgenda.logic.LogicData;
import urgenda.util.MultipleSlot;
import urgenda.util.Task;

public class LogicDataTest {

	/*
	 * this method is to test if sort fn returns correct sorted order. test
	 * cases uses diff range of task type (floating, event, deadline, isimpt and
	 * non-impt) to ensure sufficient combination coverage. Also tests that
	 * originally sorted list will still remain sorted after sort process. In
	 * addition, test that sorting of empty arraylist will return empty
	 * arraylist.
	 */
	@Test
	public void testSortList() {
		LogicData _test = LogicData.getInstance(true);
		ArrayList<Task> _testInput = new ArrayList<Task>();
		LocalDateTime notime = null;
		Task obj = new Task("Buy milk", "", notime, notime, false);
		Task obj2 = new Task("Submit ie2150 draft", "", notime,
				LocalDateTime.of(2016, Month.FEBRUARY, 24, 23, 59), true);
		Task obj3 = new Task("Dental Appointment", "", LocalDateTime.of(2016, Month.APRIL, 4, 10, 00),
				LocalDateTime.of(2016, Month.APRIL, 4, 12, 00), false);
		Task obj4 = new Task("Travel to Sweden", "", LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59), false);
		Task obj5 = new Task("Submit ie2100 hw3", "", notime, LocalDateTime.of(2016, Month.MARCH, 3, 17, 00),
				true);
		Task obj6 = new Task("Housekeeping", "", notime, notime, false);
		Task obj7 = new Task("Dinner w mum", "", LocalDateTime.of(2016, Month.JANUARY, 8, 19, 00),
				LocalDateTime.of(2016, Month.JANUARY, 8, 20, 00), false);
		Task obj8 = new Task("Project Presentation", "", LocalDateTime.of(2016, Month.MAY, 8, 10, 00),
				LocalDateTime.of(2016, Month.MAY, 8, 12, 00), false);
		Task obj9 = new Task("Bro Birthday Dinner", "", LocalDateTime.of(2016, Month.AUGUST, 21, 20, 00),
				LocalDateTime.of(2016, Month.AUGUST, 21, 21, 00), false);
		Task obj10 = new Task("CS2103 V0.1", "", notime, LocalDateTime.of(2016, Month.MARCH, 10, 17, 00),
				true);

		_testInput.add(obj);
		_testInput.add(obj2);
		_testInput.add(obj3);
		_testInput.add(obj4);
		_testInput.add(obj5);
		_testInput.add(obj6);
		_testInput.add(obj7);
		_testInput.add(obj8);
		_testInput.add(obj9);
		_testInput.add(obj10);

		ArrayList<Task> _output = new ArrayList<Task>();
		_output.add(obj2);
		_output.add(obj5);
		_output.add(obj10);
		_output.add(obj7);
		_output.add(obj3);
		_output.add(obj8);
		_output.add(obj4);
		_output.add(obj9);
		_output.add(obj);
		_output.add(obj6);

		ArrayList<Task> _testInput2 = new ArrayList<Task>();
		_testInput2.add(obj2);
		_testInput2.add(obj5);
		_testInput2.add(obj10);
		_testInput2.add(obj7);
		_testInput2.add(obj3);
		_testInput2.add(obj8);
		_testInput2.add(obj4);
		_testInput2.add(obj9);
		_testInput2.add(obj);
		_testInput2.add(obj6);

		ArrayList<Task> _testInput3 = new ArrayList<Task>();

		assertEquals(_output, _test.sortList(_testInput));
		assertEquals(_output, _test.sortList(_testInput2)); // test original
															// sorted list
		assertEquals(_testInput3, _test.sortList(_testInput3)); // test empty
																// arraylist
	}

	/*
	 * this method is to test if findmatchingTasks returns right arraylist
	 * containing all required searched description. Test case input uses diff
	 * combination of task type. Test cases test for both single and multiple
	 * matches. Test cases also test for desc containing numbers. Test cases
	 * also test for case sensitivity. Test cases also test for substring. Test
	 * cases also test for empty string.
	 */
	@Test
	public void testFindMatchingDesc() {
		LogicData _test = LogicData.getInstance(true);
		ArrayList<Task> _testInput = new ArrayList<Task>();
		_test.setDisplays(_testInput);
		LocalDateTime notime = null;
		Task obj = new Task("Buy milk", "", notime, notime);
		Task obj2 = new Task("Buy Book", "", notime, LocalDateTime.of(2016, Month.FEBRUARY, 24, 23, 59));
		Task obj3 = new Task("Dental Appointment", "", LocalDateTime.of(2016, Month.APRIL, 4, 10, 00),
				LocalDateTime.of(2016, Month.APRIL, 4, 12, 00));
		Task obj4 = new Task("Travel to Sweden", "", LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59));
		Task obj5 = new Task("Submit ie2100 hw3", "", notime, LocalDateTime.of(2016, Month.MARCH, 3, 17, 00));
		Task obj6 = new Task("Housekeeping", "", notime, notime);
		Task obj7 = new Task("Submit ie2150 project draft", "", notime,
				LocalDateTime.of(2016, Month.JANUARY, 8, 20, 00));
		Task obj8 = new Task("Project Presentation", "", LocalDateTime.of(2016, Month.MAY, 8, 10, 00),
				LocalDateTime.of(2016, Month.MAY, 8, 12, 00));

		_testInput.add(obj);
		_testInput.add(obj2);
		_testInput.add(obj3);
		_testInput.add(obj4);
		_testInput.add(obj5);
		_testInput.add(obj6);
		_testInput.add(obj7);
		_testInput.add(obj8);

		ArrayList<Task> _output = new ArrayList<Task>();
		_output.add(obj4);
		// test single match
		assertEquals(_output, _test.findMatchingDesc("Sweden"));

		_output.clear();
		_output.add(obj);
		_output.add(obj2);
		// test multiple matches
		assertEquals(_output, _test.findMatchingDesc("Buy"));

		_output.clear();
		_output.add(obj5);
		// test desc containing numbers
		assertEquals(_output, _test.findMatchingDesc("ie2100"));

		_output.clear();
		_output.add(obj5);
		_output.add(obj7);
		// test case sensitivity and substring
		assertEquals(_output, _test.findMatchingDesc("submit IE"));

		_output.clear();
		// test empty string
		assertEquals(_output, _test.findMatchingDesc(""));
	}

	/*
	 * this method is for updating and checking whether the task falls on today.
	 * test cases partition into 5 types: floating no; event yes,no; deadline
	 * yes,no
	 */
	@Test
	public void testIsTaskToday() {
		LogicData _test = LogicData.getInstance(true);
		ArrayList<Task> _tasks = new ArrayList<Task>();
		LocalDateTime notime = null;
		Task obj = new Task("Buy milk", "", notime, notime);
		Task obj2 = new Task("Submit ie2150 draft", "", notime,
				LocalDateTime.of(2016, Month.FEBRUARY, 24, 23, 59));
		Task obj3 = new Task("Submit ie2100 hw3", "", notime, LocalDateTime.now());
		Task obj4 = new Task("Dental Appointment", "", LocalDateTime.now(), LocalDateTime.now().plusHours(2));
		Task obj5 = new Task("Travel to Sweden", "", LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59));

		_tasks.add(obj);
		_tasks.add(obj2);
		_tasks.add(obj3);
		_tasks.add(obj4);
		_tasks.add(obj5);

		assertFalse(_test.isTaskToday(_tasks.get(0))); // floating
		assertFalse(_test.isTaskToday(_tasks.get(1))); // deadline false
		assertTrue(_test.isTaskToday(_tasks.get(2))); // deadline true
		assertTrue(_test.isTaskToday(_tasks.get(3))); // event true
		assertFalse(_test.isTaskToday(_tasks.get(4))); // event false

	}

	/*
	 * This method is to find task based on given arraylist of id. Equivalence
	 * partition, boundaries values are : MIN_INT, MAX_INT, 0, -1,
	 * _tasks.size(), _tasks.size -1, a random value in btwn 0 and display size
	 * 
	 */
	@Test
	public void testFindMatchingPosition() {
		LogicData _test = LogicData.getInstance(true);
		ArrayList<Task> _testInput = new ArrayList<Task>();
		_test.setDisplays(_testInput);
		LocalDateTime notime = null;
		Task obj = new Task("Cut hair", "", notime, notime);
		Task obj2 = new Task("Bro's Birthday Dinner", "", LocalDateTime.of(2016, Month.AUGUST, 31, 19, 00),
				LocalDateTime.of(2016, Month.AUGUST, 31, 21, 00));
		Task obj3 = new Task("Dental Appointment", "", LocalDateTime.of(2016, Month.APRIL, 4, 10, 00),
				LocalDateTime.of(2016, Month.APRIL, 4, 12, 00));
		Task obj4 = new Task("IE2100 Midterm", "", LocalDateTime.of(2016, Month.MARCH, 2, 13, 00),
				LocalDateTime.of(2016, Month.MARCH, 2, 13, 45));
		Task obj5 = new Task("Submit ie2100 hw3", "", notime, LocalDateTime.of(2016, Month.MARCH, 9, 17, 00));
		Task obj6 = new Task("Housekeeping", "", notime, notime);

		_testInput.add(obj);
		_testInput.add(obj2);
		_testInput.add(obj3);
		_testInput.add(obj4);
		_testInput.add(obj5);
		_testInput.add(obj6);

		assertEquals(null, _test.findMatchingPosition(Integer.MIN_VALUE)); // test
																			// MIN_INT
		assertEquals(null, _test.findMatchingPosition(Integer.MAX_VALUE)); // test
																			// MAX_INT
		assertEquals(obj, _test.findMatchingPosition(0)); // test 0
		assertEquals(null, _test.findMatchingPosition(-1)); // test -1
		assertEquals(null, _test.findMatchingPosition(6)); // test task.size
		assertEquals(obj6, _test.findMatchingPosition(5)); // test boundary of
															// task.size
		assertEquals(obj4, _test.findMatchingPosition(3)); // any random value
															// in btwn
	}

	/*
	 * This method is to find task based on input date regardless of time.
	 * Equivalence partition, Boundary values: no match, single match, multiple
	 * matches.
	 */
	@Test
	public void testFindMatchingDate() {
		LogicData _test = LogicData.getInstance(true);
		ArrayList<Task> _tasks = new ArrayList<Task>();
		_test.setDisplays(_tasks);
		LocalDateTime notime = null;
		Task obj = new Task(1, "Buy milk", "FLOATING", "", false, false, false, notime, notime,
				LocalDateTime.now(), notime, null);
		Task obj2 = new Task(2, "Submit ie2150 draft", "DEADLINE", "", true, false, true, notime,
				LocalDateTime.of(2016, Month.FEBRUARY, 24, 23, 59), LocalDateTime.now(), notime, null);
		Task obj3 = new Task(3, "Submit ie2100 hw3", "DEADLINE", "", false, false, false, notime,
				LocalDateTime.now(), LocalDateTime.now(), notime, null);
		Task obj4 = new Task(4, "Dental Appointment", "EVENT", " ", true, false, false,
				LocalDateTime.now().minusHours(3), LocalDateTime.now().plusHours(1), LocalDateTime.now(),
				notime, null);
		Task obj5 = new Task(5, "Travel to Sweden", "EVENT", " ", false, false, false,
				LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59), LocalDateTime.now(), notime, null);
		Task obj6 = new Task(1, "Mop floor", "FLOATING", "", true, false, false, notime, notime,
				LocalDateTime.now(), notime, null);

		_tasks.add(obj);
		_tasks.add(obj2);
		_tasks.add(obj3);
		_tasks.add(obj4);
		_tasks.add(obj5);
		_tasks.add(obj6);

		ArrayList<Task> _output = new ArrayList<Task>();
		_output.add(obj3);
		_output.add(obj4);
		assertEquals(_output, _test.findMatchingDates(LocalDateTime.now().toLocalDate())); // test
																							// multiple
																							// matches
		_output.clear();
		_output.add(obj2);
		assertEquals(_output, _test.findMatchingDates(LocalDate.of(2016, Month.FEBRUARY, 24))); // test
																								// single
																								// match
		_output.clear();
		assertEquals(_output, _test.findMatchingDates(LocalDate.of(2016, Month.AUGUST, 29))); // test
																								// no
																								// match
	}

	/*
	 * this method is to find task based on input datetime. Equivalence
	 * partition, Boundary values: no match (totally diff), no match(only time
	 * diff), single match, multiple matches.
	 * 
	 */
	@Test
	public void testFindMatchingDateTimes() {
		LogicData _test = LogicData.getInstance(true);
		ArrayList<Task> _tasks = new ArrayList<Task>();
		_test.setDisplays(_tasks);
		LocalDateTime notime = null;
		Task obj = new Task("Internship interview", "", LocalDateTime.of(2016, Month.APRIL, 4, 13, 00),
				LocalDateTime.of(2016, Month.APRIL, 4, 15, 00));
		Task obj2 = new Task("Bae's 21st", "", LocalDateTime.of(2016, Month.JANUARY, 15, 19, 00),
				LocalDateTime.of(2016, Month.JANUARY, 15, 21, 00));
		Task obj3 = new Task("Valentine's dinner", "", LocalDateTime.of(2016, Month.FEBRUARY, 14, 10, 00),
				LocalDateTime.of(2016, Month.FEBRUARY, 14, 12, 00));
		Task obj4 = new Task("IE2100 Midterm", "", LocalDateTime.of(2016, Month.MARCH, 2, 13, 00),
				LocalDateTime.of(2016, Month.MARCH, 2, 13, 45));
		Task obj5 = new Task("Renew pass port", "", notime, LocalDateTime.of(2016, Month.MARCH, 2, 13, 00));
		Task obj6 = new Task("Level up pokemon", "", notime, notime);

		_tasks.add(obj);
		_tasks.add(obj2);
		_tasks.add(obj3);
		_tasks.add(obj4);
		_tasks.add(obj5);
		_tasks.add(obj6);

		ArrayList<Task> _output = new ArrayList<Task>();
		_output.add(obj3);
		// test single match
		assertEquals(_output,
				_test.findMatchingDateTimes(LocalDateTime.of(2016, Month.FEBRUARY, 14, 10, 00)));
		_output.clear();
		_output.add(obj4);
		_output.add(obj5);
		// test multiple matches
		assertEquals(_output, _test.findMatchingDateTimes(LocalDateTime.of(2016, Month.MARCH, 2, 13, 00)));
		_output.clear();
		// test no match totally different
		assertEquals(_output,
				_test.findMatchingDateTimes(LocalDateTime.of(2016, Month.SEPTEMBER, 2, 13, 00)));
		// test no match (only time diff)
		assertEquals(_output, _test.findMatchingDateTimes(LocalDateTime.of(2016, Month.APRIL, 4, 18, 00)));

	}

	/*
	 * This method is to find task based on input month. Equivalence partition,
	 * Boundary values: no match, single match, multiple matches
	 * 
	 */
	@Test
	public void testFindMatchingMonths() {
		LogicData _test = LogicData.getInstance(true);
		ArrayList<Task> _testInput = new ArrayList<Task>();
		_test.setDisplays(_testInput);
		LocalDateTime notime = null;
		Task obj = new Task("Internship interview", "", LocalDateTime.of(2016, Month.APRIL, 4, 13, 00),
				LocalDateTime.of(2016, Month.APRIL, 4, 15, 00));
		Task obj2 = new Task("Bae's 21st", "", LocalDateTime.of(2016, Month.JANUARY, 15, 19, 00),
				LocalDateTime.of(2016, Month.JANUARY, 15, 21, 00));
		Task obj3 = new Task("Good Friday Holi", "", LocalDateTime.of(2016, Month.MARCH, 18, 00, 00),
				LocalDateTime.of(2016, Month.MARCH, 18, 23, 59));
		Task obj4 = new Task("IE2100 Midterm", "", LocalDateTime.of(2016, Month.MARCH, 2, 13, 00),
				LocalDateTime.of(2016, Month.MARCH, 2, 13, 45));
		Task obj5 = new Task("Pay bills", "", notime, LocalDateTime.of(2016, Month.MARCH, 16, 17, 00));
		Task obj6 = new Task("Housewarming", "", notime, notime);

		_testInput.add(obj);
		_testInput.add(obj2);
		_testInput.add(obj3);
		_testInput.add(obj4);
		_testInput.add(obj5);
		_testInput.add(obj6);

		ArrayList<Task> _output = new ArrayList<Task>();
		_output.add(obj3);
		_output.add(obj4);
		_output.add(obj5);
		// test multiple matches
		assertEquals(_output, _test.findMatchingMonths(Month.MARCH));
		_output.clear();
		_output.add(obj2);
		// test single match
		assertEquals(_output, _test.findMatchingMonths(Month.JANUARY));
		_output.clear();
		// test no match
		assertEquals(_output, _test.findMatchingMonths(Month.DECEMBER));
	}

	/*
	 * This method is to find task that has a specified blockslot. Equivalence
	 * partition, Boundary values: no match, single match, multiple matches.
	 * 
	 */
	@Test
	public void testFindBlocks() {
		LogicData _test = LogicData.getInstance(true);
		MultipleSlot block = new MultipleSlot();
		block.addTimeSlot(LocalDateTime.of(2016, Month.MAY, 15, 19, 00),
				LocalDateTime.of(2016, Month.MAY, 15, 21, 00));
		MultipleSlot block2 = new MultipleSlot();
		block2.addTimeSlot(LocalDateTime.of(2016, Month.JUNE, 4, 19, 00),
				LocalDateTime.of(2016, Month.JUNE, 4, 21, 00));
		MultipleSlot block3 = new MultipleSlot();
		block3.addTimeSlot(LocalDateTime.of(2016, Month.JULY, 4, 19, 00),
				LocalDateTime.of(2016, Month.JULY, 4, 21, 00));
		Task obj = new Task("Internship interview", "", LocalDateTime.of(2016, Month.APRIL, 4, 13, 00),
				LocalDateTime.of(2016, Month.APRIL, 4, 15, 00));
		Task obj2 = new Task("Bae's 21st", "", LocalDateTime.of(2016, Month.JANUARY, 15, 19, 00),
				LocalDateTime.of(2016, Month.JANUARY, 15, 21, 00));
		Task obj3 = new Task("Good Friday Holi", "", LocalDateTime.of(2016, Month.MARCH, 18, 00, 00),
				LocalDateTime.of(2016, Month.MARCH, 18, 23, 59));
		Task obj4 = new Task("IE2100 Midterm", "", LocalDateTime.of(2016, Month.MARCH, 2, 13, 00),
				LocalDateTime.of(2016, Month.MARCH, 2, 13, 45));
		obj.setSlot(block);
		obj2.setSlot(block2);
		obj4.setSlot(block);
		_test.addTask(obj);
		_test.addTask(obj2);
		_test.addTask(obj3);
		_test.addTask(obj4);

		ArrayList<Task> _output = new ArrayList<Task>();
		_output.add(obj2);
		assertEquals(_output, _test.findBlocks(block2)); // test single match
		_output.clear();
		_output.add(obj);
		_output.add(obj4);
		assertEquals(_output, _test.findBlocks(block)); // test multiple matches
		_output.clear();
		assertEquals(_output, _test.findBlocks(block3)); // test no match
	}

	/*
	 * this method is for checking whether the user is showing more on a task.
	 * Test cases partition into 2 main types: yes or no, 6 subtypes: floating
	 * yes,no; event yes,no; deadline yes,no
	 * 
	 */
	@Test
	public void testIsShowingMore() {
		LogicData _test = LogicData.getInstance(true);
		LocalDateTime notime = null;
		Task obj = new Task("Buy milk", "", notime, notime);
		Task obj2 = new Task("Submit ie2150 draft", "", notime,
				LocalDateTime.of(2016, Month.FEBRUARY, 24, 23, 59));
		Task obj3 = new Task("Submit ie2100 hw3", "", notime, LocalDateTime.now());
		Task obj4 = new Task("Dental Appointment", "", LocalDateTime.now(), LocalDateTime.now().plusHours(2));
		Task obj5 = new Task("Travel to Sweden", "", LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59));
		Task obj6 = new Task("Housekeeping", "", notime, notime);
		_test.toggleShowMoreTasks(obj);
		_test.toggleShowMoreTasks(obj2);
		_test.toggleShowMoreTasks(obj4);
		assertTrue(_test.isShowingMore(obj)); // test floating yes
		assertTrue(_test.isShowingMore(obj2)); // test deadline yes
		assertFalse(_test.isShowingMore(obj3)); // test deadline no
		assertTrue(_test.isShowingMore(obj4)); // test event yes
		assertFalse(_test.isShowingMore(obj5)); // test event no
		assertFalse(_test.isShowingMore(obj6)); // test floating no
	}

}
```
###### src\test\testUtils\TaskTest.java
``` java
package test.testUtils;

import static org.junit.Assert.*;

import java.time.LocalDateTime;
import java.time.Month;

import org.junit.Test;

import urgenda.util.MultipleSlot;
import urgenda.util.Task;

public class TaskTest {

	/*
	 * This method is for checking whether a task has been marked as completed.
	 * test cases partition into 2 main types: yes or no, 6 subtypes: floating
	 * yes,no ; event yes,no; deadline yes,no. Also test on empty task.
	 */
	@Test
	public void testIsCompleted() {
		LocalDateTime notime = null;
		MultipleSlot slot = null;
		Task obj = new Task(1, "Buy milk", "floating", "", false, false, false, notime, notime,
				LocalDateTime.now(), notime, slot);
		Task obj2 = new Task(2, "Submit ie2150 draft", "deadline", "", true, false, true, notime,
				LocalDateTime.of(2016, Month.FEBRUARY, 24, 23, 59), LocalDateTime.now(), notime, slot);
		Task obj3 = new Task(3, "Submit ie2100 hw3", "deadline", "", false, false, false, notime,
				LocalDateTime.now(), LocalDateTime.now(), notime, slot);
		Task obj4 = new Task(4, "Dental Appointment", "event", " ", true, false, false,
				LocalDateTime.now().minusHours(3), LocalDateTime.now().plusHours(1), LocalDateTime.now(),
				notime, slot);
		Task obj5 = new Task(5, "Travel to Sweden", "event", " ", false, false, false,
				LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59), LocalDateTime.now(), notime, slot);
		Task obj6 = new Task(1, "Mop floor", "floating", "", true, false, false, notime, notime,
				LocalDateTime.now(), notime, slot);
		Task obj7 = new Task();

		assertFalse(obj.isCompleted()); // test floating no
		assertTrue(obj2.isCompleted()); // test deadline yes
		assertFalse(obj3.isCompleted()); // test deadline no
		assertTrue(obj4.isCompleted()); // test event yes
		assertFalse(obj5.isCompleted()); // test event no
		assertTrue(obj6.isCompleted()); // test floating yes
		assertFalse(obj7.isCompleted()); // test empty task

	}

	/*
	 * This method is for checking whether a task has been marked as important.
	 * Test cases partition into 2 main types: yes or no, 6 subtypes: floating
	 * yes,no ; event yes,no; deadline yes,no. Also test on empty task
	 */
	@Test
	public void testIsImportant() {
		LocalDateTime notime = null;
		MultipleSlot slot = null;
		Task obj = new Task(1, "Buy milk", "floating", "", false, false, false, notime, notime,
				LocalDateTime.now(), notime, slot);
		Task obj2 = new Task(2, "Submit ie2150 draft", "deadline", "", true, true, true, notime,
				LocalDateTime.of(2016, Month.FEBRUARY, 24, 23, 59), LocalDateTime.now(), notime, slot);
		Task obj3 = new Task(3, "Submit ie2100 hw3", "deadline", "", false, false, false, notime,
				LocalDateTime.now(), LocalDateTime.now(), notime, slot);
		Task obj4 = new Task(4, "Dental Appointment", "event", " ", true, true, false,
				LocalDateTime.now().minusHours(3), LocalDateTime.now().plusHours(1), LocalDateTime.now(),
				notime, slot);
		Task obj5 = new Task(5, "Travel to Sweden", "event", " ", false, false, false,
				LocalDateTime.of(2016, Month.JULY, 26, 00, 00),
				LocalDateTime.of(2016, Month.AUGUST, 17, 23, 59), LocalDateTime.now(), notime, slot);
		Task obj6 = new Task(1, "Renew pastport", "floating", "", true, true, false, notime, notime,
				LocalDateTime.now(), notime, slot);
		Task obj7 = new Task();

		assertFalse(obj.isImportant()); // test floating no
		assertTrue(obj2.isImportant()); // test deadline yes
		assertFalse(obj3.isImportant()); // test deadline no
		assertTrue(obj4.isImportant()); // test event yes
		assertFalse(obj5.isImportant()); // test event no
		assertTrue(obj6.isImportant()); // test floating yes
		assertFalse(obj7.isImportant()); // test empty task
	}

	/*
	 * This method is for checking whether a task is overdue.Test cases
	 * partition into 2 main types: yes or no; deadline can be yes or no,
	 * floating, event and empty task will always be no.
	 */
	@Test
	public void testIsOverdue() {
		LocalDateTime notime = null;
		MultipleSlot slot = null;
		Task obj = new Task(1, "Buy milk", "floating", "", false, false, false, notime, notime,
				LocalDateTime.now(), notime, slot);
		Task obj2 = new Task(2, "Submit ie2150 draft", "deadline", "", true, false, true, notime,
				LocalDateTime.of(2016, Month.FEBRUARY, 24, 23, 59), LocalDateTime.now(), notime, slot);
		Task obj3 = new Task(3, "Submit ie2100 hw3", "deadline", "", false, true, false, notime,
				LocalDateTime.now(), LocalDateTime.now(), notime, slot);
		Task obj4 = new Task(4, "Dental Appointment", "event", " ", true, false, false,
				LocalDateTime.now().minusHours(3), LocalDateTime.now().plusHours(1), LocalDateTime.now(),
				notime, slot);
		Task obj5 = new Task();

		assertFalse(obj.isOverdue()); // test floating
		assertTrue(obj2.isOverdue()); // test deadline yes
		assertFalse(obj3.isOverdue()); // test deadline no
		assertFalse(obj4.isOverdue()); // test event
		assertFalse(obj5.isOverdue()); // test empty task
	}

	/*
	 * This method is for checking whether two task overlaps. Equivalence
	 * Partition: Dont overlap (task tested lies totally to the left of compared
	 * task) Dont overlap(task tested lies totally to the right of compared
	 * task. Overlap: End of task tested overlaps w compared task. Overlap:
	 * start of task tested overlaps w compared task. Overlap: task tested same
	 * as compared task. Overlap: task tested lies within compared task.
	 * Overlap: task compared is subset of task tested. Boundary value analysis:
	 * used 00000 , 235959 as timings
	 */
	@Test
	public void testHasOverlap() {
		Task test = new Task();
		LocalDateTime start = LocalDateTime.of(2016, Month.MARCH, 1, 9, 00, 00);
		LocalDateTime end = LocalDateTime.of(2016, Month.MARCH, 1, 22, 00, 00);
		LocalDateTime compareStart1 = LocalDateTime.of(2016, Month.MARCH, 1, 9, 00, 00);
		LocalDateTime compareEnd1 = LocalDateTime.of(2016, Month.MARCH, 1, 22, 00, 00);
		LocalDateTime compareStart2 = LocalDateTime.of(2016, Month.MARCH, 1, 19, 30, 59);
		LocalDateTime compareEnd2 = LocalDateTime.of(2016, Month.MARCH, 1, 20, 45, 01);
		// Boundary value for time 00,00
		LocalDateTime compareStart3 = LocalDateTime.of(2016, Month.MARCH, 1, 00, 00, 00);
		LocalDateTime compareEnd3 = LocalDateTime.of(2016, Month.MARCH, 1, 11, 17, 00);
		LocalDateTime compareStart4 = LocalDateTime.of(2016, Month.MARCH, 1, 12, 35, 00);
		// The other Boundary value for time 23,59
		LocalDateTime compareEnd4 = LocalDateTime.of(2016, Month.MARCH, 1, 23, 59, 59);
		LocalDateTime compareStart5 = LocalDateTime.of(2016, Month.MARCH, 1, 7, 00, 00);
		LocalDateTime compareEnd5 = LocalDateTime.of(2016, Month.MARCH, 1, 9, 00, 00);
		LocalDateTime compareStart6 = LocalDateTime.of(2016, Month.MARCH, 1, 22, 00, 00);
		LocalDateTime compareEnd6 = LocalDateTime.of(2016, Month.MARCH, 1, 23, 00, 00);
		LocalDateTime compareStart7 = LocalDateTime.of(2016, Month.MARCH, 1, 8, 00, 34);
		LocalDateTime compareEnd7 = LocalDateTime.of(2016, Month.MARCH, 1, 23, 54, 00);

		// overlap: task tested same as compared task.
		assertTrue(test.hasOverlap(start, end, compareStart1, compareEnd1));
		// overlap: task tested lies within compared task.
		assertTrue(test.hasOverlap(start, end, compareStart2, compareEnd2));
		// Overlap: End of task tested overlaps w compared task.
		assertTrue(test.hasOverlap(start, end, compareStart3, compareEnd3));
		// Overlap: Start of task tested overlaps w compared task.
		assertTrue(test.hasOverlap(start, end, compareStart4, compareEnd4));
		// Dont overlap (task tested lies totally to the left of compared task)
		assertFalse(test.hasOverlap(start, end, compareStart5, compareEnd5));
		// Dont overlap (task tested lies totally to the right of compared task)
		assertFalse(test.hasOverlap(start, end, compareStart6, compareEnd6));
		// Overlap: task compared is subset of task tested.
		assertTrue(test.hasOverlap(start, end, compareStart7, compareEnd7));

	}

	/*
	 * This method test whether a task is overlapping w other task. Equivalence
	 * partition: yes, no, no(not an event), no(empty task)
	 */
	@Test
	public void testIsOverlapping() {
		LocalDateTime notime = null;
		MultipleSlot slot = null;
		Task compare = new Task(4, "Dental Appointment", "EVENT", " ", true, false, false,
				LocalDateTime.now().minusHours(3), LocalDateTime.now().plusHours(1), LocalDateTime.now(),
				notime, slot);
		Task test1 = new Task(1, "Buy milk", "FLOATING", "", false, false, false, notime, notime,
				LocalDateTime.now(), notime, slot);
		Task test2 = new Task(2, "Dental Appointment", "EVENT", " ", true, false, false,
				LocalDateTime.now().minusHours(2), LocalDateTime.now(), LocalDateTime.now(), notime, slot);
		Task test3 = new Task(3, "Dental Appointment", "EVENT", " ", true, false, false,
				LocalDateTime.now().plusHours(3), LocalDateTime.now().plusHours(5), LocalDateTime.now(),
				notime, slot);
		Task test4 = new Task();

		assertFalse(compare.isOverlapping(test1)); // no (non-event)
		assertTrue(compare.isOverlapping(test2)); // yes
		assertFalse(compare.isOverlapping(test3)); // no
		assertFalse(compare.isOverlapping(test4)); // no (empty task)
	}

}
```
###### src\urgenda\command\Demo.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * Demo is the command object used for running a short demo in Urgenda.
 *
 */
public class Demo extends Command {

	/**
	 * Execute command of demo which runs a short demo version of Urgenda.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.DEMO);
		data.clearShowMoreTasks();
		return null;
	}

}
```
###### src\urgenda\command\Edit.java
``` java
package urgenda.command;

import java.time.LocalDateTime;
import java.util.ArrayList;

import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * Edit is the command object used for editing of task in Urgenda.
 * 
 */
public class Edit extends TaskCommand {

	private static final String MESSAGE_NO_EDIT_MATCH = "Invalid task number. No matches found to edit";
	private static final String MESSAGE_EDIT = " has been edited to ";
	private static final String MESSAGE_REVERTED = " has been reverted to ";
	private static final String MESSAGE_ERROR = "Error: ";
	private static final String MESSAGE_OVERLAP = " Warning: Overlaps with ";
	private static final String MESSAGE_EVENT_PASSED = " Warning: Event added has already passed";
	private static final String MESSAGE_DEADLINE_PASSED = " Warning: Deadline added has already passed";

	private static UrgendaLogger logger = UrgendaLogger.getInstance();
	private LogicData _data;
	private Integer _id;
	private Task _prevTask;
	// a copy of prevTask for edition and comparison of time so that time in
	// prevTask will not get modified during execution
	private Task _temp;
	// new copy of task for edition w info for edition entered by user
	private Task _newTask = new Task();
	// a timing variable for storing of time that user entered w/o starttime and
	// or endtime flag
	LocalDateTime _unknown;
	// a boolean variable to indicate removal of one timing (change of task type
	// from event to deadline or deadline to floating
	boolean isRemoveOnce = false;
	// a boolean variable to indicate removal of a second timing (only set as
	// true after isRemoveOnce is alr set as true)
	// for change of task type from event to floating
	boolean isRemoveTwice = false;

	/**
	 * Execute command of Edit which edits _prevTask to _newTask.
	 */
	public String execute() throws LogicException {
		_data = LogicData.getInstance();
		if (_id != null && _id.intValue() > -1) {
			_prevTask = _data.findMatchingPosition(_id.intValue());
		}
		if (_prevTask == null) {
			_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			logger.getLogger().severe("Exception(No edit match) thrown");
			throw new LogicException(MESSAGE_NO_EDIT_MATCH);
		} else {
			_temp = new Task(_prevTask);
			performEdition();
			updateEdition();
			String warning = checkValidity();
			return taskMessageWithLocation(_prevTask) + MESSAGE_EDIT + taskMessageWithLocation(_newTask)
					+ warning;
		}
	}

	/*
	 * method to check for warnings, start time after end time etc and set
	 * pointer to edited task.
	 */
	private String checkValidity() throws LogicException {
		String warning;
		try {
			checkTaskValidity(_newTask);
			_data.deleteTask(_prevTask);
			_data.addTask(_newTask);
			_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			_data.setTaskPointer(_newTask);
			_data.clearShowMoreTasks();
			warning = checkPassed();
			warning += findOverlaps();
		} catch (LogicException e) {
			logger.getLogger().severe("Exception occured: " + e);
			_data.setCurrState(LogicData.DisplayState.INVALID_TASK);
			// throws exception to prevent Edit being added to undo stack
			throw new LogicException(MESSAGE_ERROR + e.getMessage());
		}
		return warning;
	}

	/*
	 * Method to update fields that are non-editable through edit command by
	 * users e.g. multislot, priority, datemodified etc.
	 */
	private void updateEdition() {
		_newTask.setId(_prevTask.getId());
		_newTask.setSlot(_prevTask.getSlot());
		_newTask.setIsCompleted(_prevTask.isCompleted());
		_newTask.setIsImportant(_prevTask.isImportant());
		_newTask.setDateAdded(_prevTask.getDateAdded());
		_newTask.updateTaskType();
		updateDateModified();
	}

	/*
	 * Method to perform edition of prev task to new task.
	 */
	private void performEdition() {
		setMultiSlots();
		removeTimings();
		_temp.updateTaskType();
		setDesc();
		setLocation();
		setNewTimings();
	}

	private void setNewTimings() {
		if (_unknown == null) {
			setDefiniteTime();
		} else {
			determineUnclearTimings();
			setDefiniteTime();
		}
	}

	/*
	 * Method to determine whether timing entered is for edition of start/end
	 * time if user input it w/o start &/ end flag.
	 */
	private void determineUnclearTimings() {
		switch (_temp.getTaskType()) {
		case FLOATING : // Fallthrough
		case DEADLINE :
			// if prevtask is of type float/event (after removal of time had alr
			// been performed), set unknown as endtime.
			setUnknownAsEndTime();
			break;
		default :
			// if prevTask is of type event, compare unknown w task time
			checkStartEndAndSetUnknown();
			break;
		}
	}

	/*
	 * if user entered new timing w/o start/end time, if task to be
	 * edited(_temp) is of type event. Check if new timing entered is before
	 * _temp start time, set new timing as starttime if new timing entered is
	 * after _temp end time, set new timing as endtime. Else if is in btwn, take
	 * default as changing start, set to start time.
	 */
	private void checkStartEndAndSetUnknown() {
		if (_newTask.getStartTime() == null && _newTask.getEndTime() == null) {
			if (_unknown.isBefore(_temp.getStartTime())) {
				_newTask.setStartTime(_unknown);
			} else if (_unknown.isAfter(_temp.getEndTime())) {
				_newTask.setEndTime(_unknown);
			} else {
				_newTask.setStartTime(_unknown);
			}
		} else {
			// when user enter 2 new time to be edited, one w flag one w/o falg
			// e.g. 7pm to 10pm instead of from 7pm to 10pm, the unknown
			// non-flag one
			// could be determined
			if (_newTask.getEndTime() == null) {
				_newTask.setEndTime(_unknown);
			} else {
				_newTask.setStartTime(_unknown);
			}
		}
	}

	private void setUnknownAsEndTime() {
		if (_newTask.getStartTime() == null && _newTask.getEndTime() == null) {
			_newTask.setEndTime(_unknown);
		} else {
			if (_newTask.getEndTime() == null) {
				_newTask.setEndTime(_unknown);
			} else {
				_newTask.setStartTime(_unknown);
			}
		}
	}

	// when user enter timing to be edited w flag, set to _newTask accordingly.
	private void setDefiniteTime() {
		if (_newTask.getStartTime() == null) {
			_newTask.setStartTime(_temp.getStartTime());
		}
		if (_newTask.getEndTime() == null) {
			_newTask.setEndTime(_temp.getEndTime());
		}
	}

	private void setLocation() {
		if (_newTask.getLocation() == null
				|| _newTask.getLocation().equals("") && _prevTask.getLocation() != null) {
			_newTask.setLocation(_prevTask.getLocation());
		}
	}

	private void setDesc() {
		if (_newTask.getDesc() == null || _newTask.getDesc().equals("") && _prevTask.getDesc() != null) {
			_newTask.setDesc(_prevTask.getDesc());
		}
	}

	private void setMultiSlots() {
		if (_newTask.getSlot() == null || _newTask.getSlot().isEmpty()) {
			_newTask.setSlot(null);
		}
	}

	private void removeTimings() {
		if (isRemoveOnce) {
			if (_temp.getStartTime() != null) {
				_temp.setStartTime(null);
			} else {
				_temp.setEndTime(null);
			}
		}
		if (isRemoveTwice) {
			_temp.setEndTime(null);
		}
	}

	private void updateDateModified() {
		_newTask.setDateModified(LocalDateTime.now());
		_prevTask.setDateModified(LocalDateTime.now());
	}

	private String checkPassed() {
		if (_newTask.getTaskType() == Task.Type.EVENT) {
			if (_newTask.getEndTime().isBefore(LocalDateTime.now())) {
				return MESSAGE_EVENT_PASSED;
			}
		} else if (_newTask.getTaskType() == Task.Type.DEADLINE) {
			if (_newTask.getEndTime().isBefore(LocalDateTime.now())) {
				return MESSAGE_DEADLINE_PASSED;
			}
		}
		return "";
	}

	private String findOverlaps() {
		ArrayList<Task> overlaps;
		overlaps = _data.overlappingTasks(_newTask);
		if (overlaps.size() == 0) {
			return "";
		} else {
			String feedback = MESSAGE_OVERLAP + taskMessage(overlaps.get(0));
			overlaps.remove(0);
			for (Task task : overlaps) {
				feedback += ", " + taskMessage(task);
			}
			return feedback;
		}
	}

	/**
	 * Undo method of Edit which undo the revert the task edited back to
	 * original.
	 */
	public String undo() {
		updateDateModified();
		_data.deleteTask(_newTask);
		_data.addTask(_prevTask);
		_data.setTaskPointer(_prevTask);
		return taskMessageWithLocation(_newTask) + MESSAGE_REVERTED + taskMessageWithLocation(_prevTask);
	}

	/**
	 * Redo method of Edit which redo the action and edit the task to the new
	 * version.
	 */
	public String redo() {
		updateDateModified();
		_data.deleteTask(_prevTask);
		_data.addTask(_newTask);
		_data.setTaskPointer(_newTask);
		return taskMessageWithLocation(_prevTask) + MESSAGE_EDIT + taskMessageWithLocation(_newTask)
				+ findOverlaps();
	}

	/**
	 * Setter for the position of the task to be edited.
	 * 
	 * @param id
	 */
	public void setId(int id) {
		_id = Integer.valueOf(id);
	}

	/**
	 * Setter for the new edited task containing info of the fields to be edited
	 * (e.g. new desc, location, timings etc).
	 * 
	 * @param newTask
	 */
	public void setNewTask(Task newTask) {
		_newTask = newTask;
	}

	/**
	 * Setter for unknown, a LocalDateTime variable for storing of timing that
	 * user entered w/o starttime andor endtime flags.
	 * 
	 * @param unknown
	 */
	public void setUnknown(LocalDateTime unknown) {
		_unknown = unknown;
	}

	/**
	 * Setter for boolean variable isRemovedOnce which is used to indicate the
	 * removal of one timing (change of task type).
	 */
	public void setIsRemovedOnce() {
		isRemoveOnce = true;
	}

	/**
	 * Setter for boolean variable isRemovedTwice (only set after isRemovedOnce
	 * had alr been set as true) which is used to indicate the removal of two
	 * timings.
	 */
	public void setIsRemovedTwice() {
		isRemoveTwice = true;
	}
}
```
###### src\urgenda\command\Exit.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * Exit is the command object used for exiting and closing of Urgenda.
 *
 */
public class Exit extends Command {

	/**
	 * Execute command of Exit which closes Urgenda.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.EXIT);
		return null;
	}

}
```
###### src\urgenda\command\Help.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * Help is the command object used for generating help (user manual) of Urgenda.
 *
 */
public class Help extends Command {

	/**
	 * Execute command of Help which set current state of system to HELP.state
	 * and hence indicates to display help guide to user.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.HELP);
		return "";
	}

}
```
###### src\urgenda\command\Hide.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * Hide is the command object used for minimising app window of Urgenda.
 *
 */
public class Hide extends Command {

	/**
	 * Execute command of hide which minimises/hides Urgenda.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.HIDE);
		return null;
	}

}
```
###### src\urgenda\command\Home.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * Home is the command object used for returning display screen to displaying
 * all tasks.
 *
 */
public class Home extends Command {

	private static final String MESSAGE_HOME = "Showing all tasks";

	/**
	 * Execute command of Home which return user's display screen to showing all
	 * tasks.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		data.clearShowMoreTasks();
		return MESSAGE_HOME;
	}

}
```
###### src\urgenda\command\Recurrence.java
``` java
//Unused feature due to change of additional special feature towards the end. Decided to go for nicer and 
//more rewarding feature Good Gui rather than recurring task. Hence this feature has not been fully tested, implemented
//and refactored. Left it here for the effort spent, probably deleting it in the end.

package urgenda.command;

import java.time.LocalDateTime;
import java.util.ArrayList;

import urgenda.logic.LogicData;
import urgenda.util.LogicException;
import urgenda.util.MultipleSlot;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * Recurrence command object used for performing recurring tasks in Urgenda.
 * This is an unused feature due to change in special feature. Not implemented
 * and called by other components and not comprehensively tested. Tag as unused
 * due to the effort spent ><.
 *
 */
public class Recurrence extends TaskCommand {

	private static UrgendaLogger logger = UrgendaLogger.getInstance();
	private static final String MESSAGE_NO_RECURR_MATCH = "Invalid task number. "
			+ "No matches found to set as recurring";
	private static final String MESSAGE_ERROR = "ERROR:";
	private static final String MESSAGE_INVALID = "Insufficient reccurrence info entered";
	private static final String MESSAGE_TYPE_ERROR = "ERROR: Invalid Task Type for recurrence";
	private static final String MESSAGE_RECURR = " has been set as recurring task";
	private static final String MESSAGE_RECURR_TASK = "Recurring task ";
	private static final String MESSAGE_REMOVED = " removed";
	private static final String MESSAGE_ADDED = " added";
	private static final String MESSAGE_EVENT_PASSED = "\nWarning: Event added has already passed";
	private static final String MESSAGE_DEADLINE_PASSED = "\nWarning: Deadline added has already passed";
	private static final String MESSAGE_OVERLAP = "\nWarning: Overlaps with ";
	private static final String MESSAGE_NONRECURR = " has been reverted to non-recurring";

	private MultipleSlot _recurr;
	private LogicData _data;
	private Task _newTask;
	private Task _recurrTask;
	private Integer _id;
	private Integer _minutes;
	private Integer _hours;
	private Integer _days;
	private Integer _weeks;
	private Integer _months;
	private Integer _years;
	private Integer _length;

	/**
	 * Default constructor for recurrence.
	 */
	public Recurrence() {
	}

	/**
	 * Execute command of Recurrence which sets task as recurring at specified
	 * time interval in Urgenda.
	 */
	public String execute() throws LogicException {
		_data = LogicData.getInstance();
		/*
		 * recur a task that is alr in Urgenda tasklist.
		 */
		if (_id != null && _id.intValue() > -1) {
			_recurrTask = _data.findMatchingPosition(_id.intValue());
		}
		if (_recurrTask == null) {
			_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			logger.getLogger().severe("Exception(No recur match) thrown");
			throw new LogicException(MESSAGE_NO_RECURR_MATCH);
		} else {
			/*
			 * add an entirely new task that has recurring time
			 */
			_newTask = new Task(_recurrTask);
		}
		_recurr = _newTask.getSlot();
		if (_length == null) {
			// set length of recurrence to infinite(max) if non-specified
			_length = Integer.MAX_VALUE;
		}
		recurrTimeSlot();
		if (_recurr.isEmpty() || _recurr.equals(null)) {
			throw new LogicException(MESSAGE_INVALID);
		}
		/*
		 * newTask.toggleRecurring(); attribute to be added to task to indicate
		 * task is of type recurring highlight to gui to only show start time,
		 * end time and first datetime pair in multiple slot if recurrence is to
		 * be implemented.
		 */
		_newTask.setSlot(_recurr);
		LocalDateTime now = LocalDateTime.now();
		updateId(now);
		_newTask.setDateModified(now);
		_newTask.updateTaskType();
		String feedback = checkValidity();
		return taskMessage(_newTask) + MESSAGE_RECURR + feedback;
	}

	private String checkValidity() throws LogicException {
		String feedback = "";
		try {
			checkTaskValidity(_newTask);
			_data.addTask(_newTask);
			if (_id != null) {
				/*
				 * if recurring a task that is originally in tasklisk e.g.
				 * recurr 8 every week for 3 times del the original one as added
				 * the new task w recuuring timeslot as replacement
				 */
				_data.deleteTask(_recurrTask);
			}
			setDisplayState();
			if (_id == null) {
				/*
				 * if recurring a entirely newly added task e.g. recurr cs tut
				 * by 4/4/16 5pm (first occurrence) every week check for warning
				 */
				feedback = checkPassed();
				feedback += findOverlaps();
			}
		} catch (LogicException e) {
			logger.getLogger().severe("Exception occurred" + e);
			_data.setCurrState(LogicData.DisplayState.INVALID_TASK);
			// throws exception to prevent AddTask being added to undo stack
			throw new LogicException(MESSAGE_ERROR + e.getMessage());
		}
		return feedback;
	}

	private void setDisplayState() {
		_data.setCurrState(LogicData.DisplayState.ALL_TASKS);
		_data.setTaskPointer(_newTask);
		_data.clearShowMoreTasks();
	}

	private void updateId(LocalDateTime now) {
		if (_id != null) {
			_newTask.setId(_data.getCurrentId());
			_newTask.setDateAdded(now);
			_data.updateCurrentId();
		}
	}

	private void recurrTimeSlot() throws LogicException {
		switch (_newTask.getTaskType()) {
		case DEADLINE :
			LocalDateTime start = null;
			LocalDateTime end = _newTask.getEndTime();
			end = updateDeadLineTimeSlot(start, end);
			break;
		case EVENT :
			upDateEventTimeSlot();
			break;
		default :
			throw new LogicException(MESSAGE_TYPE_ERROR);
		}
	}

	private void upDateEventTimeSlot() {
		LocalDateTime start = _newTask.getStartTime();
		LocalDateTime end = _newTask.getEndTime();
		for (int i = 0; i < (_length).intValue(); i++) {
			if (_minutes != null) {
				start = start.plusMinutes(_minutes);
				end = end.plusMinutes(_minutes);
			}
			if (_hours != null) {
				start = start.plusHours(_hours);
				end = end.plusHours(_hours);
			}
			if (_days != null) {
				start = start.plusDays(_days);
				end = end.plusDays(_days);
			}
			if (_weeks != null) {
				start = start.plusWeeks(_weeks);
				end = end.plusWeeks(_weeks);
			}
			if (_months != null) {
				start = start.plusMonths(_months);
				end = end.plusMonths(_months);
			}
			if (_months != null) {
				start = start.plusYears(_years);
				end = end.plusYears(_years);
			}
			_recurr.addTimeSlot(start, end);
		}
	}

	private LocalDateTime updateDeadLineTimeSlot(LocalDateTime start, LocalDateTime end) {
		for (int i = 0; i < (_length).intValue(); i++) {
			if (_minutes != null) {
				end = end.plusMinutes(_minutes);
			}
			if (_hours != null) {
				end = end.plusHours(_hours);
			}
			if (_days != null) {
				end = end.plusDays(_days);
			}
			if (_weeks != null) {
				end = end.plusWeeks(_weeks);
			}
			if (_months != null) {
				end = end.plusMonths(_months);
			}
			if (_months != null) {
				end = end.plusYears(_years);
			}
			_recurr.addTimeSlot(start, end);
		}
		return end;
	}

	private String checkPassed() {
		if (_newTask.getTaskType() == Task.Type.EVENT) {
			if (_newTask.getEndTime().isBefore(LocalDateTime.now())) {
				return MESSAGE_EVENT_PASSED;
			}
		} else if (_newTask.getTaskType() == Task.Type.DEADLINE) {
			if (_newTask.getEndTime().isBefore(LocalDateTime.now())) {
				return MESSAGE_DEADLINE_PASSED;
			}
		}
		return "";
	}

	private String findOverlaps() {
		ArrayList<Task> overlaps;
		overlaps = _data.overlappingTasks(_newTask);

		if (overlaps.size() == 0) {
			return "";
		} else {
			String feedback = MESSAGE_OVERLAP + taskMessage(overlaps.get(0));
			overlaps.remove(0);
			for (Task task : overlaps) {
				feedback += ", " + taskMessage(task);
			}
			return feedback;
		}
	}

	@Override
	public String undo() {
		String feedback;
		if (_id != null) {
			_data.addTask(_recurrTask);
			feedback = taskMessage(_newTask) + MESSAGE_NONRECURR;
		} else {
			feedback = MESSAGE_RECURR_TASK + taskMessage(_newTask) + MESSAGE_REMOVED;
		}
		_data.deleteTask(_newTask);
		return feedback;
	}

	@Override
	public String redo() {
		String feedback;
		if (_id != null) {
			_data.deleteTask(_recurrTask);
			feedback = taskMessage(_recurrTask) + MESSAGE_RECURR;
		} else {
			feedback = MESSAGE_RECURR_TASK + taskMessage(_newTask) + MESSAGE_ADDED;
		}
		_newTask.setDateModified(LocalDateTime.now());
		_data.addTask(_newTask);
		_data.setTaskPointer(_newTask);
		return feedback;
	}

	/**
	 * setter for adding a new recurring task.
	 * 
	 * @param newTask
	 *            The new task to be added.
	 */
	public void setNewTask(Task newTask) {
		_newTask = newTask;
	}

	/**
	 * setter for recurring a task that is alr in tasklist.
	 * 
	 * @param id
	 *            the position of the task to be set as recurring.
	 */
	public void setId(int id) {
		_id = Integer.valueOf(id);
	}

	/**
	 * setter for the number of mins to recur e.g. recurr every 2 mins.
	 * 
	 * @param input
	 *            The num of mins to recur.
	 */
	public void setMins(int input) {
		_minutes = Integer.valueOf(input);
	}

	/**
	 * setter for the number of hours to recur e.g. recurr every 12 hours.
	 * 
	 * @param input
	 *            The num of hours to recur
	 */
	public void setHours(int input) {
		_hours = Integer.valueOf(input);
	}

	/**
	 * setter for the number of days to recur e.g. recurr every 5 days.
	 * 
	 * @param input
	 *            The num of days to recur.
	 */
	public void setDays(int input) {
		_days = Integer.valueOf(input);
	}

	/**
	 * setter for the number of weeks to recur e.g. recurr every week (1).
	 * 
	 * @param input
	 *            The num of weeks to recur.
	 */
	public void setWeeks(int input) {
		_weeks = Integer.valueOf(input);
	}

	/**
	 * setter for the number of months to recur e.g. recurr every 2 months.
	 * 
	 * @param input
	 *            The num of months to recur
	 */
	public void setMonths(int input) {
		_months = Integer.valueOf(input);
	}

	/**
	 * setter for the number of years to recur e.g. recurr every year (1).
	 * 
	 * @param input
	 *            The num of years to recur.
	 */
	public void setYears(int input) {
		_years = Integer.valueOf(input);
	}

	/**
	 * setter for the number of times to recurr e.g. recurr every 5 hours for 10
	 * times.
	 * 
	 * @param length
	 *            The num of times to recurr at specified interval.
	 */
	public void setLength(int length) {
		_length = length;
	}

	public void updateDateModified(ArrayList<Task> tasks) {
		LocalDateTime now = LocalDateTime.now();
		for (Task task : tasks) {
			task.setDateModified(now);
		}
	}

}
```
###### src\urgenda\command\Search.java
``` java
package urgenda.command;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Month;
import java.util.ArrayList;

import org.apache.commons.lang3.StringUtils;

import urgenda.logic.LogicData;
import urgenda.util.Task;

/**
 * Search is the command object used for searching of tasks in Urgenda.
 *
 */
public class Search extends Command {

	private static final String MESSAGE_SHOWING = "Showing: ";
	private static final String MESSAGE_PROGRESSIVE_SEARCH = "PROGRESSIVE SEARCH: %1$s based on the current view. "
			+ "Enter home to show all tasks";
	private static final String MESSAGE_SEARCH_DESC = "all task(s) found containing \"%1$s\"";
	private static final String MESSAGE_SEARCH_TYPE = "all task(s) found of type \"%1$s\"";
	private static final String MESSAGE_SEARCH_TIME = "These are all the task(s) falling on \"%1$s\"";
	private static final String MESSAGE_SEARCH_DATETIME = "These are all the task(s) falling on \"%1$s, %2$s\"";
	private static final String MESSAGE_REFINE_SEARCH_TIME = "PROGRESSIVE SEARCH: "
			+ "Showing task(s) that falls on \"%1$s\" based on the current view. "
			+ "Enter home to show all tasks";
	private static final String MESSAGE_REFINE_SEARCH_DATETIME = "PROGRESSIVE SEARCH: "
			+ "Showing task(s) that falls on \"%1$s, %2$s\" based on the current view. "
			+ "Enter home to show all tasks";
	private static final String MESSAGE_SEARCH_NOT_FOUND = "There is no match found for \"%1$s\"";
	private static final String MESSAGE_SEARCH_INT_NOT_FOUND = "There is no match found for task no. %1$s";
	private static final String MESSAGE_SEARCH_INT = "Search Result: Showing detailed info of task no. %1$s";
	private static final String MESSAGE_NEAR_MATCH = "%1$s near match(es)";
	private static final String MESSAGE_SEARCH_NO_EXACT = "No exact match found for \"%1$s\". ";

	private String _searchDesc;
	private LocalDate _searchDate;
	private LocalDateTime _searchDateTime;
	private Month _searchMonth;
	private Integer _searchId;

	/**
	 * Default constructor for creating a new Search object.
	 */
	public Search() {

	}

	/**
	 * Alternative constructor for Search command object with the String desc
	 * for searching.
	 * 
	 * @param String
	 *            input The desc entered by user for searching.
	 */
	public Search(String input) {
		_searchDesc = input;
	}

	/**
	 * Alternative constructor for Search command object with the LocalDate date
	 * for searching.
	 * 
	 * @param LocalDate
	 *            input The date entered by user for searching.
	 */
	public Search(LocalDate input) {
		_searchDate = input;
	}

	/**
	 * Alternative constructor for Search command object with the LocalDateTime
	 * date&time for searching.
	 * 
	 * @param input
	 *            The date and time entered by user for searching.
	 */
	public Search(LocalDateTime input) {
		_searchDateTime = input;
	}

	/**
	 * Alternative constructor for Search command object with the Month month
	 * for searching.
	 * 
	 * @param input
	 *            The month entered by user for searching of tasks falling on
	 *            that month.
	 */
	public Search(Month input) {
		_searchMonth = input;
	}

	/**
	 * Alternative constructor for Search command object with the int id for
	 * searching.
	 * 
	 * @param input
	 *            The position entered by user for searching of a task (fn
	 *            similarly as showmore).
	 */
	public Search(int input) {
		_searchId = Integer.valueOf(input);
	}

	/**
	 * Execute command of Search which searches for tasks in Urgenda that
	 * matches the user specified input.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		ArrayList<Task> matches;
		String feedback = null;
		data.clearShowMoreTasks();

		if (_searchDesc != null) {
			feedback = searchForDesc(data);

		} else if (_searchDate != null) {
			matches = data.findMatchingDates(_searchDate);
			feedback = generateSearchDateFeedback(data, matches);

		} else if (_searchDateTime != null) {
			matches = data.findMatchingDateTimes(_searchDateTime);
			feedback = generateSearchDateTimeFeedback(data, matches);

		} else if (_searchMonth != null) {
			matches = data.findMatchingMonths(_searchMonth);
			feedback = generateSearchMonthFeedback(data, matches);

		} else if (_searchId != null) {
			Task task = data.findMatchingPosition(_searchId);
			feedback = generateSearchIdFeedback(data, task);
		}
		return feedback;
	}

	/*
	 * method for searching for tasks w desc and or tasktype that matches input.
	 */
	private String searchForDesc(LogicData data) {
		ArrayList<Task> matches;
		String feedback;
		// copy of _searchDesc for modification, trimming and caseignore
		// and just in case prevent editing of original _searchDesc.
		String copy = _searchDesc;
		int descCount = 0;
		int typeCount = 0;
		int nearMatchCount = 0;
		switch (copy.toLowerCase().trim()) {
		case "overdue" :
			matches = data.findMatchingDesc(_searchDesc);
			descCount = matches.size();
			typeCount = findTypeOverdue(data, matches, typeCount);
			break;
		case "completed" :
			matches = data.findMatchingDesc(_searchDesc);
			descCount = matches.size();
			typeCount = findTypeCompleted(data, matches, typeCount);
			break;
		case "important" : // Fallthrough
		case "impt": // Fallthrough
		case "prioritise" :
			matches = data.findMatchingDesc(_searchDesc);
			descCount = matches.size();
			typeCount = findTypePri(data, matches, typeCount);
			break;
		case "twotime" : // Fallthrough
		case "event" :
			matches = data.findMatchingDesc(_searchDesc);
			descCount = matches.size();
			typeCount = findTypeEvent(data, matches, typeCount);
			break;
		case "onetime" : // Fallthrough
		case "duedate" : // Fallthrough
		case "deadline" : // Fallthrough
			matches = data.findMatchingDesc(_searchDesc);
			descCount = matches.size();
			typeCount = findTypeDeadLine(data, matches, typeCount);
			break;
		case "floating" : // Fallthrough
		case "untimed" :
			matches = data.findMatchingDesc(_searchDesc);
			descCount = matches.size();
			typeCount = findTypeFloat(data, matches, typeCount);
			break;
		case "archive" :
			matches = data.getArchives();
			typeCount = matches.size();
			break;
		default :
			matches = data.findRefinedMatchingDesc(_searchDesc);
			descCount = matches.size();
			nearMatchCount = findNearMatch(data, matches, nearMatchCount);
			break;
		}
		feedback = generateSearchDescFeedback(data, matches, descCount, typeCount)
				+ getNearMatchFeedback(nearMatchCount, descCount, typeCount);
		return feedback;
	}

	private String getNearMatchFeedback(int nearMatchCount, int descCount, int typeCount) {
		if (nearMatchCount != 0) {
			if (descCount == 0 && typeCount == 0) {
				return String.format(MESSAGE_SEARCH_NO_EXACT, _searchDesc) + MESSAGE_SHOWING
						+ String.format(MESSAGE_NEAR_MATCH, nearMatchCount);
			} else {
				return " and " + String.format(MESSAGE_NEAR_MATCH, nearMatchCount);
			}
		}
		return "";
	}

	private int findNearMatch(LogicData data, ArrayList<Task> matches, int nearMatchCount) {
		for (Task task : data.getDisplays()) {
			if (StringUtils.getJaroWinklerDistance(_searchDesc, task.getDesc()) >= 0.8
					&& !matches.contains(task)) {
				matches.add(task);
				nearMatchCount++;
			}
		}
		return nearMatchCount;
	}

	private String generateSearchIdFeedback(LogicData data, Task task) {
		String feedback;
		if (task != null) {
			data.toggleShowMoreTasks(task);
			data.setTaskPointer(task);
			data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			feedback = String.format(MESSAGE_SEARCH_INT, _searchId + 1);
		} else {
			data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			feedback = String.format(MESSAGE_SEARCH_INT_NOT_FOUND, _searchId + 1);
		}
		return feedback;
	}

	private String generateSearchMonthFeedback(LogicData data, ArrayList<Task> matches) {
		String feedback;
		if (matches.isEmpty()) {
			data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			feedback = String.format(MESSAGE_SEARCH_NOT_FOUND, _searchMonth.toString());
		} else {
			data.setDisplays(matches);
			if (data.getCurrState().equals(LogicData.DisplayState.ALL_TASKS)) {
				feedback = String.format(MESSAGE_SEARCH_TIME, _searchMonth.toString());
			} else {
				feedback = String.format(MESSAGE_REFINE_SEARCH_TIME, _searchMonth.toString());
			}
			data.setCurrState(LogicData.DisplayState.SHOW_SEARCH);
		}
		return feedback;
	}

	private String generateSearchDateTimeFeedback(LogicData data, ArrayList<Task> matches) {
		String feedback;
		if (matches.isEmpty()) {
			data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			feedback = String.format(MESSAGE_SEARCH_NOT_FOUND, _searchDateTime.toLocalDate().toString() + ", "
					+ _searchDateTime.toLocalTime().toString());
		} else {
			data.setDisplays(matches);
			if (data.getCurrState().equals(LogicData.DisplayState.ALL_TASKS)) {
				feedback = String.format(MESSAGE_SEARCH_DATETIME, _searchDateTime.toLocalDate().toString(),
						_searchDateTime.toLocalTime().toString());
			} else {
				feedback = String.format(MESSAGE_REFINE_SEARCH_DATETIME,
						_searchDateTime.toLocalDate().toString(), _searchDateTime.toLocalTime().toString());
			}
			data.setCurrState(LogicData.DisplayState.SHOW_SEARCH);
		}
		return feedback;
	}

	private String generateSearchDateFeedback(LogicData data, ArrayList<Task> matches) {
		String feedback;
		if (matches.isEmpty()) {
			data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			feedback = String.format(MESSAGE_SEARCH_NOT_FOUND, _searchDate.toString());
		} else {
			data.setDisplays(matches);
			if (data.getCurrState().equals(LogicData.DisplayState.ALL_TASKS)) {
				feedback = String.format(MESSAGE_SEARCH_TIME, _searchDate.toString());
			} else {
				feedback = String.format(MESSAGE_REFINE_SEARCH_TIME, _searchDate.toString());
			}
			data.setCurrState(LogicData.DisplayState.SHOW_SEARCH);
		}
		return feedback;
	}

	private String generateSearchDescFeedback(LogicData data, ArrayList<Task> matches, int descCount,
			int typeCount) {
		String feedback;
		if (matches.isEmpty()) {
			data.setCurrState(LogicData.DisplayState.ALL_TASKS);
			feedback = String.format(MESSAGE_SEARCH_NOT_FOUND, _searchDesc);
		} else {
			data.setDisplays(matches);
			if (data.getCurrState().equals(LogicData.DisplayState.ALL_TASKS)) {
				feedback = getNormSearchFeedback(descCount, typeCount);
			} else {
				feedback = getProgressiveSearchFeedback(descCount, typeCount);
			}
			data.setCurrState(LogicData.DisplayState.SHOW_SEARCH);
		}
		return feedback;
	}

	private String getProgressiveSearchFeedback(int descCount, int typeCount) {
		String feedback;
		if (descCount != 0 && typeCount != 0) {
			String substr = String.format(MESSAGE_SEARCH_DESC, _searchDesc) + " and "
					+ String.format(MESSAGE_SEARCH_TYPE, _searchDesc);
			feedback = String.format(MESSAGE_PROGRESSIVE_SEARCH, substr);
		} else if (descCount == 0) {
			feedback = String.format(MESSAGE_PROGRESSIVE_SEARCH,
					String.format(MESSAGE_SEARCH_TYPE, _searchDesc));
		} else {
			feedback = String.format(MESSAGE_PROGRESSIVE_SEARCH,
					String.format(MESSAGE_SEARCH_DESC, _searchDesc));
		}
		return feedback;
	}

	private String getNormSearchFeedback(int descCount, int typeCount) {
		String feedback;
		if (descCount != 0 && typeCount != 0) {
			feedback = MESSAGE_SHOWING + String.format(MESSAGE_SEARCH_DESC, _searchDesc) + " and "
					+ String.format(MESSAGE_SEARCH_TYPE, _searchDesc);
		} else if (descCount == 0 && typeCount != 0) {
			feedback = MESSAGE_SHOWING + String.format(MESSAGE_SEARCH_TYPE, _searchDesc);
		} else if (descCount != 0 && typeCount == 0) {
			feedback = MESSAGE_SHOWING + String.format(MESSAGE_SEARCH_DESC, _searchDesc);
		} else {
			feedback = "";
		}
		return feedback;
	}

	/*
	 * find tasks that are of type floating
	 */
	private int findTypeFloat(LogicData data, ArrayList<Task> matches, int typeCount) {
		for (Task task : data.getDisplays()) {
			if (task.getTaskType().equals(Task.Type.FLOATING)) {
				typeCount++;
			}
			if (task.getTaskType().equals(Task.Type.FLOATING) && !matches.contains(task)) {
				matches.add(task);
			}
		}
		return typeCount;
	}

	/*
	 * find tasks that are of type deadline
	 */
	private int findTypeDeadLine(LogicData data, ArrayList<Task> matches, int typeCount) {
		for (Task task : data.getDisplays()) {
			if (task.getTaskType().equals(Task.Type.DEADLINE)) {
				typeCount++;
			}
			if (task.getTaskType().equals(Task.Type.DEADLINE) && !matches.contains(task)) {
				matches.add(task);
			}
		}
		return typeCount;
	}

	/*
	 * find tasks that are of type event
	 */
	private int findTypeEvent(LogicData data, ArrayList<Task> matches, int typeCount) {
		for (Task task : data.getDisplays()) {
			if (task.getTaskType().equals(Task.Type.EVENT)) {
				typeCount++;
			}
			if (task.getTaskType().equals(Task.Type.EVENT) && !matches.contains(task)) {
				matches.add(task);
			}
		}
		return typeCount;
	}

	/*
	 * find tasks that are marked as important
	 */
	private int findTypePri(LogicData data, ArrayList<Task> matches, int typeCount) {
		for (Task task : data.getDisplays()) {
			if (task.isImportant()) {
				typeCount++; // maintain count of all pri tasks
			}
			// prevent adding duplicate copies which falls under multi category
			// eg. desc impt and isImpt
			if (task.isImportant() && !matches.contains(task)) {
				matches.add(task);
			}
		}
		return typeCount;
	}

	/*
	 * find tasks that are marked as done
	 */
	private int findTypeCompleted(LogicData data, ArrayList<Task> matches, int typeCount) {
		for (Task task : data.getTaskList()) {
			if (task.isCompleted()) {
				typeCount++; // maintain count of all completed tasks
			}
			// prevent adding duplicate copies which falls under multi category
			if (task.isCompleted() && !matches.contains(task)) {
				matches.add(task);
			}
		}
		for (Task task : data.getArchives()) {
			if (task.isCompleted() && !matches.contains(task)) {
				typeCount++;
				matches.add(task);
			}
		}
		return typeCount;
	}

	/*
	 * find tasks that are overdue
	 */
	private int findTypeOverdue(LogicData data, ArrayList<Task> matches, int typeCount) {
		for (Task task : data.getDisplays()) {
			if (task.isOverdue()) {
				// get num of overdue tasks (including those which are both
				// overdue & has desc overdue)
				typeCount++;
			}
			// prevent adding of duplicate copies
			if (task.isOverdue() && !matches.contains(task)) {
				matches.add(task);
			}
		}
		return typeCount;
	}

	/**
	 * Setter for search by desc.
	 * 
	 * @param input
	 *            The string desc used for searching.
	 */
	public void setSearchInput(String input) {
		_searchDesc = input;
	}

	/**
	 * Setter for search by date
	 * 
	 * @param input
	 *            The LocalDate date used for searching.
	 */
	public void setSearchDate(LocalDate input) {
		_searchDate = input;
	}

	/**
	 * Setter for search by datetime
	 * 
	 * @param input
	 *            The LocalDateTime dateandtime used for searching.
	 */
	public void setSearchDateTime(LocalDateTime input) {
		_searchDateTime = input;
	}

	/**
	 * Setter for search by month
	 * 
	 * @param input
	 *            The Month month used for searching.
	 */
	public void setSearchMonth(Month input) {
		_searchMonth = input;
	}

	/**
	 * Setter for search by id
	 * 
	 * @param id
	 *            The int position of task used for searching.
	 */
	public void setSearchId(int id) {
		_searchId = Integer.valueOf(id);
	}

}
```
###### src\urgenda\command\ShowArchive.java
``` java
package urgenda.command;

import urgenda.logic.LogicData;

/**
 * ShowArchive is the command object used for displaying archive (list of completed tasks)
 * to the user.
 *
 */
public class ShowArchive extends Command {
	
	private static final String MESSAGE_SHOWING_ARCHIVE = "Showing all archived tasks";

	/**
	 * Execute command of ShowArchive which sets user's display screen to showing archived tasks.
	 */
	public String execute() {
		LogicData data = LogicData.getInstance();
		data.setCurrState(LogicData.DisplayState.ARCHIVE);
		data.clearShowMoreTasks();
		return MESSAGE_SHOWING_ARCHIVE;
	}

}
```
###### src\urgenda\logic\LogicData.java
``` java
package urgenda.logic;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Month;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.regex.Pattern;

import urgenda.storage.Storage;
import urgenda.storage.StorageTester;
import urgenda.util.DateTimePair;
import urgenda.util.InvalidFolderException;
import urgenda.util.MultipleSlot;
import urgenda.util.StateFeedback;
import urgenda.util.StorageException;
import urgenda.util.Task;
import urgenda.util.UrgendaLogger;

/**
 * LogicData class of the Logic component in Urgenda. Responsible for the
 * handling of the different tasks of the user. Main class where all the
 * manipulation of the task objects are carried out. Also responsible for
 * storing of all the tasks.
 *
 */
public class LogicData {

	/**
	 * Different DisplayState for LogicData which represents the state of
	 * display given to the user
	 *
	 */
	public enum DisplayState {
		ALL_TASKS, MULTIPLE_DELETE, MULTIPLE_COMPLETE, MULTIPLE_PRIORITISE, SHOW_SEARCH, EXIT, INVALID_COMMAND, HELP, INVALID_TASK, ARCHIVE, FIND_FREE, DEMO, HIDE
	}

	private static UrgendaLogger logger = UrgendaLogger.getInstance();
	private static LogicData _logicData;

	// storage object for retrieval and storing of tasks to data format
	private Storage _storage;

	// for storage of full lists of tasks
	private ArrayList<Task> _tasks;
	// for storage of all completed tasks
	private ArrayList<Task> _archives;
	// for storage of tasks being displayed to user by last command
	private ArrayList<Task> _displays;
	// for storage of tasks to have more details to be displayed
	private ArrayList<Task> _showMoreTasks;

	private Task _taskPointer;
	private DisplayState _currState;
	private int _currentId;

	/*
	 * Default constructor where singleton pattern is applied. To initialise the
	 * variables within LogicData.
	 */
	private LogicData() {
		logger.getLogger().info("constructing LogicData Object");
		_storage = new Storage();
		_tasks = _storage.updateCurrentTaskList();
		_archives = _storage.updateArchiveTaskList();
		_currState = DisplayState.ALL_TASKS;
		_displays = new ArrayList<Task>();
		_showMoreTasks = new ArrayList<Task>();
		// sets the next id to be used for future labelling of tasks
		_currentId = _tasks.size() + 1;
	}

	/*
	 * Alternative constructor where singleton pattern is applied. To initialise
	 * the variables within LogicData when doing testing.
	 */
	private LogicData(boolean isTest) {
		// stubs storage with storagetester
		_storage = new StorageTester();
		_tasks = _storage.updateCurrentTaskList();
		_archives = _storage.updateArchiveTaskList();
		_currState = DisplayState.ALL_TASKS;
		_displays = new ArrayList<Task>();
		_showMoreTasks = new ArrayList<Task>();
		_currentId = _tasks.size() + 1;
	}

	/**
	 * Singleton pattern method for instantiation of LogicData to avoid multiple
	 * copies of tasks for the user
	 * 
	 * @return LogicData object that is used currently or created
	 */
	public static LogicData getInstance() {
		if (_logicData == null) {
			logger.getLogger().info("creating instance of logicData");
			_logicData = new LogicData();
		}
		logger.getLogger().info("retrieving prev instance of logicData");
		return _logicData;
	}

	/**
	 * Alternate constructor for singleton pattern for stubbing of storage when
	 * testing
	 * 
	 * @param isTest
	 *            boolean of checking if the current mode is in testing
	 * @return LogicData object that is used currently or created
	 */
	public static LogicData getInstance(boolean isTest) {
		if (_logicData == null) {
			_logicData = new LogicData(isTest);
		}
		return _logicData;
	}

	/**
	 * Method used for saving all current contents into the data file for usage
	 * in the future.
	 */
	public void saveContents() {
		logger.getLogger().info("Saving contents to storage");
		_storage.save(_tasks, _archives);
	}

	/**
	 * Method to retrieve the current state of LogicData into a StateFeedback
	 * object for packaging all required information. Different sets of lists
	 * are used for different states that it is currently in.
	 * 
	 * @return StateFeedback object that holds all the required information
	 */
	public StateFeedback getState() {
		StateFeedback state;
		switch (_currState) {
		case ALL_TASKS :
			state = displayAllTasks(_tasks);
			state.setState(StateFeedback.State.ALL_TASKS);
			break;
		case MULTIPLE_DELETE : // Fallthrough
		case MULTIPLE_COMPLETE : // Fallthrough
		case MULTIPLE_PRIORITISE :
			state = displayAllTasks(_displays);
			state.setState(StateFeedback.State.MULTIPLE_MATCHES);
			break;
		case SHOW_SEARCH :
			state = displayAllTasks(_displays);
			state.setState(StateFeedback.State.SHOW_SEARCH);
			break;
		case HELP :
			state = displayAllTasks(_displays);
			state.setState(StateFeedback.State.SHOW_HELP);
			break;
		case EXIT :
			saveContents();
			state = displayAllTasks(_tasks);
			state.setState(StateFeedback.State.EXIT);
			break;
		case INVALID_COMMAND : // Fallthrough
		case INVALID_TASK :
			state = displayAllTasks(_tasks);
			state.setState(StateFeedback.State.ERROR);
			break;
		case ARCHIVE :
			state = displayArchiveTasks(_archives);
			state.setState(StateFeedback.State.ARCHIVE);
			break;
		case FIND_FREE :
			state = displayAllTasks(_displays);
			state.setState(StateFeedback.State.FIND_FREE);
			break;
		case DEMO :
			state = displayAllTasks(_displays);
			state.setState(StateFeedback.State.DEMO);
			break;
		case HIDE :
			state = displayAllTasks(_displays);
			state.setState(StateFeedback.State.HIDE);
			break;
		default :
			state = displayAllTasks(_tasks);
			state.setState(StateFeedback.State.ALL_TASKS);
			break;
		}
		return state;
	}

	/**
	 * Method for setting the display list to show archive tasks
	 * 
	 * @param displayList
	 *            Archive list for putting as display
	 * @return StateFeedback object containing the list given
	 */
	public StateFeedback displayArchiveTasks(ArrayList<Task> displayList) {
		clearDisplays();
		_displays.addAll(sortArchive(displayList));
		StateFeedback state = new StateFeedback(_displays, _displays.size());
		setOverdueCount(state);
		setFeedbackDisplayPosition(state);
		setShowMorePositions(state);
		return state;
	}

	/**
	 * Method for setting the display list to show the current list given. Sorts
	 * the list according to Overdue, Today, Others.
	 * 
	 * @param displayList
	 *            Display List given for putting as display
	 * @return StateFeedback object containing the list given
	 */
	public StateFeedback displayAllTasks(ArrayList<Task> displayList) {
		ArrayList<Task> overdueTasks = new ArrayList<Task>();
		ArrayList<Task> todayTasks = new ArrayList<Task>();
		ArrayList<Task> otherTasks = new ArrayList<Task>();
		sortTasksIntoList(displayList, overdueTasks, todayTasks, otherTasks);
		clearDisplays();
		_displays.addAll(sortList(overdueTasks));
		_displays.addAll(sortList(todayTasks));
		_displays.addAll(sortList(otherTasks));

		logger.getLogger().info("asserting arraysize >= 0");
		assert (overdueTasks.size() >= 0);
		assert (todayTasks.size() >= 0);
		assert (otherTasks.size() >= 0);

		StateFeedback state = new StateFeedback(_displays, overdueTasks.size(), todayTasks.size(),
				otherTasks.size());
		setOverdueCount(state);
		setFeedbackDisplayPosition(state);
		setShowMorePositions(state);
		return state;
	}

	private void sortTasksIntoList(ArrayList<Task> displayList, ArrayList<Task> overdueTasks,
			ArrayList<Task> todayTasks, ArrayList<Task> otherTasks) {
		for (Task task : displayList) {
			if (task.isOverdue()) {
				overdueTasks.add(task);
			} else if (isTaskToday(task)) {
				todayTasks.add(task);
			} else { // remaining tasks and floating tasks
				otherTasks.add(task);
			}
		}
	}

	private void setOverdueCount(StateFeedback state) {
		int count = 0;
		for (Task task : _tasks) {
			if (task.isOverdue()) {
				count++;
			}
		}
		assert (count >= 0);
		state.setOverdueCount(count);
	}

	private void setShowMorePositions(StateFeedback state) {
		for (Task task : _showMoreTasks) {
			if (_displays.contains(task)) {
				state.addDetailedTaskIdx(_displays.indexOf(task));
			}
		}
	}

	/*
	 * sets the position if the pointer matches the display
	 */
	private void setFeedbackDisplayPosition(StateFeedback state) {
		if (_taskPointer != null && _displays.contains(_taskPointer)) {
			state.setDisplayPosition(_displays.indexOf(_taskPointer));
		} else {
			// sets to 0 (default) if no specific task to pointed at
			state.setDisplayPosition(0);
		}
		// clears task pointer for next iteration
		_taskPointer = null;
	}

	/**
	 * Method for checking whether the task falls on today (calendar time).
	 * 
	 * @param task
	 *            task given for checking if falls on today.
	 * @return boolean true or false
	 */
	public boolean isTaskToday(Task task) {
		LocalDate now = LocalDate.now();
		if (task.getTaskType() == Task.Type.DEADLINE) {
			return verifyEndTime(task, now);
		} else if (task.getTaskType() == Task.Type.EVENT) {
			// check whether any of the time within the time span of the event
			// falls on today
			return verifyTimeSpan(task, now);
		} else { // Type is floating
			return false;
		}
	}

	/*
	 * method for checking whether an event falls on today (including
	 * consideration of tasks that spans multiple days
	 */
	private boolean verifyTimeSpan(Task task, LocalDate now) {
		if (task.getStartTime().toLocalDate().isEqual(now) || task.getEndTime().toLocalDate().isEqual(now)
				|| task.getStartTime().toLocalDate().isBefore(now)
						&& task.getEndTime().toLocalDate().isAfter(now)) {
			return true;
		} else {
			return false;
		}
	}

	/*
	 * method for checking whether a deadline task falls on today
	 */
	private boolean verifyEndTime(Task task, LocalDate now) {
		if (task.getEndTime().toLocalDate().isEqual(now)) {
			return true;
		} else {
			return false;
		}
	}

	/**
	 * Method for updating the state of the system e.g. called after every
	 * execution of command so that GUI knows the state for display.
	 */
	public void updateState() {
		logger.getLogger().info("Updating state of prog");
		ArrayList<Task> completedTasks = new ArrayList<Task>();
		LocalDateTime now = LocalDateTime.now();
		for (Task task : _tasks) {
			checkDeadline(now, task);
			checkMultipleSlot(task);
			checkEvents(completedTasks, now, task);
		}
		_tasks.removeAll(completedTasks);
		_archives.addAll(completedTasks);
		assert (_archives.size() >= 0);
	}

	private void checkEvents(ArrayList<Task> completedTasks, LocalDateTime now, Task task) {
		if (task.getTaskType() == Task.Type.EVENT) {
			if (task.getEndTime().isBefore(now)) {
				task.setIsCompleted(true);
				task.setDateModified(LocalDateTime.now());
				logger.getLogger().info("event task" + task + " has been completed");
				// only moves completed tasks when the day ends for that day
				if (task.getEndTime().toLocalDate().isBefore(LocalDate.now())) {
					completedTasks.add(task);
					task.setDateModified(LocalDateTime.now());
				}
			}
		}
	}

	private void checkMultipleSlot(Task task) {
		if (task.getSlot() != null) {
			updateMultipleSlot(task);
		}
	}

	private void checkDeadline(LocalDateTime now, Task task) {
		if (task.getTaskType() == Task.Type.DEADLINE) {
			if (task.getEndTime().isBefore(now)) {
				task.setIsOverdue(true);
				task.setDateModified(LocalDateTime.now());
				logger.getLogger().info("deadline task " + task + " has turned overdue");
			} else {
				task.setIsOverdue(false);
			}
		}
	}

	/**
	 * Method for updating the Multipleslot attribute (for blocking of several
	 * timings for same task) of a given task.
	 * 
	 * @param task
	 *            The task specified for updating of multipleslot.
	 */
	public void updateMultipleSlot(Task task) {
		LocalDateTime now = LocalDateTime.now();
		if (task.getStartTime() == null || task.getEndTime() == null) {
			return;
		}
		task.getSlot().addTimeSlot(task.getStartTime(), task.getEndTime());
		task.getSlot().sortSlots();
		updateTimeSlots(task, now);
		checkEmptySlot(task);
	}

	private void checkEmptySlot(Task task) {
		if (task.getSlot().isEmpty()) {
			task.setSlot(null);
		}
	}

	private void updateTimeSlots(Task task, LocalDateTime now) {
		do {
			DateTimePair newTime = task.getSlot().getNextSlot();
			task.setStartTime(newTime.getEarlierDateTime());
			task.setEndTime(newTime.getLaterDateTime());
			task.getSlot().removeNextSlot();
		} while (task.getEndTime().isBefore(now) && !(task.getSlot().isEmpty()));
	}

	/**
	 * Method for finding tasks w desc that matches input (in same order)
	 * regardless of case. e.g. for input of abc, Abc and ABCDDD will all be
	 * returned.
	 * 
	 * @param desc
	 *            The description given by user to find matches.
	 * @return ArrayList containing all matching tasks.
	 */
	public ArrayList<Task> findMatchingDesc(String desc) {
		ArrayList<Task> matches = new ArrayList<Task>();
		if (!desc.equals("")) {
			searchForMatchingDescInDisplayList(desc, matches);
		}
		logger.getLogger().info("Find matching desc: " + desc);
		return matches;
	}

	private void searchForMatchingDescInDisplayList(String desc, ArrayList<Task> matches) {
		for (Task task : _displays) {
			if (Pattern.compile(Pattern.quote(desc), Pattern.CASE_INSENSITIVE).matcher(task.getDesc())
					.find()) {
				matches.add(task);
			}
		}
	}

	/**
	 * Method for finding tasks w desc that matches input (more than one word)
	 * (words dont need be in same order) regardless of case. e.g. for input of
	 * Sweden Holiday, Holiday to Swenden and Sweden Public Holiday will both be
	 * returned.
	 * 
	 * @param desc
	 *            The desc given by user for finding matches within current task
	 *            list.
	 * @return ArrayList containing all the tasks with matching desc.
	 */
	public ArrayList<Task> findRefinedMatchingDesc(String desc) {
		ArrayList<Task> matches = new ArrayList<Task>();
		if (!desc.equals("")) {
			String[] substr = desc.split("\\s+");
			ArrayList<String> substr2 = new ArrayList<String>(Arrays.asList(substr));
			if (substr2.size() > 1) {
				searchForNonOrderedDesc(matches, substr2);
			} else {
				searchForMatchingDescInDisplayList(desc, matches);
			}
		}
		return matches;
	}

	private void searchForNonOrderedDesc(ArrayList<Task> matches, ArrayList<String> substr2) {
		logger.getLogger().info("searching for non-ordered desc (input more than one word");
		for (Task task : _displays) {
			boolean flag = true;
			for (String s : substr2) {
				if (!(Pattern.compile(Pattern.quote(s + " "), Pattern.CASE_INSENSITIVE)
						.matcher(task.getDesc()).find())
						&& !(Pattern.compile(Pattern.quote(" " + s), Pattern.CASE_INSENSITIVE)
								.matcher(task.getDesc()).find())
						&& flag) {
					flag = false;
				}
			}
			if (flag) {
				matches.add(task);
			}
		}
	}

	/**
	 * Method for adding a completed task to archive.
	 * 
	 * @param task
	 *            The task to be moved to archive
	 */
	public void addArchive(Task task) {
		logger.getLogger().info("adding task " + task + " to archive");
		_archives.add(task);
	}

	/**
	 * Method for adding multiple completed tasks to archive at once.
	 * 
	 * @param tasks
	 *            The ArrayList of tasks to be moved to archive
	 */
	public void addArchive(ArrayList<Task> tasks) {
		logger.getLogger().info("adding task multiple tasks to archive");
		_archives.addAll(tasks);
	}

	/**
	 * Method for removing a task from archive.
	 * 
	 * @param tasks
	 *            The task to be removed from archive.
	 */
	public void removeArchive(Task task) {
		_archives.remove(task);
	}

	/**
	 * Method for removing multiple tasks from archive at once.
	 * 
	 * @param tasks
	 *            The ArrayList of tasks to be removed from archive.
	 */
	public void removeArchive(ArrayList<Task> tasks) {
		_archives.removeAll(tasks);
	}

	/**
	 * Getter for getting the private attribute _tasks in logicData.
	 * 
	 * @return _task, the list containing all current tasks.
	 */
	public ArrayList<Task> getTaskList() {
		return _tasks;
	}

	/**
	 * Getter for getting the latest id assigned to a new task.
	 * 
	 * @return _currentId, the current id of the system.
	 */
	public int getCurrentId() {
		return _currentId;
	}

	/**
	 * Method for updating the id of task list to the most recent number in
	 * logicData.
	 */
	public void updateCurrentId() {
		_currentId++;
	}

	/**
	 * Method for adding a new Task into the taskList in LogicData.
	 * 
	 * @param newTask
	 *            The new task given to be added to current task list.
	 */
	public void addTask(Task newTask) {
		_tasks.add(newTask);
	}

	/**
	 * Method for adding multiple new Tasks into the taskList in LogicData.
	 * 
	 * @param tasks
	 *            The ArrayList of new tasks to be added to current task list.
	 */
	public void addTasks(ArrayList<Task> tasks) {
		_tasks.addAll(tasks);
	}

	/**
	 * Method for removing a task from the taskList and archive in LogicData.
	 * 
	 * @param task
	 *            The task specified for the removal from Urgenda.
	 */
	public void deleteTask(Task task) {
		_tasks.remove(task);
		_archives.remove(task);
	}

	/**
	 * Method for removing a task from the taskList in LogicData.
	 * 
	 * @param tasks
	 *            The ArrayList of tasks specified for the removal from Urgenda.
	 */
	public void deleteTasks(ArrayList<Task> tasks) {
		_tasks.removeAll(tasks);
		_archives.removeAll(tasks);
	}

	/**
	 * Method for retrieving a task based on specified id (position in task list
	 * _tasks).
	 * 
	 * @param id
	 *            The id (position) specified for locating of a task.
	 * @return the task which corresponds to the position in _tasks(id) or null
	 *         if couldn't find a valid match.
	 */
	public Task findMatchingPosition(int id) {
		logger.getLogger().info("Find matching position, " + id);
		if (id >= 0 && id < _displays.size()) {
			logger.getLogger().info("Matching position found: " + id);
			return _displays.get(id);
		} else {
			logger.getLogger().info("Matching position not found");
			return null;
		}
	}

	/**
	 * Overloaded method for finding matching positions w arraylists of id given
	 * as input.
	 * 
	 * @param idPositions
	 *            The ArrayList of id (positions) specified for retrieving and
	 *            locating of multiple tasks.
	 * @return ArrayList of task which corresponds to the idpositions, none
	 *         valid id will just be ignored.
	 */
	public ArrayList<Task> findMatchingPosition(ArrayList<Integer> idPositions) {
		ArrayList<Task> matches = new ArrayList<Task>();
		for (Integer i : idPositions) {
			if (i != null && i >= 0 && i < _displays.size()) {
				matches.add(_displays.get(i));
				logger.getLogger().info("Found matching position, " + i);
			}
		}
		if (matches.isEmpty()) {
			return null;
		} else {
			return matches;
		}
	}

	/**
	 * Method for retrieving tasks that matches date as specified by input.
	 * 
	 * @param input
	 *            The date specified for searching of tasks falling on it.
	 * @return Arraylist of tasks that matches input date.
	 */
	public ArrayList<Task> findMatchingDates(LocalDate input) {
		logger.getLogger().info("Find matching dates, " + input);
		ArrayList<Task> matches = new ArrayList<Task>();
		for (Task task : _displays) {
			if (task.getTaskType() == Task.Type.DEADLINE) {
				getDeadLineWithMatchingDate(input, matches, task);
			} else if (task.getTaskType() == Task.Type.EVENT) {
				getEventWithMatchingDate(input, matches, task);
			}
		}
		return matches;
	}

	private void getEventWithMatchingDate(LocalDate input, ArrayList<Task> matches, Task task) {
		if (task.getStartTime().toLocalDate().isEqual(input)
				|| task.getEndTime().toLocalDate().isEqual(input)) {
			matches.add(task);
		} else if (task.getStartTime().toLocalDate().isBefore(input)
				&& task.getEndTime().toLocalDate().isAfter(input)) {
			matches.add(task);
		} else if (task.getSlot() != null && !task.getSlot().isEmpty()) {
			checkForMatchingDateWithinSlots(input, matches, task);
		}
	}

	private void checkForMatchingDateWithinSlots(LocalDate input, ArrayList<Task> matches, Task task) {
		ArrayList<DateTimePair> slots = task.getSlot().getSlots();
		for (DateTimePair pair : slots) {
			if (pair.getEarlierDateTime().toLocalDate().isEqual(input)
					|| pair.getLaterDateTime().toLocalDate().isEqual(input)) {
				matches.add(task);
			} else if (pair.getEarlierDateTime().toLocalDate().isBefore(input)
					&& pair.getLaterDateTime().toLocalDate().isAfter(input)) {
				matches.add(task);
			}
		}
	}

	private void getDeadLineWithMatchingDate(LocalDate input, ArrayList<Task> matches, Task task) {
		if (task.getEndTime().toLocalDate().isEqual(input)) {
			matches.add(task);
		}
	}

	/**
	 * Method for retrieving tasks that matches both date and time as specified
	 * by input.
	 * 
	 * @param input
	 *            The DateTime specified for searching of tasks falling it.
	 * @return Arraylist of tasks that matches input datetime.
	 */
	public ArrayList<Task> findMatchingDateTimes(LocalDateTime input) {
		logger.getLogger().info("Find matching datetime, " + input);
		ArrayList<Task> matches = new ArrayList<Task>();
		for (Task task : _displays) {
			if (task.getTaskType() == Task.Type.DEADLINE) {
				getDeadLineWithMatchingDateTime(input, matches, task);
			} else if (task.getTaskType() == Task.Type.EVENT) {
				getEventWithMatchingDateTime(input, matches, task);
			}
		}
		return matches;
	}

	private void getEventWithMatchingDateTime(LocalDateTime input, ArrayList<Task> matches, Task task) {
		if (task.getStartTime().isEqual(input) || task.getEndTime().isEqual(input)) {
			matches.add(task);
		} else if (task.getStartTime().isBefore(input) && task.getEndTime().isAfter(input)) {
			matches.add(task);
		} else if (task.getSlot() != null && !task.getSlot().isEmpty()) {
			getMatchingDateTimeWithinSlots(input, matches, task);
		}
	}

	private void getMatchingDateTimeWithinSlots(LocalDateTime input, ArrayList<Task> matches, Task task) {
		ArrayList<DateTimePair> slots = task.getSlot().getSlots();
		for (DateTimePair pair : slots) {
			if (pair.getEarlierDateTime().isEqual(input) || pair.getLaterDateTime().isEqual(input)) {
				matches.add(task);
			} else if (pair.getEarlierDateTime().isBefore(input) && pair.getLaterDateTime().isAfter(input)) {
				matches.add(task);
			}
		}
	}

	private void getDeadLineWithMatchingDateTime(LocalDateTime input, ArrayList<Task> matches, Task task) {
		if (task.getEndTime().isEqual(input)) {
			matches.add(task);
		}
	}

	/**
	 * Method for retrieving tasks that falls on the month specified by input.
	 * 
	 * @param input
	 *            The Month specified for searching of tasks falling on it.
	 * @return Arraylist of tasks that matches input month.
	 */
	public ArrayList<Task> findMatchingMonths(Month input) {
		logger.getLogger().info("Find matching months, " + input);
		ArrayList<Task> matches = new ArrayList<Task>();
		for (Task task : _displays) {
			if (task.getTaskType() == Task.Type.DEADLINE) {
				getDeadLineWithMatchingMonth(input, matches, task);
			} else if (task.getTaskType() == Task.Type.EVENT) {
				getEventWithMatchingMonth(input, matches, task);
			}
		}
		return matches;
	}

	private void getEventWithMatchingMonth(Month input, ArrayList<Task> matches, Task task) {
		if (task.getStartTime().getMonth() == input || task.getEndTime().getMonth() == input) {
			matches.add(task);
		} else if (task.getStartTime().getMonth() == input && task.getEndTime().getMonth() == input) {
			matches.add(task);
		} else if (task.getSlot() != null && !task.getSlot().isEmpty()) {
			getMatchingMonthWithinSlots(input, matches, task);
		}
	}

	private void getMatchingMonthWithinSlots(Month input, ArrayList<Task> matches, Task task) {
		ArrayList<DateTimePair> slots = task.getSlot().getSlots();
		for (DateTimePair pair : slots) {
			if (pair.getEarlierDateTime().getMonth() == input
					|| pair.getLaterDateTime().getMonth() == input) {
				matches.add(task);
			} else if (pair.getEarlierDateTime().getMonth() == input
					&& pair.getLaterDateTime().getMonth() == input) {
				matches.add(task);
			}
		}
	}

	private void getDeadLineWithMatchingMonth(Month input, ArrayList<Task> matches, Task task) {
		if (task.getEndTime().getMonth() == input) {
			matches.add(task);
		}
	}

	/**
	 * Method for finding task that has the same multipleslot as given input.
	 * 
	 * @param block
	 *            The MultipleSlot variable for searching of tasks that matches
	 *            this block.
	 * @return ArrayList of task that matches block.
	 */
	public ArrayList<Task> findBlocks(MultipleSlot block) {
		ArrayList<Task> _blocks = new ArrayList<Task>();
		for (Task task : _tasks) {
			if (task.getSlot() != null) {
				if (task.getSlot().equals(block)) {
					_blocks.add(task);
				}
			}
		}
		return _blocks;
	}

	/**
	 * Method for sorting of list of task according to datetime and priority and
	 * alpha order for tasks w/o datetime (floating).
	 * 
	 * @param list
	 *            The ArrayList of tasks to be sorted.
	 * @return sorted list.
	 */
	public ArrayList<Task> sortList(ArrayList<Task> list) {
		Collections.sort(list, comparator);
		Collections.sort(list, imptComparator);
		return list;
	}

	/*
	 * comparator for comparison of timing
	 */
	static Comparator<Task> comparator = new Comparator<Task>() {
		public int compare(final Task o1, final Task o2) {
			LocalDateTime c1, c2;
			if (o1.getStartTime() != null) {
				c1 = o1.getStartTime();
			} else {
				c1 = o1.getEndTime();
			}
			if (o2.getStartTime() != null) {
				c2 = o2.getStartTime();
			} else {
				c2 = o2.getEndTime();
			}
			if (c1 == null && c2 == null) {
				return o1.getDesc().compareToIgnoreCase(o2.getDesc());
			} else if (c1 == null) {
				return 1;
			} else if (c2 == null) {
				return -1;
			} else {
				if (c1.compareTo(c2) == 0) {
					return o1.getDesc().compareToIgnoreCase(o2.getDesc());
				}
				return c1.compareTo(c2);
			}
		}
	};

	/*
	 * comparator for comparing of priority status
	 */
	static Comparator<Task> imptComparator = new Comparator<Task>() {
		public int compare(final Task o1, final Task o2) {
			int compare = 0;
			if (o1.isImportant() && o2.isImportant()) {
				compare = 0;
			} else if (o1.isImportant()) {
				compare = -1;
			} else if (o2.isImportant()) {
				compare = 1;
			}
			return compare;
		}
	};

	/**
	 * Method for sorting list of tasks in archive according to date modified.
	 * 
	 * @param list
	 *            The ArrayList of archive tasks to be sorted.
	 * @return sorted list
	 */
	public ArrayList<Task> sortArchive(ArrayList<Task> list) {
		Collections.sort(list, archiveComparator);
		return list;
	}

	/*
	 * new comparator for sorting of archive, compares datemodified.
	 */
	static Comparator<Task> archiveComparator = new Comparator<Task>() {
		public int compare(final Task o1, final Task o2) {
			return o2.getDateModified().compareTo(o1.getDateModified());
		}
	};

	/**
	 * Getter for retrieving display list (all tasks currently displayed to
	 * user), the private attribute in LogicData.
	 * 
	 * @return _displays, the private attribute in logicData.
	 */
	public ArrayList<Task> getDisplays() {
		return _displays;
	}

	/**
	 * Getter for retrieving archive list (all tasks currently displayed to
	 * user), the private attribute in LogicData.
	 * 
	 * @return _archives, the private attribute in logicData.
	 */
	public ArrayList<Task> getArchives() {
		return _archives;
	}

	/**
	 * Setter for setting the attribute _display in logicData as the specified
	 * ArrayList<Task> input.
	 * 
	 * @param displays
	 *            The ArrayList to be set as display.
	 */
	public void setDisplays(ArrayList<Task> displays) {
		_displays = displays;
	}

	/**
	 * Getter for getting the currState of the program e.g. the state shown by
	 * ui.
	 * 
	 * @return _currState, a DisplayState private attribute in LogicData
	 */
	public DisplayState getCurrState() {
		return _currState;
	}

	/**
	 * Setter for setting currState of program to a specified Display State
	 * given by input e.g. indicating to UI the state of the system after a
	 * command is executed.
	 * 
	 * @param currState
	 *            The DisplayState to be set as current state of the system.
	 */
	public void setCurrState(DisplayState currState) {
		_currState = currState;
	}

	/**
	 * Method for clearing display list.
	 */
	public void clearDisplays() {
		_displays.clear();
	}

	/**
	 * Method for testing purposes only. Use in FreeTimeTest.java for clearing
	 * of entire tasklist.
	 */
	public void clearTasks() {
		_tasks.clear();
	}

	/**
	 * Method for retrieving userguide (help for user).
	 * 
	 * @return _storage.retrieveHelp, the help file stored in storage.
	 */
	public ArrayList<String> generateHelpManual() {
		return _storage.getHelp();
	}

	/**
	 * Getter for getting the selector position of the program e.g. the task
	 * that is currently pointing at.
	 * 
	 * @return _taskPointer, the private attribute in logicData which is the
	 *         selector of Urgenda.
	 */
	public Task getTaskPointer() {
		return _taskPointer;
	}

	/**
	 * Setter for setting the position of the selector, e.g. which task to point
	 * to by UI.
	 * 
	 * @param taskPointer
	 *            The Task for setting the pointer to be pointing at.
	 */
	public void setTaskPointer(Task taskPointer) {
		_taskPointer = taskPointer;
	}

	/**
	 * Method for getting the showmore status of a given task.
	 * 
	 * @param task
	 *            The task specified for checking of showmore status.
	 * @return true if status isShowingMore, false otherwise.
	 */
	public boolean isShowingMore(Task task) {
		return _showMoreTasks.contains(task);
	}

	/**
	 * Method to toggle showmore status of a specified task.
	 * 
	 * @param task
	 *            The task specified for toggling of showmore status.
	 */
	public void toggleShowMoreTasks(Task task) {
		logger.getLogger().info("toggle showmore status of " + task);
		if (_showMoreTasks.contains(task)) {
			_showMoreTasks.remove(task);
		} else {
			_showMoreTasks.add(task);
		}
	}

	/**
	 * Method for setting status of all task to not showing more.
	 */
	public void clearShowMoreTasks() {
		_showMoreTasks.clear();
	}

	/**
	 * Method to get current file directory.
	 * 
	 * @return _storage.getDirPath
	 */
	public String retrieveCurrentDirectory() {
		return _storage.getDirPath();
	}

	/**
	 * Method for changing file directory of where task is saved to.
	 * 
	 * @param path
	 *            The String path specified for changing of current directory to
	 *            the new one.
	 * @throws StorageException
	 *             if invalid input format.
	 * @throws InvalidFolderException
	 *             if folder to be saved to does not exist.
	 */
	public void changeDirectory(String path) throws StorageException, InvalidFolderException {
		_storage.changeFileSettings(path);
	}

	/**
	 * Method for retrieving all the tasks in tasklist that a specified task
	 * overlaps with.
	 * 
	 * @param newTask
	 *            The task used for comparing with all other tasks in LogicData
	 *            for searching of overlap in timing.
	 * @return ArrayList of overlapping tasks
	 */
	public ArrayList<Task> overlappingTasks(Task newTask) {
		ArrayList<Task> overlaps = new ArrayList<Task>();

		for (Task task : _tasks) {
			if (!task.equals(newTask)) {
				if (task.getTaskType() == Task.Type.EVENT) {
					if (task.isOverlapping(newTask)) {
						overlaps.add(task);
					}
				}
				// case when there are multiple slots, multiple copies of
				// overlaps are added
				if (task.getSlot() != null && !task.getSlot().isEmpty()) {
					getOverlapsWithinSlots(newTask, overlaps, task);
				}
			}
		}

		return overlaps;
	}

	private void getOverlapsWithinSlots(Task newTask, ArrayList<Task> overlaps, Task task) {
		MultipleSlot slot = new MultipleSlot(task.getSlot());
		while (!slot.isEmpty()) {
			DateTimePair pair = slot.getNextSlot();
			slot.removeNextSlot();
			Task currTask = new Task(task.getDesc(), task.getLocation(), pair.getDateTime1(),
					pair.getDateTime2());
			if (currTask.isOverlapping(newTask)) {
				overlaps.add(currTask);
			}
		}
	}

	/**
	 * Method for removing archived tasks that are beyond one month old
	 */
	public void clearOldArchive() {
		ArrayList<Task> outdatedTasks = new ArrayList<Task>();
		for (Task task : _archives) {
			if (task.getDateModified().isBefore(LocalDateTime.now().minusMonths(1))) {
				outdatedTasks.add(task);
			}
		}
		_archives.removeAll(outdatedTasks);
	}

	/**
	 * Method for checking whether taskpointer is currently pointing to an
	 * archived task. If yes, set Displaystate as archive.
	 */
	public void checkPointer() {
		if (_taskPointer != null) {
			if (_archives.contains(_taskPointer)) {
				_currState = LogicData.DisplayState.ARCHIVE;
			}
		}
	}

	/**
	 * Method to reinitialise Storage, called upon very launch of program.
	 */
	public void reinitialiseStorage() {
		_storage = new Storage();
		_tasks = _storage.updateCurrentTaskList();
		_archives = _storage.updateArchiveTaskList();
	}

	/**
	 * Method for to reinitialise Storage for integration testing.
	 */
	public void reinitialiseStorageTester() {
		_storage.delete();
		_storage = new StorageTester();
		_tasks = _storage.updateCurrentTaskList();
		_archives = _storage.updateArchiveTaskList();
	}

	/**
	 * Method for retrieving demo file stored in storage.
	 * 
	 * @return _storage.getDemoText().
	 */
	public ArrayList<String> generateDemoText() {
		return _storage.getDemoText();
	}

	/**
	 * Method for retrieving Indexes selected for demo.
	 * 
	 * @return _storage.getDemoSelectionIndexes().
	 */
	public ArrayList<Integer> generateDemoSelectionIndexes() {
		return _storage.getDemoSelectionIndexes();
	}

	/**
	 * Method for retrieving settings for novice view.
	 * 
	 * @return _storage.getNoviceSettings();
	 */
	public boolean getNoviceSettings() {
		return _storage.getNoviceSettings();
	}

	/**
	 * Sets the novice or advanced view settings.
	 * 
	 * @param isNovice
	 *            boolean to show novice or advanced view
	 */
	public void setNoviceSettings(boolean isNovice) {
		_storage.setNoviceSettings(isNovice);
	}

}
```
###### src\urgenda\util\Task.java
``` java
package urgenda.util;

import java.time.LocalDateTime;
import java.util.ArrayList;

/**
 * Task class of Utils component in Urgenda. Used for storing of information
 * related to a task e.g. timings, location, desc etc.
 *
 */
public class Task {

	private static UrgendaLogger logger = UrgendaLogger.getInstance();

	private static final String TASK_TYPE_FLOATING = "FLOATING";
	private static final String TASK_TYPE_EVENT = "EVENT";
	private static final String TASK_TYPE_DEADLINE = "DEADLINE";

	/**
	 * 
	 * Different categorisation of tasks.
	 *
	 */
	public enum Type {
		// Event type have start + end time
		EVENT,
		// Deadline type has only end time
		DEADLINE,
		// Floating type has no start and no end time
		FLOATING
	}

	private int _id;
	private String _desc;
	private Type _taskType;
	private String _location;
	private LocalDateTime _startTime;
	private LocalDateTime _endTime;
	private LocalDateTime _dateAdded;
	private LocalDateTime _dateModified;
	private boolean _isCompleted = false;
	private boolean _isImportant = false;
	private boolean _isOverdue = false;
	private MultipleSlot _slot;

	/**
	 * Default constructor for creating a Task object.
	 */
	public Task() {

	}

	/**
	 * Alternative constructor for Task object with String desc specified
	 * 
	 * @param desc
	 *            The String desc of the Task.
	 */
	public Task(String desc) {
		_desc = desc;
		updateTaskType(null, null);
	}

	/**
	 * Alternative constructor for Task object with inclusion of basic details
	 * and priority status.
	 * 
	 * @param desc
	 *            The String desc of the Task.
	 * @param location
	 *            The String location of the Task.
	 * @param start
	 *            The LocalDateTime starting date and time of the Task.
	 * @param end
	 *            The LocalDateTime ending date and time of the Task.
	 * @param isImportant
	 *            The boolean priority status of the Task.
	 */
	public Task(String desc, String location, LocalDateTime start, LocalDateTime end, boolean isImportant) {
		_desc = desc;
		_location = location;
		updateTaskType(start, end);
		_startTime = start;
		_endTime = end;
		_dateAdded = LocalDateTime.now();
		_dateModified = LocalDateTime.now();
		_isImportant = isImportant;
	}

	/**
	 * Alternative constructor for Task object with inclusion of basic details
	 * w/o priority status.
	 * 
	 * @param desc
	 *            The String desc of the Task.
	 * @param location
	 *            The String location of the Task.
	 * @param start
	 *            The LocalDateTime starting date and time of the Task.
	 * @param end
	 *            The LocalDateTime ending date and time of the Task.
	 */
	public Task(String desc, String location, LocalDateTime start, LocalDateTime end) {
		_desc = desc;
		_location = location;
		updateTaskType(start, end);
		_startTime = start;
		_endTime = end;
		_dateAdded = LocalDateTime.now();
		_dateModified = LocalDateTime.now();
	}

	/**
	 * A constructor for creating duplicate copy of a task.
	 * 
	 * @param originalTask
	 *            The Task object to be duplicated.
	 */
	public Task(Task originalTask) {
		setId(originalTask.getId());
		setDesc(originalTask.getDesc());
		setTaskType(originalTask.getTaskType());
		setLocation(originalTask.getLocation());
		setStartTime(originalTask.getStartTime());
		setEndTime(originalTask.getEndTime());
		setDateAdded(originalTask.getDateAdded());
		setDateModified(originalTask.getDateModified());
		setIsCompleted(originalTask.isCompleted());
		setIsImportant(originalTask.isImportant());
		setIsOverdue(originalTask.isOverdue());
		setSlot(originalTask.getSlot());
	}

	/**
	 * Full constructor for all variables.
	 * 
	 * @param type
	 *            required to be of String type, will be converted to enum Type
	 *            in constructor
	 */
	public Task(int id, String desc, String type, String location, boolean isCompleted, boolean isImportant,
			boolean isOverdue, LocalDateTime startTime, LocalDateTime endTime, LocalDateTime dateAdded,
			LocalDateTime dateModified, MultipleSlot slot) {
		_id = id;
		_desc = desc;
		setType(type);
		_location = location;
		_isCompleted = isCompleted;
		_isImportant = isImportant;
		_isOverdue = isOverdue;
		_startTime = startTime;
		_endTime = endTime;
		_dateAdded = dateAdded;
		_dateModified = dateModified;
		_slot = slot;

	}

	private void setType(String type) {
		if (type.equalsIgnoreCase(TASK_TYPE_EVENT)) {
			_taskType = Type.EVENT;
		} else if (type.equalsIgnoreCase(TASK_TYPE_DEADLINE)) {
			_taskType = Type.DEADLINE;
		} else if (type.equalsIgnoreCase(TASK_TYPE_FLOATING)) {
			_taskType = Type.FLOATING;
		}
	}

	/**
	 * This method is used for updating the type of a task based on the start
	 * and end time provided.
	 * 
	 * @param start
	 *            LocalDateTime starting date and time of the task.
	 * @param end
	 *            LocalDateTime ending date and time of the task.
	 */
	public void updateTaskType(LocalDateTime start, LocalDateTime end) {
		if (start == null && end == null) {
			_taskType = Type.FLOATING;
		} else if (start == null && end != null) {
			_taskType = Type.DEADLINE;
		} else if (start != null && end != null) {
			_taskType = Type.EVENT;
		}
	}

	/**
	 * This method is for updating the type of a task based on its own internal
	 * start and end time attributes.
	 */
	public void updateTaskType() {
		if (_startTime == null && _endTime == null) {
			_taskType = Type.FLOATING;
		} else if (_startTime == null && _endTime != null) {
			_taskType = Type.DEADLINE;
		} else if (_startTime != null && _endTime != null) {
			_taskType = Type.EVENT;
		}
	}

	/**
	 * Getter for the id of a task.
	 * 
	 * @return _id the int private attribute of a task object.
	 */
	public int getId() {
		return _id;
	}

	/**
	 * Getter for the desc of a task.
	 * 
	 * @return _desc the String private attribute of a task object.
	 */
	public String getDesc() {
		return _desc;
	}

	/**
	 * Getter for the tasktype of a task.
	 * 
	 * @return _taskType the private enum private attribute of a task object.
	 */
	public Type getTaskType() {
		return _taskType;
	}

	/**
	 * Getter for the location of a task.
	 * 
	 * @return _location the String private attribute of a task object.
	 */
	public String getLocation() {
		return _location;
	}

	/**
	 * Getter for the start datetime of a task object.
	 * 
	 * @return _startTime the LocalDateTime private attribute of a task object.
	 */
	public LocalDateTime getStartTime() {
		return _startTime;
	}

	/**
	 * Getter for the end datetime of a task object.
	 * 
	 * @return _endTime the LocalDateTime private attribute of a task object.
	 */
	public LocalDateTime getEndTime() {
		return _endTime;
	}

	/**
	 * Getter for the datetime at which a task object was added.
	 * 
	 * @return _dateAdded the LocalDateTime private attribute of a task object.
	 */
	public LocalDateTime getDateAdded() {
		return _dateAdded;
	}

	/**
	 * Getter for the datetime at which a task object has been last edited.
	 * 
	 * @return _dateModified the LocalDateTime private attribute of a task
	 *         object.
	 */
	public LocalDateTime getDateModified() {
		return _dateModified;
	}

	/**
	 * Getter for the complete status of a task object.
	 * 
	 * @return true if task has been set as completed, false otherwise.
	 */
	public boolean isCompleted() {
		return _isCompleted;
	}

	/**
	 * Getter for the priority status of a task object.
	 * 
	 * @return true if task has been marked as important, false otherwise.
	 */
	public boolean isImportant() {
		return _isImportant;
	}

	/**
	 * Getter for the overdue status of a task object.
	 * 
	 * @return true if task has been set as overdue, false otherwise.
	 */
	public boolean isOverdue() {
		return _isOverdue;
	}

	/**
	 * Getter for the MultipleSlot (multiple timings for the same task)
	 * attribute of a task.
	 * 
	 * @return _slot The private MultpleSlot attribute of a task object.
	 */
	public MultipleSlot getSlot() {
		return _slot;
	}

	/**
	 * Setter for the id of a task.
	 * 
	 * @param id
	 *            the int id to be set to a task.
	 */
	public void setId(int id) {
		_id = id;
	}

	/**
	 * Setter for the description of a task.
	 * 
	 * @param desc
	 *            the String to be set to a task's desc attribute.
	 */
	public void setDesc(String desc) {
		_desc = desc;
	}

	/**
	 * Setter for the taskType of a task
	 * 
	 * @param taskType
	 *            the Type enum to be set to a task.
	 */
	public void setTaskType(Type taskType) {
		_taskType = taskType;
	}

	/**
	 * Setter for the Location of a task.
	 * 
	 * @param location
	 *            the String to be set to a task's location attribute.
	 */
	public void setLocation(String location) {
		_location = location;
	}

	/**
	 * Setter for the start datetime of a task.
	 * 
	 * @param startTime
	 *            the LocalDateTime to be set as a task's start time.
	 */
	public void setStartTime(LocalDateTime startTime) {
		_startTime = startTime;
	}

	/**
	 * Setter for the start datetime of a task.
	 * 
	 * @param endTime
	 *            the LocalDateTime to be set as a task's end time.
	 */
	public void setEndTime(LocalDateTime endTime) {
		_endTime = endTime;
	}

	/**
	 * Setter for the datetime at which a task was added.
	 * 
	 * @param dateAdded
	 *            the LocalDateTime to be set to the dateadded of a task's .
	 */
	public void setDateAdded(LocalDateTime dateAdded) {
		_dateAdded = dateAdded;
	}

	/**
	 * Setter for the datetime at which a task was last edited.
	 * 
	 * @param dateModified
	 *            the LocalDateTime to be set to the datemodified of a task's
	 */
	public void setDateModified(LocalDateTime dateModified) {
		_dateModified = dateModified;
	}

	/**
	 * Setter for the complete status of a task.
	 * 
	 * @param isCompleted
	 *            the boolean to be set as the complete status of a task.
	 */
	public void setIsCompleted(boolean isCompleted) {
		_isCompleted = isCompleted;
	}

	/**
	 * Setter for the priority status of a task.
	 * 
	 * @param isImportant
	 *            the boolean to be set as the priority status of a task
	 */
	public void setIsImportant(boolean isImportant) {
		_isImportant = isImportant;
	}

	/**
	 * Setter for the overdue status of a task.
	 * 
	 * @param isOverdue
	 *            the boolean to be set as the overdue status of a task
	 */
	public void setIsOverdue(boolean isOverdue) {
		_isOverdue = isOverdue;
	}

	/**
	 * Setter for the Multiple timeslot of a task.
	 * 
	 * @param slot
	 *            the MultipleSlot object to be set as the multi time slot of a
	 *            task.
	 */
	public void setSlot(MultipleSlot slot) {
		_slot = slot;
	}

	/**
	 * This method is used for toggling the priority status of a task. if the
	 * task is originally set as important then set it to unmarked as
	 * non-important, vice versa
	 */
	public void toggleImportant() {
		if (_isImportant) {
			_isImportant = false;
		} else {
			_isImportant = true;
		}
	}

	/**
	 * This method is for checking whether a given task overlaps with other task
	 * within a list.
	 * 
	 * @param task
	 *            the task object to be checked and compared.
	 * @return true if the given task overlaps with others, false otherwise.
	 */
	public boolean isOverlapping(Task task) {
		// defensive code to prevent checking of non event types
		if (task.getTaskType() != Task.Type.EVENT || this.getTaskType() != Task.Type.EVENT) {
			return false;
		}
		LocalDateTime start = task.getStartTime();
		LocalDateTime end = task.getEndTime();
		// checks overlaps if there are multiple slots
		if (this.getSlot() != null) {
			logger.getLogger().info("checking for overlap within multipleslot");
			ArrayList<DateTimePair> slots = this.getSlot().getSlots();
			for (DateTimePair pair : slots) {
				if (hasOverlap(start, end, pair.getEarlierDateTime(), pair.getLaterDateTime())) {
					return true;
				}
			}
		}
		// checks for the initial timings in task
		return hasOverlap(start, end, _startTime, _endTime);
	}

	/**
	 * This method is used for checking whether two given sets of timing
	 * overlaps with one another
	 * 
	 * @param start
	 * @param end
	 * @param compareStart
	 * @param compareEnd
	 * @return true if they overlap, false otherwise.
	 */
	public boolean hasOverlap(LocalDateTime start, LocalDateTime end, LocalDateTime compareStart,
			LocalDateTime compareEnd) {
		if (end.isAfter(compareStart) && (end.isBefore(compareEnd) || end.isEqual(compareEnd))) {
			return true;
		} else if ((start.isAfter(compareStart) || start.isEqual(compareStart))
				&& start.isBefore(compareEnd)) {
			return true;
		} else if (start.isBefore(compareStart) && end.isAfter(compareEnd)) {
			return true;
		} else if (start.isEqual(compareStart) && end.isEqual(compareEnd)) {
			return true;
		} else {
			return false;
		}
	}

}
```
###### src\urgenda\util\TaskList.java
``` java
package urgenda.util;

import java.util.ArrayList;

/**
 * TaskList class of the Utils component in Urgenda. Used for containg multiple
 * ArrayLists of Task objects into one object. Mainly used by the GUI component.
 *
 */
public class TaskList {

	private ArrayList<Task> _tasks;
	private ArrayList<Task> _archives;
	private int _overdueCount;
	private int _todayCount;
	private int _remainingCount;
	private int _archiveCount;

	/**
	 * Default constructor for creating an empty TaskList object.
	 */
	public TaskList() {
		_tasks = new ArrayList<Task>();
		_archives = new ArrayList<Task>();
		setOverdueCount(0);
		setTodayCount(0);
		setRemainingCount(0);
		setArchiveCount(0);
	}

	/**
	 * Constructor for creating a TaskList that contains only current ongoing
	 * Tasks.
	 * 
	 * @param tasks
	 *            the ArrayList of overdued tasks
	 * @param overdue
	 *            the int number of overdued tasks.
	 * @param today
	 *            the int number of tasks that falls on today.
	 * @param remaining
	 *            the int number of tasks that are in the arraylist but does not
	 *            belong to above two categories.
	 */
	public TaskList(ArrayList<Task> tasks, int overdue, int today, int remaining) {
		_tasks = tasks;
		_archives = new ArrayList<Task>();
		setOverdueCount(overdue);
		setTodayCount(today);
		setRemainingCount(remaining);
		setArchiveCount(0);
	}

	/**
	 * Constructor for creating a TaskList that contains completed and
	 * non-completed Tasks.
	 * 
	 * @param tasks
	 *            the ArrayList of current tasks
	 * @param archives
	 *            the ArrayList of completed tasks
	 * @param overdue
	 *            the int number of overdued tasks
	 * @param today
	 *            the int number of tasks that falls on today.
	 * @param remaining
	 *            the int number of tasks that are from the current task
	 *            arraylist but does not belong to above two categories.
	 * @param archive
	 *            the int number of tasks that are the archive arraylist.
	 */
	public TaskList(ArrayList<Task> tasks, ArrayList<Task> archives, int overdue, int today, int remaining,
			int archive) {
		_tasks = tasks;
		_archives = archives;
		setOverdueCount(overdue);
		setTodayCount(today);
		setRemainingCount(remaining);
		setArchiveCount(archive);
	}

	/**
	 * Constructor for creating a TaskList that contains only completed Tasks.
	 * 
	 * @param archives
	 *            the arraylist of completed tasks
	 * @param archive
	 *            the int number of completed tasks.
	 */
	public TaskList(ArrayList<Task> archives, int archive) {
		_tasks = new ArrayList<Task>();
		_archives = archives;
		setOverdueCount(0);
		setTodayCount(0);
		setRemainingCount(0);
		setArchiveCount(archive);
	}

	/**
	 * Getter for the current ongoing task in a TaskList object.
	 * 
	 * @return _tasks the ArrayList private attribute of a TaskList object
	 */
	public ArrayList<Task> getTasks() {
		return _tasks;
	}

	/**
	 * Getter for the number of overdue tasks in a TaskList object.
	 * 
	 * @return _overdueCount
	 */
	public int getOverdueCount() {
		return _overdueCount;
	}

	/**
	 * Setter for setting the number of overdue tasks in TaskList object.
	 * 
	 * @param overdueCount
	 *            the int to be set to the overdueCount attribute of a TaskList
	 */
	public void setOverdueCount(int overdueCount) {
		_overdueCount = overdueCount;
	}

	/**
	 * Getter for the number of tasks falling on today in a TaskList object.
	 * 
	 * @return _todayCount
	 */
	public int getTodayCount() {
		return _todayCount;
	}

	/**
	 * Setter for setting the number of tasks falling on today in TaskList
	 * object.
	 * 
	 * @param todayCount
	 *            the int to be set to the todayCount attribute of a TaskList.
	 */
	public void setTodayCount(int todayCount) {
		_todayCount = todayCount;
	}

	/**
	 * Getter for the number of tasks that falls in other category in a TaskList
	 * object.
	 * 
	 * @return _remainingCount
	 */
	public int getRemainingCount() {
		return _remainingCount;
	}

	/**
	 * Setter for the number of other tasks in a TaskList object.
	 * 
	 * @param remainingCount
	 *            the int to be set to the remainingCount attribute of a
	 *            TaskList.
	 */
	public void setRemainingCount(int remainingCount) {
		_remainingCount = remainingCount;
	}

	/**
	 * Getter for retrieving the ArrayList of completed tasks in a TaskList
	 * object.
	 * 
	 * @return _archives
	 */
	public ArrayList<Task> getArchives() {
		return _archives;
	}

	/**
	 * Getter for the number of completed tasks in a TaskList object.
	 * 
	 * @return _archiveCount
	 */
	public int getArchiveCount() {
		return _archiveCount;
	}

	/**
	 * Setter for the list of completed tasks in a TaskList object.
	 * 
	 * @param archives
	 *            The ArrayList of Tasks to be set to the _archive attribute of
	 *            a TaskList.
	 */
	public void setArchives(ArrayList<Task> archives) {
		_archives = archives;
	}

	/**
	 * Setter for the number of completed tasks in a TaskList object.
	 * 
	 * @param archiveCount
	 *            the int to be set to the _archiveCount of a TaskList object.
	 */
	public void setArchiveCount(int archiveCount) {
		_archiveCount = archiveCount;
	}

	/**
	 * Getter for the total number of uncompleted tasks within a TaskList
	 * object.
	 * 
	 * @return sum of number of overdue, today and others tasks.
	 */
	public int getUncompletedCount() {
		return _overdueCount + _todayCount + _remainingCount;
	}

}
```
###### src\urgenda\util\UrgendaLogger.java
``` java
package urgenda.util;

import java.io.File;
import java.io.IOException;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

/**
 * UrgendaLogger a the class under Utils component. It is used for logging and tracking of 
 * performance of Urgenda. It is global to all other components.
 *
 */
public class UrgendaLogger {
	
	private final static Logger myLogger = Logger.getLogger(UrgendaLogger.class.getName());
	private static UrgendaLogger _loggerInstance = null;
	
	private static File _parentDir;

	/**
	 * Singleton constructor of UrgendaLogger so that all classes uses the same logger and 
	 * logging could be appended to a single log file.
	 * @return _loggerInstance
	 * The instance of Singleton pattern UrgendaLogger.
	 */
	public static UrgendaLogger getInstance() {
		if (_loggerInstance == null) {
			setUpLogger();
			_loggerInstance = new UrgendaLogger();
		}
		return _loggerInstance;
	}

	/**
	 * This method is for configuration and setting up of logger.
	 */
	private static void setUpLogger() {
		try {
			createFileSettings();
			FileHandler fh = new FileHandler("settings/UrgendaLog.txt");
			fh.setFormatter(new SimpleFormatter());
			myLogger.addHandler(fh);
			myLogger.setUseParentHandlers(false);
			myLogger.setLevel(Level.FINEST);
		} catch (IOException e) {
			myLogger.log(Level.SEVERE, "Error occur in FileHandler.", e);
		}
	}
	
	private static void createFileSettings() {
		_parentDir = new File("settings");
		_parentDir.mkdir();
		
	}

	/**
	 * Getter for the private attribute of UrgendaLogger class.
	 * @return myLogger
	 * The logger used for logging.
	 */
	public Logger getLogger() {
		return myLogger;
	}

}
```
